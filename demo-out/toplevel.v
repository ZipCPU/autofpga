////////////////////////////////////////////////////////////////////////////////
//
// Filename:	../demo-out/toplevel.v
//
// Project:	AutoFPGA, a utility for composing FPGA designs from peripherals
// {{{
// Computer Generated: This file is computer generated by AUTOFPGA. DO NOT EDIT.
// DO NOT EDIT THIS FILE!
//
// CmdLine:	./autofpga -d -o ../demo-out -I ../auto-data allclocks.txt bkram.txt buserr.txt clkcheck.txt crossbus.txt ddr3.txt edidslvscope.txt edid.txt exconsole.txt flashcfg.txt flash.txt global.txt gpio.txt gps.txt hdmi.txt i2ccpu.txt i2cdma.txt i2saudio.txt icape.txt meganet.txt mdio.txt pic.txt pwrcount.txt rtcdate.txt rtcgps.txt spio.txt sdio.txt vadj33.txt version.txt wboledbw.txt wbpmic.txt wbuarbiter.txt wbubus.txt zipcpu.txt zipmaster.txt
//
// Creator:	Dan Gisselquist, Ph.D.
//		Gisselquist Technology, LLC
//
////////////////////////////////////////////////////////////////////////////////
// }}}
// Copyright (C) 2017-2024, Gisselquist Technology, LLC
// {{{
// This program is free software (firmware): you can redistribute it and/or
// modify it under the terms of the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License, or (at
// your option) any later version.
//
// This program is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// for more details.
//
// You should have received a copy of the GNU General Public License along
// with this program.  (It's in the $(ROOT)/doc directory.  Run make with no
// target there if the PDF file isn't present.)  If not, see
// <http://www.gnu.org/licenses/> for a copy.
// }}}
// License:	GPL, v3, as defined and found on www.gnu.org,
// {{{
//		http://www.gnu.org/licenses/gpl.html
//
//
////////////////////////////////////////////////////////////////////////////////
//
// }}}
`default_nettype	none


//
// Here we declare our toplevel.v (toplevel) design module.
// All design logic must take place beneath this top level.
//
// The port declarations just copy data from the @TOP.PORTLIST
// key, or equivalently from the @MAIN.PORTLIST key if
// @TOP.PORTLIST is absent.  For those peripherals that don't need
// any top level logic, the @MAIN.PORTLIST should be sufficent,
// so the @TOP.PORTLIST key may be left undefined.
//
// The only exception is that any clocks with CLOCK.TOP tags will
// also appear in this list
//
module	toplevel(i_clk,
		// Top level Quad-SPI I/O ports
		o_flash_cs_n, io_flash_dat,
			io_scl, io_sda,
		// UART/host to wishbone interface
		i_wbu_uart_rx, o_wbu_uart_tx,
			io_hdmitx_scl, io_hdmitx_sda,
		// The GPS-UART
		i_gpsu_rx, o_gpsu_tx,
		i_hdmirx_clk_p, i_hdmirx_clk_n,
		i_hdmirx_p, i_hdmirx_n,
		o_hdmitx_clk_p, o_hdmitx_clk_n,
		o_hdmitx_p, o_hdmitx_n,
		// EDID RX definitions
		io_hdmirx_scl, io_hdmirx_sda,
		// DDR3 I/O port wires
		o_ddr3_reset_n, o_ddr3_cke, o_ddr3_clk_p, o_ddr3_clk_n,
			o_ddr3_vsel,
		o_ddr3_cs_n, o_ddr3_ras_n, o_ddr3_cas_n, o_ddr3_we_n,
		o_ddr3_ba, o_ddr3_a,
		o_ddr3_odt, o_ddr3_dm,
		io_ddr3_dqs_p, io_ddr3_dqs_n, io_ddr3_dq,
		o_i2s_lrclk, o_i2s_bclk, o_i2s_mclk, o_i2s_dac, i_i2s_adc,
		// Ethernet control (packets) lines
		o_net_reset_n,
		i_net_rx_clk, i_net_rx_ctl, i_net_rxd,
		o_net_tx_clk, o_net_tx_ctl, o_net_txd,
		// SPIO interface
		i_sw, i_btnc, i_btnd, i_btnl, i_btnr, i_btnu, o_led,
		// GPIO ports
		o_hdmirx_hpa,	// Hotplug assert
		o_hdmirx_txen,
		i_hdmitx_hpd_n, // Hotplug detect
		o_sd_reset,
		i_gps_3df,
		o_oled_reset_n, o_oled_panel_en, o_oled_logic_en,
		// SDIO SD Card

o_sd_clk,
i_sd_cd_n,

		io_sd_cmd, io_sd_dat,
		// VADJ ports
		o_vadj_en, o_vadj,
		// The GPS 1PPS signal port
		i_gps_pps,
		// Toplevel ethernet MDIO ports
		o_eth_mdclk, io_eth_mdio,
		// OLED control interface (roughly SPI)
		o_oled_sck, o_oled_mosi, o_oled_dcn,
		// The PMic3 microphone wires
		o_mic_csn, o_mic_sck, i_mic_din);
	//
	// Declaring any top level parameters.
	//
	// These declarations just copy data from the @TOP.PARAM key,
	// or from the @MAIN.PARAM key if @TOP.PARAM is absent.  For
	// those peripherals that don't do anything at the top level,
	// the @MAIN.PARAM key should be sufficient, so the @TOP.PARAM
	// key may be left undefined.
	//
	////////////////////////////////////////////////////////////////////////
	//
	// EXBUS parameters
	// {{{
	// Baudrate :   1000000
	// Clock    : 100000000
	localparam [23:0] BUSUART = 24'h64;	//   1000000 baud
	localparam	DBGBUSBITS = $clog2(BUSUART);
	// }}}
	localparam	ICAPE_LGDIV=3;
	localparam real SDRAMCONTROLLER_CLK_PERIOD = 10_000,  //ps, clock period of the controller interface
		DDR3_CLK_PERIOD = 2_500; //ps, clock period of the DDR3 RAM device (must be 1/4 of the CONTROLLER_CLK_PERIOD) 
	localparam SDRAMROW_BITS = 14,  // width of row address
		SDRAMCOL_BITS = 10,  // width of column address
		SDRAMBA_BITS  =  3,  // width of bank address
		SDRAMDQ_BITS  =  8,  // Size of one octet
		SDRAMBYTE_LANES = 2, //8 lanes of DQ
		SDRAMAUX_WIDTH = 4, //width of aux line (must be >= 4) 
		SDRAMSERDES_RATIO = $rtoi(SDRAMCONTROLLER_CLK_PERIOD/DDR3_CLK_PERIOD),
		//4 is the width of a single ddr3 command {cs_n, ras_n, cas_n, we_n} plus 3 (ck_en, odt, reset_n) plus bank bits plus row bits
		SDRAMCMD_LEN = 4 + 3 + SDRAMBA_BITS + SDRAMROW_BITS;


	parameter	[15:0]	UDP_DBGPORT  = 6784;

	localparam	[47:0]	DEF_HWMAC  = 48'h82_33_48_02_e1_c8;
	localparam	[31:0]	DEF_IPADDR = { 8'd192, 8'd168, 8'd15, 8'd29 };
	localparam [31:0] GPSCLOCK_DEFAULT_STEP = 32'haabcc771;
	////////////////////////////////////////////////////////////////////////
	//
	// Variables/definitions/parameters used by the ZipCPU bus master
	// {{{
	//
	// A 32-bit address indicating where the ZipCPU should start running
	// from
`ifdef	BKROM_ACCESS
	localparam	RESET_ADDRESS = @$(/bkrom.BASE);
`else
`ifdef	FLASH_ACCESS
	localparam	RESET_ADDRESS = 23068672;
`else
	localparam	RESET_ADDRESS = 268435456;
`endif	// FLASH_ACCESS
`endif	// BKROM_ACCESS
	//
	// The number of valid bits on the bus
	localparam	ZIP_ADDRESS_WIDTH = 27; // Zip-CPU address width
	//
	// Number of ZipCPU interrupts
	localparam	ZIP_INTS = 16;
	//
	// ZIP_START_HALTED
	//
	// A boolean, indicating whether or not the ZipCPU be halted on startup?
`ifdef	BKROM_ACCESS
	localparam	ZIP_START_HALTED=1'b0;
`else
	localparam	ZIP_START_HALTED=1'b1;
`endif
	// }}}
	//
	// Declaring our input and output ports.  We listed these above,
	// now we are declaring them here.
	//
	// These declarations just copy data from the @TOP.IODECLS key,
	// or from the @MAIN.IODECL key if @TOP.IODECL is absent.  For
	// those peripherals that don't do anything at the top level,
	// the @MAIN.IODECL key should be sufficient, so the @TOP.IODECL
	// key may be left undefined.
	//
	// We start with any @CLOCK.TOP keys
	//
	input	wire		i_clk;
	// Quad SPI flash
	output	wire		o_flash_cs_n;
	inout	wire	[3:0]	io_flash_dat;
	inout	wire	io_scl, io_sda;
	input	wire		i_wbu_uart_rx;
	output	wire		o_wbu_uart_tx;
	inout	wire	io_hdmitx_scl, io_hdmitx_sda;
	input	wire		i_gpsu_rx;
	output	wire		o_gpsu_tx;
	input	wire		i_hdmirx_clk_p, i_hdmirx_clk_n;
	input	wire	[2:0]	i_hdmirx_p, i_hdmirx_n;
	output	wire		o_hdmitx_clk_p, o_hdmitx_clk_n;
	output	wire	[2:0]	o_hdmitx_p, o_hdmitx_n;
	// EDID RX definitions
	inout	wire	io_hdmirx_scl, io_hdmirx_sda;
	// I/O declarations for the DDR3 SDRAM
	// {{{
	output	wire		o_ddr3_reset_n;
	output	wire	[0:0]	o_ddr3_cke;
	output	wire	[0:0]	o_ddr3_clk_p, o_ddr3_clk_n;
	output	wire	[0:0]	o_ddr3_cs_n; // o_ddr3_s_n[1] is set to 0 since controller only support single rank
	output	wire		o_ddr3_vsel;
	output	wire	[0:0]	o_ddr3_ras_n, o_ddr3_cas_n, o_ddr3_we_n;
	output	wire	[SDRAMBA_BITS-1:0]	o_ddr3_ba;
	output	wire	[14:0]	o_ddr3_a; //set to max of 16 bits, but only ROW_BITS bits are relevant
	output	wire	[0:0]	o_ddr3_odt;
	output	wire	[SDRAMBYTE_LANES-1:0]	o_ddr3_dm;
	inout	wire	[(SDRAMDQ_BITS*SDRAMBYTE_LANES)/8-1:0]	io_ddr3_dqs_p, io_ddr3_dqs_n;
	inout	wire	[(SDRAMDQ_BITS*SDRAMBYTE_LANES)-1:0]	io_ddr3_dq;
	// }}}

	output	wire	o_i2s_lrclk, o_i2s_bclk, o_i2s_mclk, o_i2s_dac;
	input	wire	i_i2s_adc;
	// MegaNet I/O port declarations
	// {{{
	output	wire		o_net_reset_n;
	input	wire		i_net_rx_clk, i_net_rx_ctl;
	input	wire [3:0]	i_net_rxd;
	output	wire	 	o_net_tx_clk, o_net_tx_ctl;
	output	wire [3:0]	o_net_txd;
	// }}}
	// SPIO interface
	input	wire	[8-1:0]	i_sw;
	input	wire		i_btnc, i_btnd, i_btnl, i_btnr, i_btnu;
	output	wire	[8-1:0]	o_led;
	// GPIO ports
	output	wire	o_hdmirx_hpa;
	output	wire	o_hdmirx_txen;
	input	wire	i_hdmitx_hpd_n;		// Hotplug detect
	output	wire	o_sd_reset;
	input	wire	i_gps_3df;
	output	wire	o_oled_reset_n, o_oled_panel_en, o_oled_logic_en;
	// SDIO SD Card
	// {{{

	output	wire		o_sd_clk;


	input	wire		i_sd_cd_n;

	inout	wire		io_sd_cmd;
	inout	wire	[4-1:0]	io_sd_dat;
	// }}}
	// VADJ wires
	output	wire		o_vadj_en;
	output	wire [1:0]	o_vadj;
	//The GPS Clock
	input	wire		i_gps_pps;
	// Ethernet control (MDIO)
	output	wire		o_eth_mdclk;
	inout	wire		io_eth_mdio;
	// OLEDBW interface
	output	wire		o_oled_sck, o_oled_mosi, o_oled_dcn;
	output	wire		o_mic_csn, o_mic_sck;
	input	wire		i_mic_din;


	//
	// Declaring component data, internal wires and registers
	//
	// These declarations just copy data from the @TOP.DEFNS key
	// within the component data files.
	//
	wire		w_flash_sck, w_flash_cs_n;
	wire	[1:0]	flash_bmod;
	wire	[3:0]	flash_dat;
	// I2CCPU definitions
	// {{{
	wire	i_i2c_sda, i_i2c_scl,
		o_i2c_sda, o_i2c_scl;
	// }}}
	// I2CCPU definitions
	// {{{
	wire	i_edid_sda, i_edid_scl,
		o_edid_sda, o_edid_scl;
	// }}}
	wire	[9:0]	hdmirx_red, hdmirx_grn, hdmirx_blu;
	wire	[9:0]	hdmitx_red, hdmitx_grn, hdmitx_blu;
	wire	[1:0]	w_pxclk_cksel;
	wire		hdmirx_clk, hdmi_ck, hdmi_serdes_clk;
	wire		pxrx_locked, pix_reset_n, hdmirx_reset_n;
	wire [15-1:0]	set_hdmi_delay, actual_hdmi_delay;
	wire	w_edidslv_scl, w_edidslv_sda;
	wire		s_clk, s_reset;
	reg	[2:0]	clk_reset_pipe;
	// Wires connected to PHY interface of DDR3 controller
	// {{{
	genvar ddr3gen_index;

	wire	[SDRAMDQ_BITS*SDRAMBYTE_LANES*8-1:0] ddr3_iserdes_data;
	wire	[SDRAMBYTE_LANES*8-1:0] ddr3_iserdes_dqs,
				ddr3_iserdes_bitslip_reference;
	wire    [SDRAMCMD_LEN*SDRAMSERDES_RATIO-1:0]
				ddr3_cmd;
	wire    [SDRAMDQ_BITS*SDRAMBYTE_LANES*8-1:0]
				ddr3_data;
	wire    [(SDRAMDQ_BITS*SDRAMBYTE_LANES*8)/8-1:0]
				ddr3_dm;
	wire    [4:0]	ddr3_odelay_data_cntvaluein,
			ddr3_odelay_dqs_cntvaluein,
			ddr3_idelay_data_cntvaluein,
			ddr3_idelay_dqs_cntvaluein;
	wire    [SDRAMBYTE_LANES-1:0]	ddr3_odelay_data_ld,
			ddr3_odelay_dqs_ld, ddr3_idelay_data_ld,
			ddr3_idelay_dqs_ld, ddr3_bitslip,
			ddr3_debug_read_dqs_p,
			ddr3_debug_read_dqs_n;
	wire    ddr3_idelayctrl_rdy,
		ddr3_dqs_tri_control, ddr3_dq_tri_control,
		ddr3_toggle_dqs, ddr3_write_leveling_calib,
		ddr3_reset;
	wire    ddr3_debug_clk_p, ddr3_debug_clk_n;
	// }}}
	wire	[31:0]	pxclk_debug;
	wire		w_pxclk_cyc, w_pxclk_stb, w_pxclk_we,
			w_pxclk_stall, w_pxclk_ack;
	wire	[6:0]	w_pxclk_addr;
	wire	[31:0]	w_pxclk_data, w_pxclk_idata;
	wire	[3:0]	w_pxclk_sel;
	// Mega Net definitions
	// {{{
	wire	[7:0]		w_net_rxd, w_net_txd;
	wire			w_net_rxdv, w_net_rxerr,
				w_net_txctl;
	wire	[1:0]		w_net_tx_clk;
	reg	net_last_tck;
	// }}}
	wire	[8-1:0]	w_led;
	// GPIO declarations.  The two wire busses are just virtual lists
	// of input (or output) ports.
	wire	[8-1:0]	i_gpio;
	// Verilator lint_off UNUSED
	// Two of our outputs, o_trace and o_halt, will be unused at the top
	// level.
	wire	[10-1:0]	o_gpio;
	// Verilator lint_on  UNUSED
	// SDIO SD Card definitions
	// {{{
	wire		w_sdio_hwreset_n, w_sdio_1p8v;
	wire		w_sdio_cfg_ddr;
	wire		w_sdio_cfg_ds, w_sdio_cfg_dscmd;
	wire	[4:0]	w_sdio_cfg_sample_shift;
	wire		w_sdio_cmd_tristate;
	wire		w_sdio_data_tristate;
		//
	wire	[7:0]	w_sdio_sdclk;
	wire		w_sdio_cmd_en;
	wire	[1:0]	w_sdio_cmd_data;
	wire		w_sdio_data_en;
	wire		w_sdio_rx_en;
	wire	[31:0]	w_sdio_tx_data;
		//
	wire	[1:0]	w_sdio_cmd_strb;
	wire	[1:0]	w_sdio_cmd_idata;
	wire		w_sdio_cmd_collision;
	wire		w_sdio_crcack,
			w_sdio_crcnak;
	wire		w_sdio_card_busy;
	wire	[1:0]	w_sdio_rx_strb;
	wire	[15:0]	w_sdio_rx_data;
		//
	wire		w_sdio_ac_valid;
	wire	[1:0]	w_sdio_ac_data;
	wire		w_sdio_ad_valid;
	wire	[31:0]	w_sdio_ad_data;

	wire		w_sdio_ck;
	wire		w_sdio_ds;
	wire	[31:0]	w_sdio_debug;
	// }}}

	// Clock/reset definitions
	// {{{
	wire	s_clk_200mhz,  s_clk_200mhz_unbuffered,
		sysclk_locked, sysclk_feedback, sysclk_feedback_buffered,
		s_clk_250mhz,  s_clk_250_unbuffered,
		s_clk_125mhz,  s_clk_125_unbuffered,
		s_clk_125d,    s_clk_125d_unbuffered,
		s_clksync,     s_clksync_unbuffered,
		s_clk_400mhz,  s_clk_400mhz_unbuffered,	// Pixclk * 10
		s_clk_80mhz_unbuffered,	// 80MHz
		netclk_locked, netclk_feedback, netclk_feedback_buffered;
	wire	i_clk_buffered;
	wire	clocks_locked;
	wire	dly_ctrl_ready;
	reg	[3:0]	sysclk_stable, syncd_stable;
	reg	[4:0]	pll_reset_sreg;
	reg		pll_reset;
	// }}}
	reg	[4:0]	vadj33_vadj_counter;
	// Ethernet control (MDIO)
	wire		w_mdio, w_mdwe;
	// Verilator lint_off UNUSED
	wire		ign_cpu_stall, ign_cpu_ack;
	wire	[31:0]	ign_cpu_idata;
	// Verilator lint_on  UNUSED


	//
	// Time to call the main module within main.v.  Remember, the purpose
	// of the main.v module is to contain all of our portable logic.
	// Things that are Xilinx (or even Altera) specific, or for that
	// matter anything that requires something other than on-off logic,
	// such as the high impedence states required by many wires, is
	// kept in this (toplevel.v) module.  Everything else goes in
	// main.v.
	//
	// We automatically place s_clk, and s_reset here.  You may need
	// to define those above.  (You did, didn't you?)  Other
	// component descriptions come from the keys @TOP.MAIN (if it
	// exists), or @MAIN.PORTLIST if it does not.
	//

	main	thedesign(s_clk, s_reset,
		// Quad SPI flash
		w_flash_cs_n, w_flash_sck, flash_dat, io_flash_dat, flash_bmod,
		// I2CCPU
		i_i2c_sda, i_i2c_scl,
		o_i2c_sda, o_i2c_scl,
		// UART/host to wishbone interface
		i_wbu_uart_rx, o_wbu_uart_tx,
		// I2CCPU
		i_edid_sda, i_edid_scl,
		o_edid_sda, o_edid_scl,
		// The GPS-UART
		i_gpsu_rx, o_gpsu_tx,
		// HDMI control ports
		hdmirx_clk, hdmi_ck,	// Depending on s_siclk
		hdmirx_red, hdmirx_grn, hdmirx_blu,
		hdmitx_red, hdmitx_grn, hdmitx_blu,
		set_hdmi_delay, actual_hdmi_delay,
		pix_reset_n, pxrx_locked, hdmirx_reset_n,
		w_pxclk_cksel,
	// EDID RX definitions
	io_hdmirx_scl, io_hdmirx_sda,
	w_edidslv_scl,  w_edidslv_sda,
	// DDR3 Controller-PHY Interface
	ddr3_iserdes_data, ddr3_iserdes_dqs,
	ddr3_iserdes_bitslip_reference,
	ddr3_idelayctrl_rdy,
	ddr3_cmd,
	ddr3_dqs_tri_control, ddr3_dq_tri_control,
	ddr3_toggle_dqs, ddr3_data, ddr3_dm,
	ddr3_odelay_data_cntvaluein, ddr3_odelay_dqs_cntvaluein,
	ddr3_idelay_data_cntvaluein, ddr3_idelay_dqs_cntvaluein,
	ddr3_odelay_data_ld, ddr3_odelay_dqs_ld,
	ddr3_idelay_data_ld, ddr3_idelay_dqs_ld,
	ddr3_bitslip,
	ddr3_write_leveling_calib,
	ddr3_reset,
		o_i2s_lrclk, o_i2s_bclk, o_i2s_mclk, o_i2s_dac, i_i2s_adc,
		w_pxclk_cyc, w_pxclk_stb, w_pxclk_we,
		w_pxclk_addr, w_pxclk_data, w_pxclk_sel,
		w_pxclk_stall, w_pxclk_ack, w_pxclk_idata,
		// Ethernet (RGMII) connections
		o_net_reset_n,
		i_net_rx_clk, w_net_rxdv,  w_net_rxdv ^ w_net_rxerr, w_net_rxd,
		w_net_tx_clk, w_net_txctl, w_net_txd,
		i_sw, i_btnc, i_btnd, i_btnl, i_btnr, i_btnu, w_led,
		// GPIO wires
		i_gpio, o_gpio,
		// SDIO SD Card
		!i_sd_cd_n,
		//
		w_sdio_cfg_ddr,
		w_sdio_cfg_ds,
		w_sdio_cfg_dscmd,
		w_sdio_cfg_sample_shift,
		w_sdio_cmd_tristate,
		w_sdio_data_tristate,
		//
		w_sdio_sdclk,
		w_sdio_cmd_en,
		w_sdio_cmd_data,
		w_sdio_data_en,
		w_sdio_rx_en,
		w_sdio_tx_data,
		//
		w_sdio_cmd_strb,
		w_sdio_cmd_idata,
		w_sdio_cmd_collision,
		w_sdio_crcack,
		w_sdio_crcnak,
		w_sdio_card_busy,
		w_sdio_rx_strb,
		w_sdio_rx_data,
		//
		w_sdio_ac_valid,
		w_sdio_ac_data,
		w_sdio_ad_valid,
		w_sdio_ad_data,
		w_sdio_hwreset_n, w_sdio_1p8v,
		w_sdio_debug,
		// PLL generated clocks
		s_clk_125mhz,
		// The GPS 1PPS signal port
		i_gps_pps,
		o_eth_mdclk, w_mdio, w_mdwe, io_eth_mdio,
		// OLED control interface (roughly SPI)
		o_oled_sck, o_oled_mosi, o_oled_dcn,
		// The PMic3 microphone wires
		o_mic_csn, o_mic_sck, i_mic_din,
		// Simulation bus control for the CPU
		1'b0, 1'b0, 1'b0, 7'h0, 32'h0,
		ign_cpu_stall, ign_cpu_ack, ign_cpu_idata,
		// Reset wire for the ZipCPU
		s_reset);


	//
	// Our final section to the toplevel is used to provide all of
	// that special logic that couldnt fit in main.  This logic is
	// given by the @TOP.INSERT tag in our data files.
	//


	////////////////////////////////////////////////////////////////////////
	//
	// QSPI Flash IO pin handling
	// {{{
	//
	// Wires for setting up the QSPI flash wishbone peripheral
	//
	//
	// QSPI)BMOD, Quad SPI bus mode, Bus modes are:
	//	0?	Normal serial mode, one bit in one bit out
	//	10	Quad SPI mode, going out
	//	11	Quad SPI mode coming from the device (read mode)
	xqflex #(
		.OPT_CLOCK(1'b0), .OPT_PHASE(1'b1)
	) u_xqflex (
		.i_clk(s_clk), .i_cs_n(w_flash_cs_n), .i_sck(w_flash_sck),
		.i_dat(o_flash_dat), .o_dat(i_flash_dat), .i_bmod(flash_bmod),
		//
		.o_cs_n(o_flash_cs_n), .o_sck(o_flash_sck), .io_dat(io_flash_dat)
	);

	// The following primitive is necessary in many designs order to gain
	// access to the o_flash_sck pin.  It's not necessary on the Arty,
	// simply because they provide two pins that can drive the QSPI
	// clock pin.
	wire	[3:0]	su_nc;	// Startup primitive, no connect
	STARTUPE2 #(
		// {{{
		// Leave PROG_USR false to avoid activating the program
		// event security feature.  Notes state that such a feature
		// requires encrypted bitstreams.
		.PROG_USR("FALSE"),
		// Sets the configuration clock frequency (in ns) for
		// simulation.
		.SIM_CCLK_FREQ(0.0)
		// }}}
	) STARTUPE2_inst (
		// {{{
		// CFGCLK, 1'b output: Configuration main clock output -- no
		//	connect
		.CFGCLK(su_nc[0]),
		// CFGMCLK, 1'b output: Configuration internal oscillator clock
		//	output
		.CFGMCLK(su_nc[1]),
		// EOS, 1'b output: Active high output indicating the End Of
		//	Startup.
		.EOS(su_nc[2]),
		// PREQ, 1'b output: PROGRAM request to fabric output
		//	Only enabled if PROG_USR is set.  This lets the fabric
		//	know that a request has been made (either JTAG or pin
		//	pulled low) to program the device
		.PREQ(su_nc[3]),
		// CLK, 1'b input: User start-up clock input
		.CLK(1'b0),
		// GSR, 1'b input: Global Set/Reset input
		.GSR(1'b0),
		// GTS, 1'b input: Global 3-state input
		.GTS(1'b0),
		// KEYCLEARB, 1'b input: Clear AES Decrypter Key input from
		//	BBRAM
		.KEYCLEARB(1'b0),
		// PACK, 1-bit input: PROGRAM acknowledge input
		//	This pin is only enabled if PROG_USR is set.  This
		//	allows the FPGA to acknowledge a request for reprogram
		//	to allow the FPGA to get itself into a reprogrammable
		//	state first.
		.PACK(1'b0),
		// USRCLKO, 1-bit input: User CCLK input -- This is why I am
		//	using this module at all.
		.USRCCLKO(o_flash_sck),
		// USRCCLKTS, 1'b input: User CCLK 3-state enable input
		//	An active high here places the clock into a high
		//	impedence state.  Since we wish to use the clock as an
		//	active output always, we drive this pin low.
		.USRCCLKTS(1'b0),
		// USRDONEO, 1'b input: User DONE pin output control
		//	Set this to "high" to make sure that the DONE LED pin
		//	is high.
		.USRDONEO(1'b1),
		// USRDONETS, 1'b input: User DONE 3-state enable output
		//	This enables the FPGA DONE pin to be active.  Setting
		//	this active high sets the DONE pin to high impedence,
		//	setting it low allows the output of this pin to be as
		//	stated above.
		.USRDONETS(1'b1)
		// }}}
	);
	// }}}

	////////////////////////////////////////////////////////////////////////
	//
	// I2C IO buffers
	// {{{

	// We need these in order to (properly) ensure the high impedance
	// states (pull ups) of the I2C I/O lines.  Our goals are:
	//
	//	o_i2c_X	io_i2c_X		Derived:T
	//	1'b0		1'b0			1'b0
	//	1'b1		1'bz			1'b1
	//
	IOBUF i2csclp(
		// {{{
		.I(1'b0),
		.T(o_i2c_scl),
		.O(i_i2c_scl),
		.IO(io_scl)
		// }}}
	);

	IOBUF i2csdap(
		// {{{
		.I(1'b0),
		.T(o_i2c_sda),
		.O(i_i2c_sda),
		.IO(io_sda)
		// }}}
	);
	// }}}

	////////////////////////////////////////////////////////////////////////
	//
	// I2C IO buffers
	// {{{

	// We need these in order to (properly) ensure the high impedance
	// states (pull ups) of the I2C I/O lines.  Our goals are:
	//
	//	o_edid_X	io_edid_X		Derived:T
	//	1'b0		1'b0			1'b0
	//	1'b1		1'bz			1'b1
	//
	IOBUF edidsclp(
		// {{{
		.I(1'b0),
		.T(o_edid_scl),
		.O(i_edid_scl),
		.IO(io_hdmitx_scl)
		// }}}
	);

	IOBUF edidsdap(
		// {{{
		.I(1'b0),
		.T(o_edid_sda),
		.O(i_edid_sda),
		.IO(io_hdmitx_sda)
		// }}}
	);
	// }}}

	////////////////////////////////////////////////////////////////////////
	//
	// HDMI
	// {{{

	// Ingest the HDMI data lines
	// {{{
	xhdmiin
	u_hdmirx_red(
		.i_clk(hdmi_ck), .i_hsclk(hdmi_serdes_clk),
		.i_reset_n(hdmirx_reset_n),
		.i_delay(set_hdmi_delay[14:10]),
		.o_delay(actual_hdmi_delay[14:10]),
		.i_hs_wire({ i_hdmirx_p[2], i_hdmirx_n[2] }),
		.o_word(hdmirx_red)
	);

	xhdmiin
	u_hdmirx_grn(
		.i_clk(hdmi_ck), .i_hsclk(hdmi_serdes_clk),
		.i_reset_n(hdmirx_reset_n),
		.i_delay(set_hdmi_delay[9:5]),
		.o_delay(actual_hdmi_delay[9:5]),
		.i_hs_wire({ i_hdmirx_p[1], i_hdmirx_n[1] }),
		.o_word(hdmirx_grn)
	);

	xhdmiin
	u_hdmirx_blu(
		.i_clk(hdmi_ck), .i_hsclk(hdmi_serdes_clk),
		.i_reset_n(hdmirx_reset_n),
		.i_delay(set_hdmi_delay[4:0]),
		.o_delay(actual_hdmi_delay[4:0]),
		.i_hs_wire({ i_hdmirx_p[0], i_hdmirx_n[0] }),
		.o_word(hdmirx_blu)
	);
	// }}}

	// Output the HDMI TX data lines
	// {{{
	xhdmiout
	u_hdmitx_clk(
		.i_clk(hdmi_ck), .i_hsclk(hdmi_serdes_clk),
		.i_reset_n(pix_reset_n), .i_en(1'b1),
		.i_word(10'b11111_00000),
		.o_port({ o_hdmitx_clk_p, o_hdmitx_clk_n })
	);

	xhdmiout
	u_hdmitx_red(
		.i_clk(hdmi_ck), .i_hsclk(hdmi_serdes_clk),
		.i_reset_n(pix_reset_n), .i_en(1'b1),
		.i_word(hdmitx_red),
		.o_port({ o_hdmitx_p[2], o_hdmitx_n[2] })
	);

	xhdmiout
	u_hdmitx_grn(
		.i_clk(hdmi_ck), .i_hsclk(hdmi_serdes_clk),
		.i_reset_n(pix_reset_n), .i_en(1'b1),
		.i_word(hdmitx_grn),
		.o_port({ o_hdmitx_p[1], o_hdmitx_n[1] })
	);

	xhdmiout
	u_hdmitx_blu(
		.i_clk(hdmi_ck), .i_hsclk(hdmi_serdes_clk),
		.i_reset_n(pix_reset_n), .i_en(1'b1),
		.i_word(hdmitx_blu),
		.o_port({ o_hdmitx_p[0], o_hdmitx_n[0] })
	);
	// }}}

	// }}}

	assign	io_hdmirx_scl = w_edidslv_scl ? 1'bz : 1'b0;
	assign	io_hdmirx_sda = w_edidslv_sda ? 1'bz : 1'b0;

	assign	s_clk = s_clksync;
	assign	o_ddr3_vsel = 1'bz;

	always @(posedge s_clk or negedge clocks_locked)
	if (!clocks_locked)
		clk_reset_pipe <= 3'h7;
	else
		clk_reset_pipe <= { clk_reset_pipe[1:0], 1'b0 };

	assign	s_reset = clk_reset_pipe[2];

	// DDR3 PHY Instantiation
	ddr3_phy #(
		// {{{
		.ROW_BITS(SDRAMROW_BITS),	//width of row address
		.BA_BITS(SDRAMBA_BITS),	//width of bank address
		.DQ_BITS(SDRAMDQ_BITS),	//width of DQ
		.LANES(SDRAMBYTE_LANES), //8 lanes of DQ
		.CONTROLLER_CLK_PERIOD(SDRAMCONTROLLER_CLK_PERIOD), //ns, period of clock input to this DDR3 controller module
		.DDR3_CLK_PERIOD(DDR3_CLK_PERIOD), //ns, period of clock input to DDR3 RAM device
		.ODELAY_SUPPORTED(1)
		// }}}
	) ddr3_phy_inst (
		// {{{
		// clock and reset
		.i_controller_clk(s_clksync),
		.i_ddr3_clk(s_clk_400mhz),
		.i_ref_clk(s_clk_200mhz),
		.i_ddr3_clk_90(0), //required only when ODELAY_SUPPORTED is zero
		.i_rst_n(!s_reset),
		// Controller Interface
		.i_controller_reset(ddr3_reset),
		.i_controller_cmd(ddr3_cmd),
		.i_controller_dqs_tri_control(ddr3_dqs_tri_control),
		.i_controller_dq_tri_control(ddr3_dq_tri_control),
		.i_controller_toggle_dqs(ddr3_toggle_dqs),
		.i_controller_data(ddr3_data),
		.i_controller_dm(ddr3_dm),
		.i_controller_odelay_data_cntvaluein(ddr3_odelay_data_cntvaluein),
		.i_controller_odelay_dqs_cntvaluein(ddr3_odelay_dqs_cntvaluein),
		.i_controller_idelay_data_cntvaluein(ddr3_idelay_data_cntvaluein),
		.i_controller_idelay_dqs_cntvaluein(ddr3_idelay_dqs_cntvaluein),
		.i_controller_odelay_data_ld(ddr3_odelay_data_ld),
		.i_controller_odelay_dqs_ld(ddr3_odelay_dqs_ld),
		.i_controller_idelay_data_ld(ddr3_idelay_data_ld),
		.i_controller_idelay_dqs_ld(ddr3_idelay_dqs_ld),
		.i_controller_bitslip(ddr3_bitslip),
		.i_controller_write_leveling_calib(ddr3_write_leveling_calib),
		.o_controller_iserdes_data(ddr3_iserdes_data),
		.o_controller_iserdes_dqs(ddr3_iserdes_dqs),
		.o_controller_iserdes_bitslip_reference(ddr3_iserdes_bitslip_reference),
		.o_controller_idelayctrl_rdy(ddr3_idelayctrl_rdy),
		// DDR3 I/O Interface
		.o_ddr3_clk_p(o_ddr3_clk_p),
		.o_ddr3_clk_n(o_ddr3_clk_n),
		.o_ddr3_reset_n(o_ddr3_reset_n),
		.o_ddr3_cke(o_ddr3_cke[0]), // CKE
		.o_ddr3_cs_n(o_ddr3_cs_n[0]), // chip select signal (controls rank 1 only)
		.o_ddr3_ras_n(o_ddr3_ras_n), // RAS#
		.o_ddr3_cas_n(o_ddr3_cas_n), // CAS#
		.o_ddr3_we_n(o_ddr3_we_n), // WE#
		.o_ddr3_addr(o_ddr3_a[SDRAMROW_BITS-1:0]),
		.o_ddr3_ba_addr(o_ddr3_ba),
		.io_ddr3_dq(io_ddr3_dq),
		.io_ddr3_dqs(io_ddr3_dqs_p),
		.io_ddr3_dqs_n(io_ddr3_dqs_n),
		.o_ddr3_dm(o_ddr3_dm),
		.o_ddr3_odt(o_ddr3_odt[0]), // on-die termination
		// DEBUG PHY
		.o_ddr3_debug_read_dqs_p(ddr3_debug_read_dqs_p),
		.o_ddr3_debug_read_dqs_n(ddr3_debug_read_dqs_n)
		// }}}
	);

	generate for(ddr3gen_index = SDRAMROW_BITS;
			ddr3gen_index < 15;
			ddr3gen_index = ddr3gen_index + 1)
	begin : GEN_UNUSED_SDRAM_ASSIGN
		assign o_ddr3_a[ddr3gen_index] = 0;
	end endgenerate

	////////////////////////////////////////////////////////////////////////
	//
	// HDMI Clock generation
	// {{{

	xpxclk
	u_xpxclk (
		.i_sysclk(s_clk),		// System clock
		.i_cksel(w_pxclk_cksel),		// Clock select switch
		//
		.i_hdmirx_clk_p(i_hdmirx_clk_p),	// HDMI RX input clock
		.i_hdmirx_clk_n(i_hdmirx_clk_n),
		.i_lcl_pixclk(s_clk_80mhz_unbuffered),	// Locally generated clk
		.i_siclk(s_clk_80mhz_unbuffered),
		//
		.o_hdmick_locked(pxrx_locked),
		.o_hdmirx_clk(hdmirx_clk),	// Clk for measurement only
		.o_pixclk(hdmi_ck),		// Pixel clock
		.o_hdmick(hdmi_serdes_clk),	// HS pixel clock
		//
		.i_wb_clk(s_clk),
		//
		.i_wb_cyc(w_pxclk_cyc), .i_wb_stb(w_pxclk_stb),
			.i_wb_we(w_pxclk_we),
			.i_wb_addr(w_pxclk_addr[7-1:0]),
			.i_wb_data(w_pxclk_data), // 32 bits wide
			.i_wb_sel(w_pxclk_sel),  // 32/8 bits wide
		.o_wb_stall(w_pxclk_stall),.o_wb_ack(w_pxclk_ack),
			.o_wb_data(w_pxclk_idata),
		//
		.o_debug(pxclk_debug)
	);
	// }}}

	// RGMII control
	// {{{
	xiddr	netrx0(i_net_rx_clk, i_net_rxd[0], { w_net_rxd[4], w_net_rxd[0] });
	xiddr	netrx1(i_net_rx_clk, i_net_rxd[1], { w_net_rxd[5], w_net_rxd[1] });
	xiddr	netrx2(i_net_rx_clk, i_net_rxd[2], { w_net_rxd[6], w_net_rxd[2] });
	xiddr	netrx3(i_net_rx_clk, i_net_rxd[3], { w_net_rxd[7], w_net_rxd[3] });
	xiddr	netrxc(i_net_rx_clk, i_net_rx_ctl, { w_net_rxdv,   w_net_rxerr });

	//
	// All of the below is about delaying the clock 90 degrees from the data
	//
	xoserdes	nettx0(s_clk_125mhz, pll_reset, s_clk_250mhz, { {(2){w_net_txd[0]}}, {(2){w_net_txd[4]}} }, o_net_txd[0]);
	xoserdes	nettx1(s_clk_125mhz, pll_reset, s_clk_250mhz, { {(2){w_net_txd[1]}}, {(2){w_net_txd[5]}} }, o_net_txd[1]);
	xoserdes	nettx2(s_clk_125mhz, pll_reset, s_clk_250mhz, { {(2){w_net_txd[2]}}, {(2){w_net_txd[6]}} }, o_net_txd[2]);
	xoserdes	nettx3(s_clk_125mhz, pll_reset, s_clk_250mhz, { {(2){w_net_txd[3]}}, {(2){w_net_txd[7]}} }, o_net_txd[3]);

	always @(posedge s_clk_125mhz)
		net_last_tck <= w_net_tx_clk[0];

	xoserdes	nettxc(s_clk_125mhz, pll_reset, s_clk_250mhz, {(4){w_net_txctl}}, o_net_tx_ctl );

	xoserdes	nettxck(s_clk_125mhz, pll_reset, s_clk_250mhz, {net_last_tck, {(2){w_net_tx_clk[1]}},w_net_tx_clk[0]},o_net_tx_clk);
	// xoserdes	nettxck(s_clk_125mhz, pll_reset, s_clk_250mhz, { {(2){w_net_tx_clk[1]}},{(2){w_net_tx_clk[0]}} }, o_net_tx_clk);
	// }}}

	assign	o_led = { w_led[8-1:3],
			(w_led[2] || !syncd_stable[3]),
			(w_led[1] || !clocks_locked),
			(w_led[0] || s_reset) };

	////////////////////////////////////////////////////////////////////////
	//
	// GPIO adjustments
	// {{{
	assign	i_gpio = { 8'h0,
			pxrx_locked,
			sysclk_locked,
`ifdef	GPSTRK_ACCESS
			i_gps_3df,
`else
			1'b0,
`endif
			!i_hdmitx_hpd_n,	// Hotplug detect
			!i_sd_cd_n,
			1'b0,
			i_hdmitx_cec, i_hdmirx_cec };
	assign	o_hdmirx_txen = o_gpio[2];
	assign	o_hdmirx_hpa  = o_gpio[3];	// Hotplug assert
	assign	o_sd_reset  = !w_sdio_hwreset_n;
	assign	o_oled_reset_n  = !o_gpio[5];
	assign	o_oled_panel_en =  o_gpio[6];
	assign	o_oled_logic_en =  o_gpio[7];
	// These two pins are only used in simulation, and only within the
	// MAIN RTL component.
	// assign o_trace     = o_gpio[8];
	// assign o_halt      = o_gpio[9];

	// }}}

	sdfrontend #(
		.OPT_SERDES(1'b1),
		.OPT_DDR(1'b1),
		.NUMIO(4),
		.BUSY_CLOCKS(16),
		.OPT_CRCTOKEN(1)
	) u_sdio_frontend (
		// {{{
		.i_clk(s_clk), .i_hsclk(s_clk_400mhz), .i_reset(s_reset),
		// Configuration
		.i_cfg_ddr(w_sdio_cfg_ddr),
		.i_cfg_ds(w_sdio_cfg_ds),
		.i_cfg_dscmd(w_sdio_cfg_dscmd),
		.i_sample_shift(w_sdio_cfg_sample_shift),
		.i_cmd_tristate(w_sdio_cmd_tristate),
		.i_data_tristate(w_sdio_data_tristate),
		// Run-time inputs
		.i_sdclk(w_sdio_sdclk),
		.i_cmd_en(w_sdio_cmd_en),
		.i_cmd_data(w_sdio_cmd_data),
		.i_data_en(w_sdio_data_en),
		.i_rx_en(w_sdio_rx_en),
		.i_tx_data(w_sdio_tx_data),
		// Return values
		.o_cmd_strb(w_sdio_cmd_strb),
		.o_cmd_data(w_sdio_cmd_idata),
		.o_cmd_collision(w_sdio_cmd_collision),
		.o_crcack(w_sdio_crcack),
		.o_crcnak(w_sdio_crcnak),
		.o_data_busy(w_sdio_card_busy),
		.o_rx_strb( w_sdio_rx_strb),
		.o_rx_data( w_sdio_rx_data),
		//
		.MAC_VALID(w_sdio_ac_valid),
		.MAC_DATA( w_sdio_ac_data),
		.MAD_VALID(w_sdio_ad_valid),
		.MAD_DATA( w_sdio_ad_data),
		// IO ports
		.o_ck(w_sdio_ck),
		.i_ds(w_sdio_ds),
		.io_cmd(io_sd_cmd),
		.io_dat(io_sd_dat),
		.o_debug(w_sdio_debug)
		// }}}
	);


	assign	o_sd_clk = w_sdio_ck;

	assign	w_sdio_ds    = 1'b0;


	// Buffer the incoming clock
	BUFG masterclkclkbufi(.I(i_clk), .O(i_clk_buffered));

	// pll_reset
	initial	{ pll_reset, pll_reset_sreg } = -1;
	always @(posedge i_clk_buffered)
		{ pll_reset, pll_reset_sreg } <= { pll_reset_sreg, 1'b0 };

	////////////////////////////////////////////////////////////////////////
	//
	// PLL #1: 100MHz, 200MHz, 400MHz, and 80MHz
	// {{{
	////////////////////////////////////////////////////////////////////////
	//
	//

	// But ... the delay controller requires a 200 MHz reference clock,
	// the generic clock generator requires a 400MHz clock and a clock
	// synchronized to it
	PLLE2_BASE #(
		// {{{
		.CLKFBOUT_MULT(8),
		.CLKFBOUT_PHASE(0.0),
		.CLKIN1_PERIOD(10),
		.CLKOUT0_DIVIDE(4),	// 200 MHz
		.CLKOUT1_DIVIDE(2),	// 400 MHz
		.CLKOUT2_DIVIDE(8),	// 100 MHz
		.CLKOUT3_DIVIDE(10)	//  80 MHz
		// }}}
	) gen_sysclk(
		// {{{
		.CLKIN1(i_clk_buffered),
		.CLKOUT0(s_clk_200mhz_unbuffered),
		.CLKOUT1(s_clk_400mhz_unbuffered),
		.CLKOUT2(s_clksync_unbuffered),
		.CLKOUT3(s_clk_80mhz_unbuffered),
		// .CLKOUT4(),
		// .CLKOUT5(),
		.PWRDWN(1'b0), .RST(pll_reset),
		.CLKFBOUT(sysclk_feedback),
		.CLKFBIN(sysclk_feedback_buffered),
		.LOCKED(sysclk_locked)
		// }}}
	);

	BUFG	sysbuf(     .I(s_clk_200mhz_unbuffered),.O(s_clk_200mhz));
	BUFG	clksync_buf(.I(s_clksync_unbuffered),   .O(s_clksync));
	BUFG	clk4x_buf(  .I(s_clk_400mhz_unbuffered),.O(s_clk_400mhz));
	BUFG	sys_feedback(.I(sysclk_feedback),.O(sysclk_feedback_buffered));

	// }}}
	////////////////////////////////////////////////////////////////////////
	//
	// PLL #2: 125MHz, 250MHz
	// {{{
	////////////////////////////////////////////////////////////////////////
	//
	//

	// The ethernet MAC requires a 125MHz clock
	//   We can't trust the RX 125MHz clock for this, since there's a
	//   possibility the RX 125MHz clock might arrive at a different rate.
	//
	PLLE2_BASE #(
		// {{{
		.CLKFBOUT_MULT(10),
		.CLKFBOUT_PHASE(0.0),
		.CLKIN1_PERIOD(10),
		.CLKOUT0_DIVIDE(8),	// 125 MHz
		.CLKOUT0_PHASE(0),
		.CLKOUT1_DIVIDE(4),	// 250 MHz
		.CLKOUT1_PHASE(0)
		// }}}
	) gen_netclk(
		// {{{
		.CLKIN1(i_clk_buffered),
		.CLKOUT0(s_clk_125_unbuffered),
		.CLKOUT1(s_clk_250_unbuffered),
		// .CLKOUT2(),
		// .CLKOUT3(),
		// .CLKOUT4(),
		// .CLKOUT5(),
		.PWRDWN(1'b0), .RST(pll_reset),
		.CLKFBOUT(netclk_feedback),
		.CLKFBIN(netclk_feedback_buffered),
		.LOCKED(netclk_locked)
		// }}}
	);

	BUFG	netbuf(.I(s_clk_125_unbuffered), .O(s_clk_125mhz));
	BUFG	netbf5(.I(s_clk_250_unbuffered), .O(s_clk_250mhz));
	BUFG	netfb(.I(netclk_feedback), .O(netclk_feedback_buffered));

	assign	clocks_locked = (netclk_locked && sysclk_locked && dly_ctrl_ready);

	// }}}
	////////////////////////////////////////////////////////////////////////
	//
	// reg	[3:0]	sysclk_stable;
	// {{{
	initial	sysclk_stable = 0;
	always @(posedge i_clk_buffered or negedge clocks_locked)
	if (!clocks_locked)
		sysclk_stable <= 0;
	else
		sysclk_stable <= { sysclk_stable[2:0], 1'b1 };

	initial	syncd_stable = 0;
	always @(posedge i_clk_buffered)
	if (!sysclk_stable[3])
		syncd_stable <= 0;
	else
		syncd_stable <= { syncd_stable[2:0], 1'b1 };

	// }}}
	////////////////////////////////////////////////////////////////////////
	//
	// IDELAYCTRL
	IDELAYCTRL
	u_delay_control (
		.REFCLK(s_clk_200mhz),
		.RST(!sysclk_locked),
		.RDY(dly_ctrl_ready)
	);


	assign	o_vadj = 2'b11;
	initial	vadj33_vadj_counter = 0;
	always @(posedge i_clk_buffered)
	if (!vadj33_vadj_counter[4])
		vadj33_vadj_counter[4] <= vadj33_vadj_counter[4] + 1;
	assign	o_vadj_en = vadj33_vadj_counter[4];

	assign	io_eth_mdio = (w_mdwe)?w_mdio : 1'bz;



endmodule // end of toplevel.v module definition
