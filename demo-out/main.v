`timescale	1ps / 1ps
////////////////////////////////////////////////////////////////////////////////
//
// Filename:	../demo-out/main.v
// {{{
// Project:	AutoFPGA, a utility for composing FPGA designs from peripherals
//
// DO NOT EDIT THIS FILE!
// Computer Generated: This file is computer generated by AUTOFPGA. DO NOT EDIT.
// DO NOT EDIT THIS FILE!
//
// CmdLine:	./autofpga ./autofpga -d -o ../demo-out -I ../auto-data bkram.txt buserr.txt clkcounter.txt clock.txt enet.txt flash.txt global.txt gpio.txt gps.txt hdmi.txt icape.txt legalgen.txt mdio.txt pic.txt pwrcount.txt rtcdate.txt rtcgps.txt sdram.txt sdspi.txt spio.txt version.txt wbmouse.txt wboledbw.txt wbpmic.txt wbscopc.txt wbscope.txt wbubus.txt xpander.txt zipmaster.txt
//
// Creator:	Dan Gisselquist, Ph.D.
//		Gisselquist Technology, LLC
//
////////////////////////////////////////////////////////////////////////////////
// }}}
// Copyright (C) 2017-2021, Gisselquist Technology, LLC
// {{{
// This program is free software (firmware): you can redistribute it and/or
// modify it under the terms of the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License, or (at
// your option) any later version.
//
// This program is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// for more details.
//
// You should have received a copy of the GNU General Public License along
// with this program.  (It's in the $(ROOT)/doc directory.  Run make with no
// target there if the PDF file isn't present.)  If not, see
// <http://www.gnu.org/licenses/> for a copy.
// }}}
// License:	GPL, v3, as defined and found on www.gnu.org,
// {{{
//		http://www.gnu.org/licenses/gpl.html
//
////////////////////////////////////////////////////////////////////////////////
//
// }}}
`default_nettype	none
////////////////////////////////////////////////////////////////////////////////
//
// Macro defines
// {{{
//
//
// Here is a list of defines which may be used, post auto-design
// (not post-build), to turn particular peripherals (and bus masters)
// on and off.  In particular, to turn off support for a particular
// design component, just comment out its respective `define below.
//
// These lines are taken from the respective @ACCESS tags for each of our
// components.  If a component doesn't have an @ACCESS tag, it will not
// be listed here.
//
// First, the independent access fields for any bus masters
`define	WBUBUS_MASTER
// And then for the independent peripherals
`define	INCLUDE_ZIPCPU
`define	GPIO_ACCESS
`define	FLASH_ACCESS
`define	GPSUART_ACCESS
`define	BKRAM_ACCESS
`define	ETHERNET_ACCESS
`define	BUSPIC_ACCESS
`define	SDSPI_ACCESS
`define	HDMIIN_ACCESS
`define	GPSTRK_ACCESS
`define	NETCTRL_ACCESS
`define	CFG_ACCESS
`define	PWRCOUNT_ACCESS
`define	HDMI_OUT_EDID_ACCESS
`define	RTC_ACCESS
`define	SPIO_ACCESS
`define	MOUSE_ACCESS
`define	OLEDBW_ACCESS
`define	MICROPHONE_ACCESS
`define	SCOPC_SCOPC
`define	SCOPE_SCOPE
`define	HDMI_IN_EDID_ACCESS
//
//
// The list of those things that have @DEPENDS tags
//
//
//
// Dependencies
// Any core with both an @ACCESS and a @DEPENDS tag will show up here.
// The @DEPENDS tag will turn into a series of ifdef's, with the @ACCESS
// being defined only if all of the ifdef's are true//
// Deplist for @$(PREFIX)=sdram
// Deplist for @$(PREFIX)=rtcdate
`ifdef	RTC_ACCESS
`define	RTCDATE_ACCESS
`endif	// RTC_ACCESS
// Deplist for @$(PREFIX)=flashcfg
`ifdef	FLASH_ACCESS
`define	FLASHCFG_ACCESS
`endif	// FLASH_ACCESS
// Deplist for @$(PREFIX)=sdram
//
// The following macros have unmet dependencies.  They are listed
// here for reference, but their dependencies cannot be met.
// Unmet Dependency list for @$(PREFIX)=sdram
`ifdef	ALLCLOCKS_PRESENT // This value is unknown
`define	SDRAM_ACCESS
`endif

//
// End of dependency list
//
//
// }}}
////////////////////////////////////////////////////////////////////////////////
//
// Any include files
// {{{
// These are drawn from anything with a MAIN.INCLUDE definition.
// }}}
//
// Finally, we define our main module itself.  We start with the list of
// I/O ports, or wires, passed into (or out of) the main function.
//
// These fields are copied verbatim from the respective I/O port lists,
// from the fields given by @MAIN.PORTLIST
//
module	main(i_clk, i_reset,
	// {{{
		i_cpu_reset,
		// HDMI output ports
		i_hdmi_out_clk,
		// HDMI output pixels
		o_hdmi_out_r, o_hdmi_out_g, o_hdmi_out_b,
		// GPIO ports
		i_gpio, o_gpio,
		// The Universal QSPI Flash
		o_qspi_cs_n, o_qspi_sck, o_qspi_dat, i_qspi_dat, o_qspi_mod,
		// The GPS-UART
		i_gpsu_rx, o_gpsu_tx,
		// Ethernet control (packets) lines
		o_net_reset_n,
		// eth_int_b	// Interrupt, leave floating
		// eth_pme_b	// Power management event, leave floating
		i_net_rx_clk, i_net_rx_dv, i_net_rx_err, i_net_rxd,
		o_net_tx_clk, o_net_tx_ctl, o_net_txd,
		// The SD-Card wires
		o_sd_sck, o_sd_cmd, o_sd_data, i_sd_cmd, i_sd_data, i_sd_detect,
		// HDMI input ports
		i_hdmi_in_clk,
		i_hdmi_in_r, i_hdmi_in_g, i_hdmi_in_b,
		i_hdmi_in_hsclk,
		// HDMI input delay control
		i_hdmi_in_actual_delay_r, i_hdmi_in_actual_delay_g,
		i_hdmi_in_actual_delay_b, o_hdmi_in_delay,
		// The GPS 1PPS signal port
		i_gps_pps,
		// The ethernet MDIO wires
		o_mdclk, o_mdio, o_mdwe, i_mdio,
		// HDMI out (source) EDID I2C ports
		i_hdmi_out_scl, i_hdmi_out_sda, o_hdmi_out_scl, o_hdmi_out_sda,
		// SDRAM ports
		o_sdram_cyc, o_sdram_stb, o_sdram_we,
				o_sdram_addr, o_sdram_data, o_sdram_sel,
			i_sdram_stall, i_sdram_ack, i_sdram_data,
			i_sdram_err
			, i_sdram_dbg,
		// SPIO interface
		i_sw, i_btnc, i_btnd, i_btnl, i_btnr, i_btnu, o_led,
		// The PS/2 Mouse
		i_ps2, o_ps2,
		// OLED control interface (roughly SPI)
		o_oled_sck, o_oled_mosi, o_oled_dcn,
		o_oled_reset_n, o_oled_panel_en, o_oled_logic_en,
		// The PMic3 microphone wires
		o_mic_csn, o_mic_sck, i_mic_din,
		// UART/host to wishbone interface
		i_host_uart_rx, o_host_uart_tx,
		// HDMI input EDID I2C ports
		i_hdmi_in_scl, i_hdmi_in_sda, o_hdmi_in_scl, o_hdmi_in_sda
	// }}}
	);
////////////////////////////////////////////////////////////////////////////////
//
// Any parameter definitions
// {{{
// These are drawn from anything with a MAIN.PARAM definition.
// As they aren't connected to the toplevel at all, it would
// be best to use localparam over parameter, but here we don't
// check
	//
	//
	// Variables/definitions needed by the ZipCPU BUS master
	//
	//
	// A 32-bit address indicating where the ZipCPU should start running
	// from
`ifdef	BKROM_ACCESS
	localparam	RESET_ADDRESS = @$(/bkrom.BASE);
`else
`ifdef	FLASH_ACCESS
	localparam	RESET_ADDRESS = @$RESET_ADDRESS;
`else
	localparam	RESET_ADDRESS = 436207616;
`endif	// FLASH_ACCESS
`endif	// BKROM_ACCESS
	//
	// The number of valid bits on the bus
	localparam	ZIP_ADDRESS_WIDTH = 28; // Zip-CPU address width
	//
	// Number of ZipCPU interrupts
	localparam	ZIP_INTS = 16;
	//
	// ZIP_START_HALTED
	//
	// A boolean, indicating whether or not the ZipCPU be halted on startup?
`ifdef	BKROM_ACCESS
	localparam	ZIP_START_HALTED=1'b0;
`else
	localparam	ZIP_START_HALTED=1'b1;
`endif
	localparam [31:0] GPSCLOCK_DEFAULT_STEP = 32'haabcc771;
	localparam	ICAPE_LGDIV=3;
// }}}
////////////////////////////////////////////////////////////////////////////////
//
// Port declarations
// {{{
// The next step is to declare all of the various ports that were just
// listed above.  
//
// The following declarations are taken from the values of the various
// @MAIN.IODECL keys.
//
	input	wire		i_clk;
	// verilator lint_off UNUSED
	input	wire		i_reset;
	// verilator lint_on UNUSED
	input	wire		i_cpu_reset;
	// Verilator lint_off UNUSED
	// HDMI output clock
	input	wire	i_hdmi_out_clk;
	// Verilator lint_on  UNUSED
	// HDMI output pixels
	output	wire	[9:0]	o_hdmi_out_r, o_hdmi_out_g, o_hdmi_out_b;
	localparam	NGPI = 16, NGPO=16;
	// GPIO ports
	input		[(NGPI-1):0]	i_gpio;
	output	wire	[(NGPO-1):0]	o_gpio;
	// The Universal QSPI flash
	output	wire		o_qspi_cs_n, o_qspi_sck;
	output	wire	[3:0]	o_qspi_dat;
	input	wire	[3:0]	i_qspi_dat;
	output	wire	[1:0]	o_qspi_mod;
	input	wire		i_gpsu_rx;
	output	wire		o_gpsu_tx;
	// Ethernet (RGMII) control
	output	wire		o_net_reset_n;
	input	wire		i_net_rx_clk, i_net_rx_dv, i_net_rx_err;
	input	wire	[7:0]	i_net_rxd;
	output	wire	[1:0]	o_net_tx_clk;
	output	wire		o_net_tx_ctl;
	output	wire	[7:0]	o_net_txd;
	// SD-Card declarations
	output	wire		o_sd_sck, o_sd_cmd;
	output	wire	[3:0]	o_sd_data;
	// verilator lint_off UNUSED
	input	wire		i_sd_cmd;
	input	wire	[3:0]	i_sd_data;
	// verilator lint_on  UNUSED
	input	wire		i_sd_detect;
	// HDMI input ports
	input	wire		i_hdmi_in_clk;
	input	wire	[9:0]	i_hdmi_in_r, i_hdmi_in_g, i_hdmi_in_b;
	// verilator lint_off UNUSED
	input	wire		i_hdmi_in_hsclk;
	// verilator lint_on  UNUSED
	// Sub-pixel delay control
	input	wire	[4:0]	i_hdmi_in_actual_delay_r;
	input	wire	[4:0]	i_hdmi_in_actual_delay_g;
	input	wire	[4:0]	i_hdmi_in_actual_delay_b;
	output	wire	[4:0]	o_hdmi_in_delay;
	//The GPS Clock
	input	wire		i_gps_pps;
	// Ethernet control (MDIO)
	output	wire		o_mdclk, o_mdio, o_mdwe;
	input	wire		i_mdio;
	// HDMI input EDID I2C ports
	input	wire		i_hdmi_out_scl, i_hdmi_out_sda;
	output	wire		o_hdmi_out_scl, o_hdmi_out_sda;
	// SDRAM I/O declarations
	output	wire			o_sdram_cyc,
					o_sdram_stb, o_sdram_we;
	output	wire	[25-1:0]	o_sdram_addr;
	output	wire	[(128-1):0]	o_sdram_data;
	output	wire	[(128/8)-1:0]	o_sdram_sel;
	//
	input	wire			i_sdram_ack;
	input	wire			i_sdram_stall;
	input	wire	[(128-1):0]	i_sdram_data;
	// Verilator lint_off UNUSED
	input	wire			i_sdram_err;
	input	wire	[31:0]		i_sdram_dbg;
	// Verilator lint_on  UNUSED
	// SPIO interface
	input	wire	[8-1:0]	i_sw;
	input	wire		i_btnc, i_btnd, i_btnl, i_btnr, i_btnu;
	output	wire	[8-1:0]	o_led;
	// The PS/2 Mouse
	input		[1:0]	i_ps2;
	output	wire	[1:0]	o_ps2;
	// OLEDBW interface
	output	wire		o_oled_sck, o_oled_mosi,
				o_oled_dcn, o_oled_reset_n, o_oled_panel_en,
				o_oled_logic_en;
	output	wire		o_mic_csn, o_mic_sck;
	input	wire		i_mic_din;
	input	wire		i_host_uart_rx;
	output	wire		o_host_uart_tx;
	// HDMI input EDID I2C ports
	input	wire		i_hdmi_in_scl, i_hdmi_in_sda;
	output	wire		o_hdmi_in_scl, o_hdmi_in_sda;
// }}}
	// Make Verilator happy
	// {{{
	// Defining bus wires for lots of components often ends up with unused
	// wires lying around.  We'll turn off Ver1lator's lint warning
	// here that checks for unused wires.
	// }}}
	// verilator lint_off UNUSED
	////////////////////////////////////////////////////////////////////////
	//
	// Declaring interrupt lines
	// {{{
	// These declarations come from the various components values
	// given under the @INT.<interrupt name>.WIRE key.
	//
	wire	zip_cpu_int;	// zip.INT.ZIP.WIRE
	wire	scop_edid_int;	// scop_edid.INT.SCOPE.WIRE
	wire	gpio_int;	// gpio.INT.GPIO.WIRE
	wire	gpsurxf_int;	// gpsu.INT.GPSRXF.WIRE
	wire	gpsutxf_int;	// gpsu.INT.GPSTXF.WIRE
	wire	gpsutx_int;	// gpsu.INT.GPSTX.WIRE
	wire	gpsurx_int;	// gpsu.INT.GPSRX.WIRE
	wire	nettx_int;	// netp.INT.NETTX.WIRE
	wire	netrx_int;	// netp.INT.NETRX.WIRE
	wire	w_bus_int;	// buspic.INT.BUS.WIRE
	wire	sdcard_int;	// sdcard.INT.SDCARD.WIRE
	wire	hdmiin_int;	// hdmiin.INT.VSYNC.WIRE
	wire	ck_pps;	// gck.INT.PPS.WIRE
	wire	scop_hdmiin_int;	// scope_hdmiin.INT.HINSCOPE.WIRE
	wire	edid_out_int;	// edout.INT.EDID.WIRE
	wire	rtc_int;	// rtc.INT.RTC.WIRE
	wire	spio_int;	// spio.INT.SPIO.WIRE
	wire	mous_interrupt;	// mous.INT.MOUSE.WIRE
	wire	oled_int;	// oled.INT.OLED.WIRE
	wire	pmic_int;	// pmic.INT.MIC.WIRE
	// }}}
	////////////////////////////////////////////////////////////////////////
	//
	// Component declarations
	// {{{
	// These declarations come from the @MAIN.DEFNS keys found in the
	// various components comprising the design.
	//
	// ZipSystem/ZipCPU connection definitions
	// All we define here is a set of scope wires
	wire	[31:0]	zip_debug;
	wire		zip_trigger;
	wire	[ZIP_INTS-1:0] zip_int_vector;
	wire		edid_scope_trigger;
	wire	[30:0]	edid_scope_data;
	wire	sd_reset;
`ifndef	GPSTRK_ACCESS
	reg	[31:0]	r_subseconds_data;
`endif
	// Definitions for the flash debug port
	wire		flash_dbg_trigger;
	wire	[31:0]	flash_debug;
	reg	r_clkhdmiout_ack;
	wire	w_gpsu_cts_n, w_gpsu_rts_n;
	assign	w_gpsu_cts_n=1'b1;
	reg	[28-1:0]	r_buserr_addr;
	//
	wire		netp_debug_clk;
	wire	[31:0]	netp_debug;
	reg	r_sysclk_ack;
`include "builddate.v"
	reg	r_clkhdmiin_ack;
	wire	tb_pps;
	wire[31:0]	sdspi_debug;
	reg [31:0]	r_hdmi_scope_frame_offset_data;
	reg	r_hdmi_scope_frame_offset_ack;
	initial	r_hdmi_scope_frame_offset_data=0;
	always @(posedge i_clk)
		if ((wb_stb)&&(hdmi_scope_frame_offset_sel)&&(wb_we))
			r_hdmi_scope_frame_offset_data <= wb_data;

	assign	hdmi_scope_frame_offset_data = r_hdmi_scope_frame_offset_data;
	assign	hdmi_scope_frame_offset_stall= 1'b0;
	always @(posedge i_clk)
		r_hdmi_scope_frame_offset_ack <= (wb_stb)&&(hdmi_scope_frame_offset_sel);
	wire	[31:0]	hin_dbg_scope;
	wire	[29:0]	hin_pixels;
	wire	[9:0]	hdmi_in_r;
	wire	[9:0]	hdmi_in_g;
	wire	[9:0]	hdmi_in_b;
	wire	gps_pps, gps_led, gps_locked, gps_tracking;
	wire	[63:0]	gps_now, gps_err, gps_step;
	wire	[1:0]	gps_dbg_tick;
// BUILDTIME doesnt need to include builddate.v a second time
// `include "builddate.v"
	reg	[31:0]	r_pwrcount_data;
	wire	[31:0]	hdmi_in_data;
	wire	[31:0]	edido_dbg;
	// Definitions in support of the GPS driven RTC
	// This clock step is designed to match 100000000 Hz
	localparam	[31:0]	RTC_CLKSTEP = 32'h002af31d;
	wire	rtc_ppd;
	reg	r_rtc_ack;
`ifdef	GPSTRK_ACCESS
	wire	rtc_pps;
`endif
	wire	[5-1:0]	w_btn;
	wire	[8-1:0]	w_led;
	// scrn_mouse is a 32-bit field containing 16-bits of x-position and
	// 16-bits of y position, limited to the size of the screen.
	wire	[31:0]	scrn_mouse;
	// Remove this scope tag via inheritance when/if you connect the
	// scope interrupt
	//
	// Virilator lint_off UNUSED
	wire	scopc_int;
	// Virilator lint_on  UNUSED
	// Remove this scope tag via inheritance when/if you connect the
	// scope interrupt
	//
	// Virilator lint_off UNUSED
	wire	scope_int;
	// Virilator lint_on  UNUSED
	//
	//
	// UART interface
	//
	//
	localparam [23:0] BUSUART = 24'h64;	// 1000000 baud
	//
	wire	w_ck_uart, w_uart_tx;
	wire		rx_host_stb;
	wire	[7:0]	rx_host_data;
	wire		tx_host_stb;
	wire	[7:0]	tx_host_data;
	wire		tx_host_busy;
	//
	// Definitions for the WB-UART converter.  We really only need one
	// (more) non-bus wire--one to use to select if we are interacting
	// with the ZipCPU or not.
	wire		wbu_zip_sel;
	wire	[0:0]	wbubus_dbg;
`ifndef	INCLUDE_ZIPCPU
	//
	// The bus-console depends upon the zip_dbg wires.  If there is no
	// ZipCPU defining them, we'll need to define them here anyway.
	//
	wire		zip_dbg_stall, zip_dbg_ack;
	wire	[31:0]	zip_dbg_data;
`endif
	wire	[31:0]	edid_dbg;

// }}}
	////////////////////////////////////////////////////////////////////////
	//
	// Declaring interrupt vector wires
	// {{{
	// These declarations come from the various components having
	// PIC and PIC.MAX keys.
	//
	wire	[14:0]	sys_int_vector;
	wire	[14:0]	alt_int_vector;
	wire	[14:0]	bus_int_vector;
	// }}}
	////////////////////////////////////////////////////////////////////////
	//
	// Declare bus signals
	// {{{
	////////////////////////////////////////////////////////////////////////

	// Bus wb
	// {{{
	// Wishbone definitions for bus wb, component zip
	// Verilator lint_off UNUSED
	wire		wb_zip_cyc, wb_zip_stb, wb_zip_we;
	wire	[27:0]	wb_zip_addr;
	wire	[31:0]	wb_zip_data;
	wire	[3:0]	wb_zip_sel;
	wire		wb_zip_stall, wb_zip_ack, wb_zip_err;
	wire	[31:0]	wb_zip_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb, component wbu_arbiter
	// Verilator lint_off UNUSED
	wire		wb_wbu_arbiter_cyc, wb_wbu_arbiter_stb, wb_wbu_arbiter_we;
	wire	[27:0]	wb_wbu_arbiter_addr;
	wire	[31:0]	wb_wbu_arbiter_data;
	wire	[3:0]	wb_wbu_arbiter_sel;
	wire		wb_wbu_arbiter_stall, wb_wbu_arbiter_ack, wb_wbu_arbiter_err;
	wire	[31:0]	wb_wbu_arbiter_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb(SIO), component buildtime
	// Verilator lint_off UNUSED
	wire		wb_buildtime_cyc, wb_buildtime_stb, wb_buildtime_we;
	wire	[27:0]	wb_buildtime_addr;
	wire	[31:0]	wb_buildtime_data;
	wire	[3:0]	wb_buildtime_sel;
	wire		wb_buildtime_stall, wb_buildtime_ack, wb_buildtime_err;
	wire	[31:0]	wb_buildtime_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb(SIO), component buserr
	// Verilator lint_off UNUSED
	wire		wb_buserr_cyc, wb_buserr_stb, wb_buserr_we;
	wire	[27:0]	wb_buserr_addr;
	wire	[31:0]	wb_buserr_data;
	wire	[3:0]	wb_buserr_sel;
	wire		wb_buserr_stall, wb_buserr_ack, wb_buserr_err;
	wire	[31:0]	wb_buserr_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb(SIO), component buspic
	// Verilator lint_off UNUSED
	wire		wb_buspic_cyc, wb_buspic_stb, wb_buspic_we;
	wire	[27:0]	wb_buspic_addr;
	wire	[31:0]	wb_buspic_data;
	wire	[3:0]	wb_buspic_sel;
	wire		wb_buspic_stall, wb_buspic_ack, wb_buspic_err;
	wire	[31:0]	wb_buspic_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb(SIO), component clkhdmiin
	// Verilator lint_off UNUSED
	wire		wb_clkhdmiin_cyc, wb_clkhdmiin_stb, wb_clkhdmiin_we;
	wire	[27:0]	wb_clkhdmiin_addr;
	wire	[31:0]	wb_clkhdmiin_data;
	wire	[3:0]	wb_clkhdmiin_sel;
	wire		wb_clkhdmiin_stall, wb_clkhdmiin_ack, wb_clkhdmiin_err;
	wire	[31:0]	wb_clkhdmiin_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb(SIO), component clkhdmiout
	// Verilator lint_off UNUSED
	wire		wb_clkhdmiout_cyc, wb_clkhdmiout_stb, wb_clkhdmiout_we;
	wire	[27:0]	wb_clkhdmiout_addr;
	wire	[31:0]	wb_clkhdmiout_data;
	wire	[3:0]	wb_clkhdmiout_sel;
	wire		wb_clkhdmiout_stall, wb_clkhdmiout_ack, wb_clkhdmiout_err;
	wire	[31:0]	wb_clkhdmiout_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb(SIO), component gpio
	// Verilator lint_off UNUSED
	wire		wb_gpio_cyc, wb_gpio_stb, wb_gpio_we;
	wire	[27:0]	wb_gpio_addr;
	wire	[31:0]	wb_gpio_data;
	wire	[3:0]	wb_gpio_sel;
	wire		wb_gpio_stall, wb_gpio_ack, wb_gpio_err;
	wire	[31:0]	wb_gpio_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb(SIO), component hdmi_scope_frame_offset
	// Verilator lint_off UNUSED
	wire		wb_hdmi_scope_frame_offset_cyc, wb_hdmi_scope_frame_offset_stb, wb_hdmi_scope_frame_offset_we;
	wire	[27:0]	wb_hdmi_scope_frame_offset_addr;
	wire	[31:0]	wb_hdmi_scope_frame_offset_data;
	wire	[3:0]	wb_hdmi_scope_frame_offset_sel;
	wire		wb_hdmi_scope_frame_offset_stall, wb_hdmi_scope_frame_offset_ack, wb_hdmi_scope_frame_offset_err;
	wire	[31:0]	wb_hdmi_scope_frame_offset_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb(SIO), component pwrcount
	// Verilator lint_off UNUSED
	wire		wb_pwrcount_cyc, wb_pwrcount_stb, wb_pwrcount_we;
	wire	[27:0]	wb_pwrcount_addr;
	wire	[31:0]	wb_pwrcount_data;
	wire	[3:0]	wb_pwrcount_sel;
	wire		wb_pwrcount_stall, wb_pwrcount_ack, wb_pwrcount_err;
	wire	[31:0]	wb_pwrcount_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb(SIO), component rtcdate
	// Verilator lint_off UNUSED
	wire		wb_rtcdate_cyc, wb_rtcdate_stb, wb_rtcdate_we;
	wire	[27:0]	wb_rtcdate_addr;
	wire	[31:0]	wb_rtcdate_data;
	wire	[3:0]	wb_rtcdate_sel;
	wire		wb_rtcdate_stall, wb_rtcdate_ack, wb_rtcdate_err;
	wire	[31:0]	wb_rtcdate_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb(SIO), component spio
	// Verilator lint_off UNUSED
	wire		wb_spio_cyc, wb_spio_stb, wb_spio_we;
	wire	[27:0]	wb_spio_addr;
	wire	[31:0]	wb_spio_data;
	wire	[3:0]	wb_spio_sel;
	wire		wb_spio_stall, wb_spio_ack, wb_spio_err;
	wire	[31:0]	wb_spio_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb(SIO), component subseconds
	// Verilator lint_off UNUSED
	wire		wb_subseconds_cyc, wb_subseconds_stb, wb_subseconds_we;
	wire	[27:0]	wb_subseconds_addr;
	wire	[31:0]	wb_subseconds_data;
	wire	[3:0]	wb_subseconds_sel;
	wire		wb_subseconds_stall, wb_subseconds_ack, wb_subseconds_err;
	wire	[31:0]	wb_subseconds_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb(SIO), component sysclk
	// Verilator lint_off UNUSED
	wire		wb_sysclk_cyc, wb_sysclk_stb, wb_sysclk_we;
	wire	[27:0]	wb_sysclk_addr;
	wire	[31:0]	wb_sysclk_data;
	wire	[3:0]	wb_sysclk_sel;
	wire		wb_sysclk_stall, wb_sysclk_ack, wb_sysclk_err;
	wire	[31:0]	wb_sysclk_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb(SIO), component version
	// Verilator lint_off UNUSED
	wire		wb_version_cyc, wb_version_stb, wb_version_we;
	wire	[27:0]	wb_version_addr;
	wire	[31:0]	wb_version_data;
	wire	[3:0]	wb_version_sel;
	wire		wb_version_stall, wb_version_ack, wb_version_err;
	wire	[31:0]	wb_version_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb(DIO), component gck
	// Verilator lint_off UNUSED
	wire		wb_gck_cyc, wb_gck_stb, wb_gck_we;
	wire	[27:0]	wb_gck_addr;
	wire	[31:0]	wb_gck_data;
	wire	[3:0]	wb_gck_sel;
	wire		wb_gck_stall, wb_gck_ack, wb_gck_err;
	wire	[31:0]	wb_gck_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb(DIO), component mous
	// Verilator lint_off UNUSED
	wire		wb_mous_cyc, wb_mous_stb, wb_mous_we;
	wire	[27:0]	wb_mous_addr;
	wire	[31:0]	wb_mous_data;
	wire	[3:0]	wb_mous_sel;
	wire		wb_mous_stall, wb_mous_ack, wb_mous_err;
	wire	[31:0]	wb_mous_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb(DIO), component oled
	// Verilator lint_off UNUSED
	wire		wb_oled_cyc, wb_oled_stb, wb_oled_we;
	wire	[27:0]	wb_oled_addr;
	wire	[31:0]	wb_oled_data;
	wire	[3:0]	wb_oled_sel;
	wire		wb_oled_stall, wb_oled_ack, wb_oled_err;
	wire	[31:0]	wb_oled_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb(DIO), component rtc
	// Verilator lint_off UNUSED
	wire		wb_rtc_cyc, wb_rtc_stb, wb_rtc_we;
	wire	[27:0]	wb_rtc_addr;
	wire	[31:0]	wb_rtc_data;
	wire	[3:0]	wb_rtc_sel;
	wire		wb_rtc_stall, wb_rtc_ack, wb_rtc_err;
	wire	[31:0]	wb_rtc_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb(DIO), component gtb
	// Verilator lint_off UNUSED
	wire		wb_gtb_cyc, wb_gtb_stb, wb_gtb_we;
	wire	[27:0]	wb_gtb_addr;
	wire	[31:0]	wb_gtb_data;
	wire	[3:0]	wb_gtb_sel;
	wire		wb_gtb_stall, wb_gtb_ack, wb_gtb_err;
	wire	[31:0]	wb_gtb_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb(DIO), component netp
	// Verilator lint_off UNUSED
	wire		wb_netp_cyc, wb_netp_stb, wb_netp_we;
	wire	[27:0]	wb_netp_addr;
	wire	[31:0]	wb_netp_data;
	wire	[3:0]	wb_netp_sel;
	wire		wb_netp_stall, wb_netp_ack, wb_netp_err;
	wire	[31:0]	wb_netp_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb(DIO), component hdmiin
	// Verilator lint_off UNUSED
	wire		wb_hdmiin_cyc, wb_hdmiin_stb, wb_hdmiin_we;
	wire	[27:0]	wb_hdmiin_addr;
	wire	[31:0]	wb_hdmiin_data;
	wire	[3:0]	wb_hdmiin_sel;
	wire		wb_hdmiin_stall, wb_hdmiin_ack, wb_hdmiin_err;
	wire	[31:0]	wb_hdmiin_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb(DIO), component wb_sio
	// Verilator lint_off UNUSED
	wire		wb_sio_cyc, wb_sio_stb, wb_sio_we;
	wire	[27:0]	wb_sio_addr;
	wire	[31:0]	wb_sio_data;
	wire	[3:0]	wb_sio_sel;
	wire		wb_sio_stall, wb_sio_ack, wb_sio_err;
	wire	[31:0]	wb_sio_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb(DIO), component edin
	// Verilator lint_off UNUSED
	wire		wb_edin_cyc, wb_edin_stb, wb_edin_we;
	wire	[27:0]	wb_edin_addr;
	wire	[31:0]	wb_edin_data;
	wire	[3:0]	wb_edin_sel;
	wire		wb_edin_stall, wb_edin_ack, wb_edin_err;
	wire	[31:0]	wb_edin_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb(DIO), component edout
	// Verilator lint_off UNUSED
	wire		wb_edout_cyc, wb_edout_stb, wb_edout_we;
	wire	[27:0]	wb_edout_addr;
	wire	[31:0]	wb_edout_data;
	wire	[3:0]	wb_edout_sel;
	wire		wb_edout_stall, wb_edout_ack, wb_edout_err;
	wire	[31:0]	wb_edout_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb, component flashcfg
	// Verilator lint_off UNUSED
	wire		wb_flashcfg_cyc, wb_flashcfg_stb, wb_flashcfg_we;
	wire	[27:0]	wb_flashcfg_addr;
	wire	[31:0]	wb_flashcfg_data;
	wire	[3:0]	wb_flashcfg_sel;
	wire		wb_flashcfg_stall, wb_flashcfg_ack, wb_flashcfg_err;
	wire	[31:0]	wb_flashcfg_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb, component pmic
	// Verilator lint_off UNUSED
	wire		wb_pmic_cyc, wb_pmic_stb, wb_pmic_we;
	wire	[27:0]	wb_pmic_addr;
	wire	[31:0]	wb_pmic_data;
	wire	[3:0]	wb_pmic_sel;
	wire		wb_pmic_stall, wb_pmic_ack, wb_pmic_err;
	wire	[31:0]	wb_pmic_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb, component scop_edid
	// Verilator lint_off UNUSED
	wire		wb_scop_edid_cyc, wb_scop_edid_stb, wb_scop_edid_we;
	wire	[27:0]	wb_scop_edid_addr;
	wire	[31:0]	wb_scop_edid_data;
	wire	[3:0]	wb_scop_edid_sel;
	wire		wb_scop_edid_stall, wb_scop_edid_ack, wb_scop_edid_err;
	wire	[31:0]	wb_scop_edid_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb, component scopc
	// Verilator lint_off UNUSED
	wire		wb_scopc_cyc, wb_scopc_stb, wb_scopc_we;
	wire	[27:0]	wb_scopc_addr;
	wire	[31:0]	wb_scopc_data;
	wire	[3:0]	wb_scopc_sel;
	wire		wb_scopc_stall, wb_scopc_ack, wb_scopc_err;
	wire	[31:0]	wb_scopc_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb, component scope
	// Verilator lint_off UNUSED
	wire		wb_scope_cyc, wb_scope_stb, wb_scope_we;
	wire	[27:0]	wb_scope_addr;
	wire	[31:0]	wb_scope_data;
	wire	[3:0]	wb_scope_sel;
	wire		wb_scope_stall, wb_scope_ack, wb_scope_err;
	wire	[31:0]	wb_scope_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb, component scope_hdmiin
	// Verilator lint_off UNUSED
	wire		wb_scope_hdmiin_cyc, wb_scope_hdmiin_stb, wb_scope_hdmiin_we;
	wire	[27:0]	wb_scope_hdmiin_addr;
	wire	[31:0]	wb_scope_hdmiin_data;
	wire	[3:0]	wb_scope_hdmiin_sel;
	wire		wb_scope_hdmiin_stall, wb_scope_hdmiin_ack, wb_scope_hdmiin_err;
	wire	[31:0]	wb_scope_hdmiin_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb, component gpsu
	// Verilator lint_off UNUSED
	wire		wb_gpsu_cyc, wb_gpsu_stb, wb_gpsu_we;
	wire	[27:0]	wb_gpsu_addr;
	wire	[31:0]	wb_gpsu_data;
	wire	[3:0]	wb_gpsu_sel;
	wire		wb_gpsu_stall, wb_gpsu_ack, wb_gpsu_err;
	wire	[31:0]	wb_gpsu_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb, component sdcard
	// Verilator lint_off UNUSED
	wire		wb_sdcard_cyc, wb_sdcard_stb, wb_sdcard_we;
	wire	[27:0]	wb_sdcard_addr;
	wire	[31:0]	wb_sdcard_data;
	wire	[3:0]	wb_sdcard_sel;
	wire		wb_sdcard_stall, wb_sdcard_ack, wb_sdcard_err;
	wire	[31:0]	wb_sdcard_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb, component cfg
	// Verilator lint_off UNUSED
	wire		wb_cfg_cyc, wb_cfg_stb, wb_cfg_we;
	wire	[27:0]	wb_cfg_addr;
	wire	[31:0]	wb_cfg_data;
	wire	[3:0]	wb_cfg_sel;
	wire		wb_cfg_stall, wb_cfg_ack, wb_cfg_err;
	wire	[31:0]	wb_cfg_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb, component mdio
	// Verilator lint_off UNUSED
	wire		wb_mdio_cyc, wb_mdio_stb, wb_mdio_we;
	wire	[27:0]	wb_mdio_addr;
	wire	[31:0]	wb_mdio_data;
	wire	[3:0]	wb_mdio_sel;
	wire		wb_mdio_stall, wb_mdio_ack, wb_mdio_err;
	wire	[31:0]	wb_mdio_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb, component wb_dio
	// Verilator lint_off UNUSED
	wire		wb_dio_cyc, wb_dio_stb, wb_dio_we;
	wire	[27:0]	wb_dio_addr;
	wire	[31:0]	wb_dio_data;
	wire	[3:0]	wb_dio_sel;
	wire		wb_dio_stall, wb_dio_ack, wb_dio_err;
	wire	[31:0]	wb_dio_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb, component netb
	// Verilator lint_off UNUSED
	wire		wb_netb_cyc, wb_netb_stb, wb_netb_we;
	wire	[27:0]	wb_netb_addr;
	wire	[31:0]	wb_netb_data;
	wire	[3:0]	wb_netb_sel;
	wire		wb_netb_stall, wb_netb_ack, wb_netb_err;
	wire	[31:0]	wb_netb_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb, component bkram
	// Verilator lint_off UNUSED
	wire		wb_bkram_cyc, wb_bkram_stb, wb_bkram_we;
	wire	[27:0]	wb_bkram_addr;
	wire	[31:0]	wb_bkram_data;
	wire	[3:0]	wb_bkram_sel;
	wire		wb_bkram_stall, wb_bkram_ack, wb_bkram_err;
	wire	[31:0]	wb_bkram_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb, component flash
	// Verilator lint_off UNUSED
	wire		wb_flash_cyc, wb_flash_stb, wb_flash_we;
	wire	[27:0]	wb_flash_addr;
	wire	[31:0]	wb_flash_data;
	wire	[3:0]	wb_flash_sel;
	wire		wb_flash_stall, wb_flash_ack, wb_flash_err;
	wire	[31:0]	wb_flash_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb, component xpand
	// Verilator lint_off UNUSED
	wire		wb_xpand_cyc, wb_xpand_stb, wb_xpand_we;
	wire	[27:0]	wb_xpand_addr;
	wire	[31:0]	wb_xpand_data;
	wire	[3:0]	wb_xpand_sel;
	wire		wb_xpand_stall, wb_xpand_ack, wb_xpand_err;
	wire	[31:0]	wb_xpand_idata;
	// Verilator lint_on UNUSED
	// }}}
	// Bus wbu
	// {{{
	// Wishbone definitions for bus wbu, component wbu
	// Verilator lint_off UNUSED
	wire		wbu_wbu_cyc, wbu_wbu_stb, wbu_wbu_we;
	wire	[1:0]	wbu_wbu_addr;
	wire	[31:0]	wbu_wbu_data;
	wire	[3:0]	wbu_wbu_sel;
	wire		wbu_wbu_stall, wbu_wbu_ack, wbu_wbu_err;
	wire	[31:0]	wbu_wbu_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wbu, component wbu_arbiter
	// Verilator lint_off UNUSED
	wire		wbu_wbu_arbiter_cyc, wbu_wbu_arbiter_stb, wbu_wbu_arbiter_we;
	wire	[1:0]	wbu_wbu_arbiter_addr;
	wire	[31:0]	wbu_wbu_arbiter_data;
	wire	[3:0]	wbu_wbu_arbiter_sel;
	wire		wbu_wbu_arbiter_stall, wbu_wbu_arbiter_ack, wbu_wbu_arbiter_err;
	wire	[31:0]	wbu_wbu_arbiter_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wbu, component zip
	// Verilator lint_off UNUSED
	wire		wbu_zip_cyc, wbu_zip_stb, wbu_zip_we;
	wire	[1:0]	wbu_zip_addr;
	wire	[31:0]	wbu_zip_data;
	wire	[3:0]	wbu_zip_sel;
	wire		wbu_zip_stall, wbu_zip_ack, wbu_zip_err;
	wire	[31:0]	wbu_zip_idata;
	// Verilator lint_on UNUSED
	// }}}
	// Bus rambus
	// {{{
	// Wishbone definitions for bus rambus, component hdmiin
	// Verilator lint_off UNUSED
	wire		rambus_hdmiin_cyc, rambus_hdmiin_stb, rambus_hdmiin_we;
	wire	[24:0]	rambus_hdmiin_addr;
	wire	[127:0]	rambus_hdmiin_data;
	wire	[15:0]	rambus_hdmiin_sel;
	wire		rambus_hdmiin_stall, rambus_hdmiin_ack, rambus_hdmiin_err;
	wire	[127:0]	rambus_hdmiin_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus rambus, component xpand
	// Verilator lint_off UNUSED
	wire		rambus_xpand_cyc, rambus_xpand_stb, rambus_xpand_we;
	wire	[24:0]	rambus_xpand_addr;
	wire	[127:0]	rambus_xpand_data;
	wire	[15:0]	rambus_xpand_sel;
	wire		rambus_xpand_stall, rambus_xpand_ack, rambus_xpand_err;
	wire	[127:0]	rambus_xpand_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus rambus, component sdram
	// Verilator lint_off UNUSED
	wire		rambus_sdram_cyc, rambus_sdram_stb, rambus_sdram_we;
	wire	[24:0]	rambus_sdram_addr;
	wire	[127:0]	rambus_sdram_data;
	wire	[15:0]	rambus_sdram_sel;
	wire		rambus_sdram_stall, rambus_sdram_ack, rambus_sdram_err;
	wire	[127:0]	rambus_sdram_idata;
	// Verilator lint_on UNUSED
	// }}}
	// }}}
	////////////////////////////////////////////////////////////////////////
	//
	// Peripheral address decoding, bus handling
	// {{{
	//
	// BUS-LOGIC for wb
	// {{{
	//
	// wb Bus logic to handle SINGLE slaves
	//
	reg		r_wb_sio_ack;
	reg	[31:0]	r_wb_sio_data;

	assign	wb_sio_stall = 1'b0;

	initial r_wb_sio_ack = 1'b0;
	always	@(posedge i_clk)
		r_wb_sio_ack <= (wb_sio_stb);
	assign	wb_sio_ack = r_wb_sio_ack;

	always	@(posedge i_clk)
	casez( wb_sio_addr[3:0] )
	4'h0: r_wb_sio_data <= wb_buildtime_idata;
	4'h1: r_wb_sio_data <= wb_buserr_idata;
	4'h2: r_wb_sio_data <= wb_buspic_idata;
	4'h3: r_wb_sio_data <= wb_clkhdmiin_idata;
	4'h4: r_wb_sio_data <= wb_clkhdmiout_idata;
	4'h5: r_wb_sio_data <= wb_gpio_idata;
	4'h6: r_wb_sio_data <= wb_hdmi_scope_frame_offset_idata;
	4'h7: r_wb_sio_data <= wb_pwrcount_idata;
	4'h8: r_wb_sio_data <= wb_rtcdate_idata;
	4'h9: r_wb_sio_data <= wb_spio_idata;
	4'ha: r_wb_sio_data <= wb_subseconds_idata;
	4'hb: r_wb_sio_data <= wb_sysclk_idata;
	4'hc: r_wb_sio_data <= wb_version_idata;
	default: r_wb_sio_data <= wb_version_idata;
	endcase
	assign	wb_sio_idata = r_wb_sio_data;


	//
	// Now to translate this logic to the various SIO slaves
	//
	// In this case, the SIO bus has the prefix wb_sio
	// and all of the slaves have various wires beginning
	// with their own respective bus prefixes.
	// Our goal here is to make certain that all of
	// the slave bus inputs match the SIO bus wires
	assign	wb_buildtime_cyc = wb_sio_cyc;
	assign	wb_buildtime_stb = wb_sio_stb && (wb_sio_addr[ 3: 0] ==  4'h0);  // 0x0000000
	assign	wb_buildtime_we  = wb_sio_we;
	assign	wb_buildtime_data= wb_sio_data;
	assign	wb_buildtime_sel = wb_sio_sel;
	assign	wb_buserr_cyc = wb_sio_cyc;
	assign	wb_buserr_stb = wb_sio_stb && (wb_sio_addr[ 3: 0] ==  4'h1);  // 0x0000004
	assign	wb_buserr_we  = wb_sio_we;
	assign	wb_buserr_data= wb_sio_data;
	assign	wb_buserr_sel = wb_sio_sel;
	assign	wb_buspic_cyc = wb_sio_cyc;
	assign	wb_buspic_stb = wb_sio_stb && (wb_sio_addr[ 3: 0] ==  4'h2);  // 0x0000008
	assign	wb_buspic_we  = wb_sio_we;
	assign	wb_buspic_data= wb_sio_data;
	assign	wb_buspic_sel = wb_sio_sel;
	assign	wb_clkhdmiin_cyc = wb_sio_cyc;
	assign	wb_clkhdmiin_stb = wb_sio_stb && (wb_sio_addr[ 3: 0] ==  4'h3);  // 0x000000c
	assign	wb_clkhdmiin_we  = wb_sio_we;
	assign	wb_clkhdmiin_data= wb_sio_data;
	assign	wb_clkhdmiin_sel = wb_sio_sel;
	assign	wb_clkhdmiout_cyc = wb_sio_cyc;
	assign	wb_clkhdmiout_stb = wb_sio_stb && (wb_sio_addr[ 3: 0] ==  4'h4);  // 0x0000010
	assign	wb_clkhdmiout_we  = wb_sio_we;
	assign	wb_clkhdmiout_data= wb_sio_data;
	assign	wb_clkhdmiout_sel = wb_sio_sel;
	assign	wb_gpio_cyc = wb_sio_cyc;
	assign	wb_gpio_stb = wb_sio_stb && (wb_sio_addr[ 3: 0] ==  4'h5);  // 0x0000014
	assign	wb_gpio_we  = wb_sio_we;
	assign	wb_gpio_data= wb_sio_data;
	assign	wb_gpio_sel = wb_sio_sel;
	assign	wb_hdmi_scope_frame_offset_cyc = wb_sio_cyc;
	assign	wb_hdmi_scope_frame_offset_stb = wb_sio_stb && (wb_sio_addr[ 3: 0] ==  4'h6);  // 0x0000018
	assign	wb_hdmi_scope_frame_offset_we  = wb_sio_we;
	assign	wb_hdmi_scope_frame_offset_data= wb_sio_data;
	assign	wb_hdmi_scope_frame_offset_sel = wb_sio_sel;
	assign	wb_pwrcount_cyc = wb_sio_cyc;
	assign	wb_pwrcount_stb = wb_sio_stb && (wb_sio_addr[ 3: 0] ==  4'h7);  // 0x000001c
	assign	wb_pwrcount_we  = wb_sio_we;
	assign	wb_pwrcount_data= wb_sio_data;
	assign	wb_pwrcount_sel = wb_sio_sel;
	assign	wb_rtcdate_cyc = wb_sio_cyc;
	assign	wb_rtcdate_stb = wb_sio_stb && (wb_sio_addr[ 3: 0] ==  4'h8);  // 0x0000020
	assign	wb_rtcdate_we  = wb_sio_we;
	assign	wb_rtcdate_data= wb_sio_data;
	assign	wb_rtcdate_sel = wb_sio_sel;
	assign	wb_spio_cyc = wb_sio_cyc;
	assign	wb_spio_stb = wb_sio_stb && (wb_sio_addr[ 3: 0] ==  4'h9);  // 0x0000024
	assign	wb_spio_we  = wb_sio_we;
	assign	wb_spio_data= wb_sio_data;
	assign	wb_spio_sel = wb_sio_sel;
	assign	wb_subseconds_cyc = wb_sio_cyc;
	assign	wb_subseconds_stb = wb_sio_stb && (wb_sio_addr[ 3: 0] ==  4'ha);  // 0x0000028
	assign	wb_subseconds_we  = wb_sio_we;
	assign	wb_subseconds_data= wb_sio_data;
	assign	wb_subseconds_sel = wb_sio_sel;
	assign	wb_sysclk_cyc = wb_sio_cyc;
	assign	wb_sysclk_stb = wb_sio_stb && (wb_sio_addr[ 3: 0] ==  4'hb);  // 0x000002c
	assign	wb_sysclk_we  = wb_sio_we;
	assign	wb_sysclk_data= wb_sio_data;
	assign	wb_sysclk_sel = wb_sio_sel;
	assign	wb_version_cyc = wb_sio_cyc;
	assign	wb_version_stb = wb_sio_stb && (wb_sio_addr[ 3: 0] ==  4'hc);  // 0x0000030
	assign	wb_version_we  = wb_sio_we;
	assign	wb_version_data= wb_sio_data;
	assign	wb_version_sel = wb_sio_sel;
	//
	// wb Bus logic to handle 10 DOUBLE slaves
	//
	//
	reg	[1:0]	r_wb_dio_ack;
	// # dlist = 10, nextlg(#dlist) = 4
	reg	[3:0]	r_wb_dio_bus_select;
	reg	[31:0]	r_wb_dio_data;

	// DOUBLE peripherals are not allowed to stall.
	assign	wb_dio_stall = 1'b0;

	// DOUBLE peripherals return their acknowledgments in two
	// clocks--always, allowing us to collect this logic together
	// in a slave independent manner.  Here, the acknowledgment
	// is treated as a two stage shift register, cleared on any
	// reset, or any time the cycle line drops.  (Dropping the
	// cycle line aborts the transaction.)
	initial	r_wb_dio_ack = 0;
	always	@(posedge i_clk)
	if (i_reset || !wb_dio_cyc)
		r_wb_dio_ack <= 0;
	else
		r_wb_dio_ack <= { r_wb_dio_ack[0], (wb_dio_stb) };
	assign	wb_dio_ack = r_wb_dio_ack[1];

	// Since it costs us two clocks to go through this
	// logic, we'll take one of those clocks here to set
	// a selection index, and then on the next clock we'll
	// use this index to select from among the vaious
	// possible bus return values
	always @(posedge i_clk)
	casez(wb_dio_addr[7:2])
	6'b00_0000: r_wb_dio_bus_select <= 4'd0;
	6'b00_0001: r_wb_dio_bus_select <= 4'd1;
	6'b00_0010: r_wb_dio_bus_select <= 4'd2;
	6'b00_0011: r_wb_dio_bus_select <= 4'd3;
	6'b00_010?: r_wb_dio_bus_select <= 4'd4;
	6'b00_011?: r_wb_dio_bus_select <= 4'd5;
	6'b00_10??: r_wb_dio_bus_select <= 4'd6;
	6'b00_11??: r_wb_dio_bus_select <= 4'd7;
	6'b01_????: r_wb_dio_bus_select <= 4'd8;
	6'b1?_????: r_wb_dio_bus_select <= 4'd9;
	default: r_wb_dio_bus_select <= 0;
	endcase

	always	@(posedge i_clk)
	casez(r_wb_dio_bus_select)
	4'd0: r_wb_dio_data <= wb_gck_idata;
	4'd1: r_wb_dio_data <= wb_mous_idata;
	4'd2: r_wb_dio_data <= wb_oled_idata;
	4'd3: r_wb_dio_data <= wb_rtc_idata;
	4'd4: r_wb_dio_data <= wb_gtb_idata;
	4'd5: r_wb_dio_data <= wb_netp_idata;
	4'd6: r_wb_dio_data <= wb_hdmiin_idata;
	4'd7: r_wb_dio_data <= wb_sio_idata;
	4'd8: r_wb_dio_data <= wb_edin_idata;
	4'd9: r_wb_dio_data <= wb_edout_idata;
	default: r_wb_dio_data <= wb_edout_idata;
	endcase

	assign	wb_dio_idata = r_wb_dio_data;

	assign	wb_gck_cyc = wb_dio_cyc;
	assign	wb_gck_stb = wb_dio_stb && ((wb_dio_addr[ 7: 2] &  6'h3f) ==  6'h00);  // 0x0000000 - 0x000000f
	assign	wb_gck_we  = wb_dio_we;
	assign	wb_gck_addr= wb_dio_addr;
	assign	wb_gck_data= wb_dio_data;
	assign	wb_gck_sel = wb_dio_sel;
	assign	wb_mous_cyc = wb_dio_cyc;
	assign	wb_mous_stb = wb_dio_stb && ((wb_dio_addr[ 7: 2] &  6'h3f) ==  6'h01);  // 0x0000010 - 0x000001f
	assign	wb_mous_we  = wb_dio_we;
	assign	wb_mous_addr= wb_dio_addr;
	assign	wb_mous_data= wb_dio_data;
	assign	wb_mous_sel = wb_dio_sel;
	assign	wb_oled_cyc = wb_dio_cyc;
	assign	wb_oled_stb = wb_dio_stb && ((wb_dio_addr[ 7: 2] &  6'h3f) ==  6'h02);  // 0x0000020 - 0x000002f
	assign	wb_oled_we  = wb_dio_we;
	assign	wb_oled_addr= wb_dio_addr;
	assign	wb_oled_data= wb_dio_data;
	assign	wb_oled_sel = wb_dio_sel;
	assign	wb_rtc_cyc = wb_dio_cyc;
	assign	wb_rtc_stb = wb_dio_stb && ((wb_dio_addr[ 7: 2] &  6'h3f) ==  6'h03);  // 0x0000030 - 0x000003f
	assign	wb_rtc_we  = wb_dio_we;
	assign	wb_rtc_addr= wb_dio_addr;
	assign	wb_rtc_data= wb_dio_data;
	assign	wb_rtc_sel = wb_dio_sel;
	assign	wb_gtb_cyc = wb_dio_cyc;
	assign	wb_gtb_stb = wb_dio_stb && ((wb_dio_addr[ 7: 2] &  6'h3e) ==  6'h04);  // 0x0000040 - 0x000005f
	assign	wb_gtb_we  = wb_dio_we;
	assign	wb_gtb_addr= wb_dio_addr;
	assign	wb_gtb_data= wb_dio_data;
	assign	wb_gtb_sel = wb_dio_sel;
	assign	wb_netp_cyc = wb_dio_cyc;
	assign	wb_netp_stb = wb_dio_stb && ((wb_dio_addr[ 7: 2] &  6'h3e) ==  6'h06);  // 0x0000060 - 0x000007f
	assign	wb_netp_we  = wb_dio_we;
	assign	wb_netp_addr= wb_dio_addr;
	assign	wb_netp_data= wb_dio_data;
	assign	wb_netp_sel = wb_dio_sel;
	assign	wb_hdmiin_cyc = wb_dio_cyc;
	assign	wb_hdmiin_stb = wb_dio_stb && ((wb_dio_addr[ 7: 2] &  6'h3c) ==  6'h08);  // 0x0000080 - 0x00000bf
	assign	wb_hdmiin_we  = wb_dio_we;
	assign	wb_hdmiin_addr= wb_dio_addr;
	assign	wb_hdmiin_data= wb_dio_data;
	assign	wb_hdmiin_sel = wb_dio_sel;
	assign	wb_sio_cyc = wb_dio_cyc;
	assign	wb_sio_stb = wb_dio_stb && ((wb_dio_addr[ 7: 2] &  6'h3c) ==  6'h0c);  // 0x00000c0 - 0x00000ff
	assign	wb_sio_we  = wb_dio_we;
	assign	wb_sio_addr= wb_dio_addr;
	assign	wb_sio_data= wb_dio_data;
	assign	wb_sio_sel = wb_dio_sel;
	assign	wb_edin_cyc = wb_dio_cyc;
	assign	wb_edin_stb = wb_dio_stb && ((wb_dio_addr[ 7: 2] &  6'h30) ==  6'h10);  // 0x0000100 - 0x00001ff
	assign	wb_edin_we  = wb_dio_we;
	assign	wb_edin_addr= wb_dio_addr;
	assign	wb_edin_data= wb_dio_data;
	assign	wb_edin_sel = wb_dio_sel;
	assign	wb_edout_cyc = wb_dio_cyc;
	assign	wb_edout_stb = wb_dio_stb && ((wb_dio_addr[ 7: 2] &  6'h20) ==  6'h20);  // 0x0000200 - 0x00003ff
	assign	wb_edout_we  = wb_dio_we;
	assign	wb_edout_addr= wb_dio_addr;
	assign	wb_edout_data= wb_dio_data;
	assign	wb_edout_sel = wb_dio_sel;
	assign	wb_flashcfg_err= 1'b0;
	assign	wb_pmic_err= 1'b0;
	assign	wb_scop_edid_err= 1'b0;
	assign	wb_scopc_err= 1'b0;
	assign	wb_scope_err= 1'b0;
	assign	wb_scope_hdmiin_err= 1'b0;
	assign	wb_gpsu_err= 1'b0;
	assign	wb_sdcard_err= 1'b0;
	assign	wb_cfg_err= 1'b0;
	assign	wb_mdio_err= 1'b0;
	assign	wb_dio_err= 1'b0;
	assign	wb_netb_err= 1'b0;
	assign	wb_bkram_err= 1'b0;
	assign	wb_flash_err= 1'b0;
	// info: @ERROR.WIRE for xpand matches the buses error name, wb_xpand_err
	//
	// Connect the wb bus components together using the wbxbar()
	//
	//
	wbxbar #(
		.NM(2), .NS(15), .AW(28), .DW(32),
		.SLAVE_ADDR({
			// Address width    = 28
			// Address LSBs     = 2
			// Slave name width = 12
			{ 28'h8000000 }, //        xpand: 0x20000000
			{ 28'h7000000 }, //        flash: 0x1c000000
			{ 28'h6800000 }, //        bkram: 0x1a000000
			{ 28'h6000000 }, //         netb: 0x18000000
			{ 28'h5800000 }, //       wb_dio: 0x16000000
			{ 28'h5000000 }, //         mdio: 0x14000000
			{ 28'h4800000 }, //          cfg: 0x12000000
			{ 28'h4000000 }, //       sdcard: 0x10000000
			{ 28'h3800000 }, //         gpsu: 0x0e000000
			{ 28'h3000000 }, // scope_hdmiin: 0x0c000000
			{ 28'h2800000 }, //        scope: 0x0a000000
			{ 28'h2000000 }, //        scopc: 0x08000000
			{ 28'h1800000 }, //    scop_edid: 0x06000000
			{ 28'h1000000 }, //         pmic: 0x04000000
			{ 28'h0800000 }  //     flashcfg: 0x02000000
		}),
		.SLAVE_MASK({
			// Address width    = 28
			// Address LSBs     = 2
			// Slave name width = 12
			{ 28'h8000000 }, //        xpand
			{ 28'hf800000 }, //        flash
			{ 28'hf800000 }, //        bkram
			{ 28'hf800000 }, //         netb
			{ 28'hf800000 }, //       wb_dio
			{ 28'hf800000 }, //         mdio
			{ 28'hf800000 }, //          cfg
			{ 28'hf800000 }, //       sdcard
			{ 28'hf800000 }, //         gpsu
			{ 28'hf800000 }, // scope_hdmiin
			{ 28'hf800000 }, //        scope
			{ 28'hf800000 }, //        scopc
			{ 28'hf800000 }, //    scop_edid
			{ 28'hf800000 }, //         pmic
			{ 28'hf800000 }  //     flashcfg
		}),
		.OPT_DBLBUFFER(1'b1))
	wb_xbar(
		.i_clk(i_clk), .i_reset(i_reset),
		.i_mcyc({
			wb_wbu_arbiter_cyc,
			wb_zip_cyc
		}),
		.i_mstb({
			wb_wbu_arbiter_stb,
			wb_zip_stb
		}),
		.i_mwe({
			wb_wbu_arbiter_we,
			wb_zip_we
		}),
		.i_maddr({
			wb_wbu_arbiter_addr,
			wb_zip_addr
		}),
		.i_mdata({
			wb_wbu_arbiter_data,
			wb_zip_data
		}),
		.i_msel({
			wb_wbu_arbiter_sel,
			wb_zip_sel
		}),
		.o_mstall({
			wb_wbu_arbiter_stall,
			wb_zip_stall
		}),
		.o_mack({
			wb_wbu_arbiter_ack,
			wb_zip_ack
		}),
		.o_mdata({
			wb_wbu_arbiter_idata,
			wb_zip_idata
		}),
		.o_merr({
			wb_wbu_arbiter_err,
			wb_zip_err
		}),
		// Slave connections
		.o_scyc({
			wb_xpand_cyc,
			wb_flash_cyc,
			wb_bkram_cyc,
			wb_netb_cyc,
			wb_dio_cyc,
			wb_mdio_cyc,
			wb_cfg_cyc,
			wb_sdcard_cyc,
			wb_gpsu_cyc,
			wb_scope_hdmiin_cyc,
			wb_scope_cyc,
			wb_scopc_cyc,
			wb_scop_edid_cyc,
			wb_pmic_cyc,
			wb_flashcfg_cyc
		}),
		.o_sstb({
			wb_xpand_stb,
			wb_flash_stb,
			wb_bkram_stb,
			wb_netb_stb,
			wb_dio_stb,
			wb_mdio_stb,
			wb_cfg_stb,
			wb_sdcard_stb,
			wb_gpsu_stb,
			wb_scope_hdmiin_stb,
			wb_scope_stb,
			wb_scopc_stb,
			wb_scop_edid_stb,
			wb_pmic_stb,
			wb_flashcfg_stb
		}),
		.o_swe({
			wb_xpand_we,
			wb_flash_we,
			wb_bkram_we,
			wb_netb_we,
			wb_dio_we,
			wb_mdio_we,
			wb_cfg_we,
			wb_sdcard_we,
			wb_gpsu_we,
			wb_scope_hdmiin_we,
			wb_scope_we,
			wb_scopc_we,
			wb_scop_edid_we,
			wb_pmic_we,
			wb_flashcfg_we
		}),
		.o_saddr({
			wb_xpand_addr,
			wb_flash_addr,
			wb_bkram_addr,
			wb_netb_addr,
			wb_dio_addr,
			wb_mdio_addr,
			wb_cfg_addr,
			wb_sdcard_addr,
			wb_gpsu_addr,
			wb_scope_hdmiin_addr,
			wb_scope_addr,
			wb_scopc_addr,
			wb_scop_edid_addr,
			wb_pmic_addr,
			wb_flashcfg_addr
		}),
		.o_sdata({
			wb_xpand_data,
			wb_flash_data,
			wb_bkram_data,
			wb_netb_data,
			wb_dio_data,
			wb_mdio_data,
			wb_cfg_data,
			wb_sdcard_data,
			wb_gpsu_data,
			wb_scope_hdmiin_data,
			wb_scope_data,
			wb_scopc_data,
			wb_scop_edid_data,
			wb_pmic_data,
			wb_flashcfg_data
		}),
		.o_ssel({
			wb_xpand_sel,
			wb_flash_sel,
			wb_bkram_sel,
			wb_netb_sel,
			wb_dio_sel,
			wb_mdio_sel,
			wb_cfg_sel,
			wb_sdcard_sel,
			wb_gpsu_sel,
			wb_scope_hdmiin_sel,
			wb_scope_sel,
			wb_scopc_sel,
			wb_scop_edid_sel,
			wb_pmic_sel,
			wb_flashcfg_sel
		}),
		.i_sstall({
			wb_xpand_stall,
			wb_flash_stall,
			wb_bkram_stall,
			wb_netb_stall,
			wb_dio_stall,
			wb_mdio_stall,
			wb_cfg_stall,
			wb_sdcard_stall,
			wb_gpsu_stall,
			wb_scope_hdmiin_stall,
			wb_scope_stall,
			wb_scopc_stall,
			wb_scop_edid_stall,
			wb_pmic_stall,
			wb_flashcfg_stall
		}),
		.i_sack({
			wb_xpand_ack,
			wb_flash_ack,
			wb_bkram_ack,
			wb_netb_ack,
			wb_dio_ack,
			wb_mdio_ack,
			wb_cfg_ack,
			wb_sdcard_ack,
			wb_gpsu_ack,
			wb_scope_hdmiin_ack,
			wb_scope_ack,
			wb_scopc_ack,
			wb_scop_edid_ack,
			wb_pmic_ack,
			wb_flashcfg_ack
		}),
		.i_sdata({
			wb_xpand_idata,
			wb_flash_idata,
			wb_bkram_idata,
			wb_netb_idata,
			wb_dio_idata,
			wb_mdio_idata,
			wb_cfg_idata,
			wb_sdcard_idata,
			wb_gpsu_idata,
			wb_scope_hdmiin_idata,
			wb_scope_idata,
			wb_scopc_idata,
			wb_scop_edid_idata,
			wb_pmic_idata,
			wb_flashcfg_idata
		}),
		.i_serr({
			wb_xpand_err,
			wb_flash_err,
			wb_bkram_err,
			wb_netb_err,
			wb_dio_err,
			wb_mdio_err,
			wb_cfg_err,
			wb_sdcard_err,
			wb_gpsu_err,
			wb_scope_hdmiin_err,
			wb_scope_err,
			wb_scopc_err,
			wb_scop_edid_err,
			wb_pmic_err,
			wb_flashcfg_err
		})
		);

	// End of bus logic for wb
	// }}}
	//
	// BUS-LOGIC for wbu
	// {{{
	//
	// No class SINGLE peripherals on the "wbu" bus
	//

	//
	// No class DOUBLE peripherals on the "wbu" bus
	//

	assign	wbu_wbu_arbiter_err= 1'b0;
	assign	wbu_zip_err= 1'b0;
	//
	// Connect the wbu bus components together using the wbxbar()
	//
	//
	wbxbar #(
		.NM(1), .NS(2), .AW(2), .DW(32),
		.SLAVE_ADDR({
			// Address width    = 2
			// Address LSBs     = 2
			// Slave name width = 11
			{ 2'h2 }, //         zip: 0x8
			{ 2'h0 }  // wbu_arbiter: 0x0
		}),
		.SLAVE_MASK({
			// Address width    = 2
			// Address LSBs     = 2
			// Slave name width = 11
			{ 2'h2 }, //         zip
			{ 2'h2 }  // wbu_arbiter
		}),
		.OPT_DBLBUFFER(1'b1))
	wbu_xbar(
		.i_clk(i_clk), .i_reset(i_reset),
		.i_mcyc({
			wbu_wbu_cyc
		}),
		.i_mstb({
			wbu_wbu_stb
		}),
		.i_mwe({
			wbu_wbu_we
		}),
		.i_maddr({
			wbu_wbu_addr
		}),
		.i_mdata({
			wbu_wbu_data
		}),
		.i_msel({
			wbu_wbu_sel
		}),
		.o_mstall({
			wbu_wbu_stall
		}),
		.o_mack({
			wbu_wbu_ack
		}),
		.o_mdata({
			wbu_wbu_idata
		}),
		.o_merr({
			wbu_wbu_err
		}),
		// Slave connections
		.o_scyc({
			wbu_zip_cyc,
			wbu_wbu_arbiter_cyc
		}),
		.o_sstb({
			wbu_zip_stb,
			wbu_wbu_arbiter_stb
		}),
		.o_swe({
			wbu_zip_we,
			wbu_wbu_arbiter_we
		}),
		.o_saddr({
			wbu_zip_addr,
			wbu_wbu_arbiter_addr
		}),
		.o_sdata({
			wbu_zip_data,
			wbu_wbu_arbiter_data
		}),
		.o_ssel({
			wbu_zip_sel,
			wbu_wbu_arbiter_sel
		}),
		.i_sstall({
			wbu_zip_stall,
			wbu_wbu_arbiter_stall
		}),
		.i_sack({
			wbu_zip_ack,
			wbu_wbu_arbiter_ack
		}),
		.i_sdata({
			wbu_zip_idata,
			wbu_wbu_arbiter_idata
		}),
		.i_serr({
			wbu_zip_err,
			wbu_wbu_arbiter_err
		})
		);

	// End of bus logic for wbu
	// }}}
	//
	// BUS-LOGIC for rambus
	// {{{
	//
	// No class SINGLE peripherals on the "rambus" bus
	//

	//
	// No class DOUBLE peripherals on the "rambus" bus
	//

	assign	rambus_sdram_err= 1'b0;
	//
	// Connect the rambus bus components together using the wbxbar()
	//
	//
	wbxbar #(
		.NM(2), .NS(1), .AW(25), .DW(128),
		.SLAVE_ADDR({
			// Address width    = 25
			// Address LSBs     = 4
			// Slave name width = 5
			{ 25'h0000000 }  // sdram: 0x00000000
		}),
		.SLAVE_MASK({
			// Address width    = 25
			// Address LSBs     = 4
			// Slave name width = 5
			{ 25'h0000000 }  // sdram
		}),
		.OPT_DBLBUFFER(1'b1))
	rambus_xbar(
		.i_clk(i_clk), .i_reset(i_reset),
		.i_mcyc({
			rambus_xpand_cyc,
			rambus_hdmiin_cyc
		}),
		.i_mstb({
			rambus_xpand_stb,
			rambus_hdmiin_stb
		}),
		.i_mwe({
			rambus_xpand_we,
			rambus_hdmiin_we
		}),
		.i_maddr({
			rambus_xpand_addr,
			rambus_hdmiin_addr
		}),
		.i_mdata({
			rambus_xpand_data,
			rambus_hdmiin_data
		}),
		.i_msel({
			rambus_xpand_sel,
			rambus_hdmiin_sel
		}),
		.o_mstall({
			rambus_xpand_stall,
			rambus_hdmiin_stall
		}),
		.o_mack({
			rambus_xpand_ack,
			rambus_hdmiin_ack
		}),
		.o_mdata({
			rambus_xpand_idata,
			rambus_hdmiin_idata
		}),
		.o_merr({
			rambus_xpand_err,
			rambus_hdmiin_err
		}),
		// Slave connections
		.o_scyc({
			rambus_sdram_cyc
		}),
		.o_sstb({
			rambus_sdram_stb
		}),
		.o_swe({
			rambus_sdram_we
		}),
		.o_saddr({
			rambus_sdram_addr
		}),
		.o_sdata({
			rambus_sdram_data
		}),
		.o_ssel({
			rambus_sdram_sel
		}),
		.i_sstall({
			rambus_sdram_stall
		}),
		.i_sack({
			rambus_sdram_ack
		}),
		.i_sdata({
			rambus_sdram_idata
		}),
		.i_serr({
			rambus_sdram_err
		})
		);

	// End of bus logic for rambus
	// }}}
	// }}}
	////////////////////////////////////////////////////////////////////////
	//
	// Declare the interrupt busses
	// {{{
	// Interrupt busses are defined by anything with a @PIC tag.
	// The @PIC.BUS tag defines the name of the wire bus below,
	// while the @PIC.MAX tag determines the size of the bus width.
	//
	// For your peripheral to be assigned to this bus, it must have an
	// @INT.NAME.WIRE= tag to define the wire name of the interrupt line,
	// and an @INT.NAME.PIC= tag matching the @PIC.BUS tag of the bus
	// your interrupt will be assigned to.  If an @INT.NAME.ID tag also
	// exists, then your interrupt will be assigned to the position given
	// by the ID# in that tag.
	//
	assign	sys_int_vector = {
		1'b0,
		1'b0,
		pmic_int,
		mous_interrupt,
		ck_pps,
		sdcard_int,
		netrx_int,
		nettx_int,
		w_bus_int,
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		1'b0
	};
	assign	alt_int_vector = {
		rtc_int,
		edid_out_int,
		gpsutxf_int,
		gpsurxf_int,
		gpsutx_int,
		gpsurx_int,
		gpio_int,
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		1'b0
	};
	assign	bus_int_vector = {
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		mous_interrupt,
		spio_int,
		scop_hdmiin_int,
		sdcard_int,
		scop_edid_int
	};
	// }}}
	////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////
	//
	// @MAIN.INSERT and @MAIN.ALT
	// {{{
	////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////
	//
	//
	// Now we turn to defining all of the parts and pieces of what
	// each of the various peripherals does, and what logic it needs.
	//
	// This information comes from the @MAIN.INSERT and @MAIN.ALT tags.
	// If an @ACCESS tag is available, an ifdef is created to handle
	// having the access and not.  If the @ACCESS tag is `defined above
	// then the @MAIN.INSERT code is executed.  If not, the @MAIN.ALT
	// code is exeucted, together with any other cleanup settings that
	// might need to take place--such as returning zeros to the bus,
	// or making sure all of the various interrupt wires are set to
	// zero if the component is not included.
	//
`ifdef	INCLUDE_ZIPCPU
	// {{{
	//
	//
	// The ZipCPU/ZipSystem BUS master
	//
	//
	assign	zip_int_vector = { alt_int_vector[14:8], sys_int_vector[14:6] };
	zipsystem #(.RESET_ADDRESS(RESET_ADDRESS),
			.ADDRESS_WIDTH(ZIP_ADDRESS_WIDTH),
			.LGICACHE(12),.LGDCACHE(12),
			.START_HALTED(ZIP_START_HALTED),
`ifdef	VERILATOR
			.RESET_DURATION(20),
`else
			.RESET_DURATION(20_000),
`endif
			.EXTERNAL_INTERRUPTS(ZIP_INTS))
		swic(i_clk, (i_reset)||(i_cpu_reset),
			// Zippys wishbone interface
			wb_zip_cyc, wb_zip_stb, wb_zip_we,
			wb_zip_addr[28-1:0],
			wb_zip_data, // 32 bits wide
			wb_zip_sel,  // 32/8 bits wide
		wb_zip_stall, wb_zip_ack, wb_zip_idata,wb_zip_err,
			zip_int_vector, zip_cpu_int,
			// Debug wishbone interface
			wbu_zip_cyc, wbu_zip_stb, wbu_zip_we,
			wbu_zip_addr[1-1:0],
			wbu_zip_data, // 32 bits wide
			wbu_zip_sel,  // 32/8 bits wide
		wbu_zip_stall, wbu_zip_ack, wbu_zip_idata,
			zip_debug);
	assign	zip_trigger = zip_debug[31];
	// }}}
`else	// INCLUDE_ZIPCPU
	// {{{
	// Null bus master
	// {{{
	// }}}
	// Null bus slave
	// {{{

	//
	// In the case that there is no wbu_zip peripheral
	// responding on the wbu bus
	assign	wbu_zip_ack   = 1'b0;
	assign	wbu_zip_err   = (wbu_zip_stb);
	assign	wbu_zip_stall = 0;
	assign	wbu_zip_idata = 0;

	// }}}
	// Null interrupt definitions
	// {{{
	assign	zip_cpu_int = 1'b0;	// zip.INT.ZIP.WIRE
	// }}}
	// }}}
`endif	// INCLUDE_ZIPCPU

	assign	edid_scope_trigger = edido_dbg[31];
	assign	edid_scope_data    = edido_dbg[30:0];
	wbscopc	#(.LGMEM(5'hb), .MAX_STEP(31'h10000)) theicscop(i_clk, 1'b1,
			edid_scope_trigger, edid_scope_data,
			i_clk, wb_scop_edid_cyc, wb_scop_edid_stb, wb_scop_edid_we,
			wb_scop_edid_addr[1-1:0],
			wb_scop_edid_data, // 32 bits wide
			wb_scop_edid_sel,  // 32/8 bits wide
		wb_scop_edid_stall, wb_scop_edid_ack, wb_scop_edid_idata,
			scop_edid_int);
`ifdef	GPIO_ACCESS
	// {{{
	//
	// GPIO
	//
	// This interface should allow us to control up to 16 GPIO inputs, and
	// another 16 GPIO outputs.  The interrupt trips when any of the inputs
	// changes.  (Sorry, which input isn't (yet) selectable.)
	//
	localparam	INITIAL_GPIO = 16'h04f;
	wbgpio	#(NGPI, NGPO, INITIAL_GPIO)
		gpioi(i_clk, wb_gpio_cyc, wb_gpio_stb, wb_gpio_we,
			wb_gpio_data, // 32 bits wide
			wb_gpio_sel,  // 32/8 bits wide
		wb_gpio_stall, wb_gpio_ack, wb_gpio_idata,
			i_gpio, o_gpio, gpio_int);

	assign	sd_reset = o_gpio[6];
	// }}}
`else	// GPIO_ACCESS
	// {{{
	// Null interrupt definitions
	// {{{
	assign	gpio_int = 1'b0;	// gpio.INT.GPIO.WIRE
	// }}}
	// }}}
`endif	// GPIO_ACCESS

`ifdef	FLASHCFG_ACCESS
	// {{{
	// The Flash control interface is defined by the flash instantiation
	// hence we don't need to do anything to define it here.
	// }}}
`else	// FLASHCFG_ACCESS
	// {{{
	// Null bus slave
	// {{{

	//
	// In the case that there is no wb_flashcfg peripheral
	// responding on the wb bus
	assign	wb_flashcfg_ack   = 1'b0;
	assign	wb_flashcfg_err   = (wb_flashcfg_stb);
	assign	wb_flashcfg_stall = 0;
	assign	wb_flashcfg_idata = 0;

	// }}}
	// }}}
`endif	// FLASHCFG_ACCESS

`ifdef	GPSTRK_ACCESS
	assign	wb_subseconds_idata = gps_now[31:0];
`else
	always @(posedge i_clk)
	if (wb_subseconds_stb && wb_subseconds_we)
		r_subseconds_data <= wb_data;
	else
		r_subseconds_data <= r_subseconds_data
			+ { 16'h0, RTLCLKSTEP[31:16] };

	assign	wb_subseconds_idata = r_subseconds_data;
`endif
`ifdef	FLASH_ACCESS
	// {{{
	qflexpress #(.LGFLASHSZ(24), .OPT_CLKDIV(1),
		.NDUMMY(6), .RDDELAY(1),
		.OPT_STARTUP_FILE("spansion.hex"),
`ifdef	FLASHCFG_ACCESS
		.OPT_CFG(1'b1)
`else
		.OPT_CFG(1'b0)
`endif
		)
		flashi(i_clk, i_reset,
			// Primary memory reading inputs
			wb_flash_cyc, wb_flash_stb, wb_flash_we,
			wb_flash_addr[22-1:0],
			wb_flash_data, // 32 bits wide
			wb_flash_sel,  // 32/8 bits wide
		wb_flash_stall, wb_flash_ack, wb_flash_idata,
			// Configuration bus ports
			wb_flashcfg_cyc, wb_flashcfg_stb, wb_flashcfg_we,
			wb_flashcfg_data, // 32 bits wide
			wb_flashcfg_sel,  // 32/8 bits wide
		wb_flashcfg_stall, wb_flashcfg_ack, wb_flashcfg_idata,
			o_qspi_sck, o_qspi_cs_n, o_qspi_mod, o_qspi_dat, i_qspi_dat,
			flash_dbg_trigger, flash_debug);
	// }}}
`else	// FLASH_ACCESS
	// {{{
	assign	o_qspi_sck  = 1'b1;
	assign	o_qspi_cs_n = 1'b1;
	assign	o_qspi_mod  = 2'b01;
	assign	o_qspi_dat  = 4'b1111;
	// Null bus slave
	// {{{

	//
	// In the case that there is no wb_flash peripheral
	// responding on the wb bus
	assign	wb_flash_ack   = 1'b0;
	assign	wb_flash_err   = (wb_flash_stb);
	assign	wb_flash_stall = 0;
	assign	wb_flash_idata = 0;

	// }}}
	// }}}
`endif	// FLASH_ACCESS

	clkcounter clkclkhdmioutctr(i_clk, ck_pps, i_clk_200mhz, wb_clkhdmiout_idata);

	initial	r_clkhdmiout_ack = 0;
	always @(posedge i_clk)
		r_clkhdmiout_ack <= (wb_clkhdmiout_stb);
	assign	wb_clkhdmiout_ack   = r_clkhdmiout_ack;
	assign	wb_clkhdmiout_stall = 1'b0;
`ifdef	GPSUART_ACCESS
	// {{{
	wbuart #(.INITIAL_SETUP(31'h000028b0))
		gpsu_uart(i_clk, 1'b0,
			wb_gpsu_cyc, wb_gpsu_stb, wb_gpsu_we,
			wb_gpsu_addr[2-1:0],
			wb_gpsu_data, // 32 bits wide
			wb_gpsu_sel,  // 32/8 bits wide
		wb_gpsu_stall, wb_gpsu_ack, wb_gpsu_idata,
			i_gpsu_rx, o_gpsu_tx, w_gpsu_cts_n, w_gpsu_rts_n,
			gpsurx_int, gpsutx_int,
			gpsurxf_int, gpsutxf_int);
	// }}}
`else	// GPSUART_ACCESS
	// {{{
	assign	o_gpsu_tx    = 1'b1;
	assign	w_gpsu_rts_n = 1'b0;
	// Null bus slave
	// {{{

	//
	// In the case that there is no wb_gpsu peripheral
	// responding on the wb bus
	assign	wb_gpsu_ack   = 1'b0;
	assign	wb_gpsu_err   = (wb_gpsu_stb);
	assign	wb_gpsu_stall = 0;
	assign	wb_gpsu_idata = 0;

	// }}}
	// Null interrupt definitions
	// {{{
	assign	gpsurxf_int = 1'b0;	// gpsu.INT.GPSRXF.WIRE
	assign	gpsutxf_int = 1'b0;	// gpsu.INT.GPSTXF.WIRE
	assign	gpsutx_int = 1'b0;	// gpsu.INT.GPSTX.WIRE
	assign	gpsurx_int = 1'b0;	// gpsu.INT.GPSRX.WIRE
	// }}}
	// }}}
`endif	// GPSUART_ACCESS

`ifdef	BKRAM_ACCESS
	// {{{
	memdev #(.LGMEMSZ(20), .EXTRACLOCK(1))
		bkrami(i_clk, i_reset,
			wb_bkram_cyc, wb_bkram_stb, wb_bkram_we,
			wb_bkram_addr[18-1:0],
			wb_bkram_data, // 32 bits wide
			wb_bkram_sel,  // 32/8 bits wide
		wb_bkram_stall, wb_bkram_ack, wb_bkram_idata);
	// }}}
`else	// BKRAM_ACCESS
	// {{{
	// Null bus slave
	// {{{

	//
	// In the case that there is no wb_bkram peripheral
	// responding on the wb bus
	assign	wb_bkram_ack   = 1'b0;
	assign	wb_bkram_err   = (wb_bkram_stb);
	assign	wb_bkram_stall = 0;
	assign	wb_bkram_idata = 0;

	// }}}
	// }}}
`endif	// BKRAM_ACCESS

	always @(posedge i_clk)
	if (wb_zip_err)
	begin
		r_buserr_addr <= 0;
		r_buserr_addr[28-1:0] <= wb_zip_addr[28-1:0];
	end else if (wbu_wbu_err)
	begin
		r_buserr_addr <= 0;
		r_buserr_addr[2-1:0] <= wbu_wbu_addr[2-1:0];
	end
	assign	wb_buserr_stall= 1'b0;
	assign	wb_buserr_ack  = wb_buserr_stb;
	assign	wb_buserr_idata = { {(30-28){1'b0}},
			r_buserr_addr, 2'b00 };
`ifdef	ETHERNET_ACCESS
	// {{{
	enetpackets	#(.MEMORY_ADDRESS_WIDTH(14))
		netctrl(i_clk, i_reset,
			wb_netb_cyc, wb_netb_stb, wb_netb_we,
			wb_netb_addr[13-1:0],
			wb_netb_data, // 32 bits wide
			wb_netb_sel,  // 32/8 bits wide
		wb_netb_stall, wb_netb_ack, wb_netb_idata,
			wb_netp_cyc, wb_netp_stb, wb_netp_we,
			wb_netp_addr[3-1:0],
			wb_netp_data, // 32 bits wide
			wb_netp_sel,  // 32/8 bits wide
		wb_netp_stall, wb_netp_ack, wb_netp_idata,
			o_net_reset_n,
			i_net_rx_clk, i_net_rx_dv, i_net_rx_err, i_net_rxd,
			i_clk_125mhz, o_net_tx_clk, o_net_tx_ctl, o_net_txd,
			netrx_int, nettx_int, netp_debug_clk, netp_debug);

	// }}}
`else	// ETHERNET_ACCESS
	// {{{
	// Null interrupt definitions
	// {{{
	assign	nettx_int = 1'b0;	// netp.INT.NETTX.WIRE
	assign	netrx_int = 1'b0;	// netp.INT.NETRX.WIRE
	// }}}
	// }}}
`endif	// ETHERNET_ACCESS

`ifdef	BUSPIC_ACCESS
	// {{{
	//
	// The BUS Interrupt controller
	//
	icontrol #(15)	buspici(i_clk, 1'b0,
			wb_buspic_cyc, wb_buspic_stb, wb_buspic_we,
			wb_buspic_data, // 32 bits wide
			wb_buspic_sel,  // 32/8 bits wide
		wb_buspic_stall, wb_buspic_ack, wb_buspic_idata,
			bus_int_vector, w_bus_int);
	// }}}
`else	// BUSPIC_ACCESS
	// {{{
	// Null interrupt definitions
	// {{{
	assign	w_bus_int = 1'b0;	// buspic.INT.BUS.WIRE
	// }}}
	// }}}
`endif	// BUSPIC_ACCESS

`ifndef	ETHERNET_ACCESS
	// Ethernet packet memory declaration
	//
	// The only time this needs to be defined is when the ethernet module
	// itself isnt defined.  Otherwise, the access is accomplished by the
	// ethernet module

	memdev #(14)
		enet_buffers(i_clk,
			wb_netb_cyc, wb_netb_stb, wb_netb_we,
			wb_netb_addr[13-1:0],
			wb_netb_data, // 32 bits wide
			wb_netb_sel,  // 32/8 bits wide
		wb_netb_stall, wb_netb_ack, wb_netb_idata);

`else

// These don't need to be defined here, and indeed should not be defined here
// lest their definitions override those of the netb interface defined in the
// enetpackets module
//
//	assign	wb_netb_ack   = 1'b0;
//	assign	wb_netb_stall = 1'b0;
//	assign	wb_netb_data  = wb_netp_data;

`endif

	clkcounter clksysclkctr(i_clk, ck_pps, i_clk, wb_sysclk_idata);

	initial	r_sysclk_ack = 0;
	always @(posedge i_clk)
		r_sysclk_ack <= (wb_sysclk_stb);
	assign	wb_sysclk_ack   = r_sysclk_ack;
	assign	wb_sysclk_stall = 1'b0;
	assign	wb_version_idata = `DATESTAMP;
	assign	wb_version_ack = wb_version_stb;
	assign	wb_version_stall = 1'b0;
	clkcounter clkclkhdmiinctr(i_clk, ck_pps, i_hdmi_in_clk, wb_clkhdmiin_idata);

	initial	r_clkhdmiin_ack = 0;
	always @(posedge i_clk)
		r_clkhdmiin_ack <= (wb_clkhdmiin_stb);
	assign	wb_clkhdmiin_ack   = r_clkhdmiin_ack;
	assign	wb_clkhdmiin_stall = 1'b0;
	assign	o_hdmi_out_r = hdmi_in_r;
	assign	o_hdmi_out_g = hdmi_in_g;
	assign	o_hdmi_out_b = hdmi_in_b;

`ifdef	GPSTRK_ACCESS
	gpsclock_tb #(.CLOCK_FREQUENCY_HZ(100000000))
		ppstb(i_clk, ck_pps, tb_pps,
			wb_gtb_cyc, wb_gtb_stb, wb_gtb_we,
			wb_gtb_addr[3-1:0],
			wb_gtb_data, // 32 bits wide
			wb_gtb_sel,  // 32/8 bits wide
		wb_gtb_stall, wb_gtb_ack, wb_gtb_idata,
			gps_err, gps_now, gps_step);

`ifdef	GPSTB
	assign	gps_pps = tb_pps;
`else
	assign	gps_pps = i_gps_pps;
`endif

`endif

`ifdef	SDSPI_ACCESS
	// {{{
	// SPI mapping
	wire	w_sd_cs_n, w_sd_mosi, w_sd_miso;

	sdspi	sdcardi(i_clk, sd_reset,
		wb_sdcard_cyc, wb_sdcard_stb, wb_sdcard_we,
			wb_sdcard_addr[2-1:0],
			wb_sdcard_data, // 32 bits wide
			wb_sdcard_sel,  // 32/8 bits wide
		wb_sdcard_stall, wb_sdcard_ack, wb_sdcard_idata,
		w_sd_cs_n, o_sd_sck, w_sd_mosi, w_sd_miso, i_sd_detect,
		sdcard_int, 1'b1, sdspi_debug);

	assign	w_sd_miso = i_sd_data[0];
	assign	o_sd_data = { w_sd_cs_n, 3'b111 };
	assign	o_sd_cmd  = w_sd_mosi;
	// }}}
`else	// SDSPI_ACCESS
	// {{{
	assign	o_sd_sck   = 1'b1;
	assign	o_sd_cmd   = 1'b1;
	assign	o_sd_data  = 4'hf;
	// Null bus slave
	// {{{

	//
	// In the case that there is no wb_sdcard peripheral
	// responding on the wb bus
	assign	wb_sdcard_ack   = 1'b0;
	assign	wb_sdcard_err   = (wb_sdcard_stb);
	assign	wb_sdcard_stall = 0;
	assign	wb_sdcard_idata = 0;

	// }}}
	// Null interrupt definitions
	// {{{
	assign	sdcard_int = 1'b0;	// sdcard.INT.SDCARD.WIRE
	// }}}
	// }}}
`endif	// SDSPI_ACCESS

`ifdef	HDMIIN_ACCESS
	// {{{
	// HDMI input processor
	hdmiin	thehdmiin(i_clk, i_hdmi_in_clk, ck_pps,
			//
			i_hdmi_in_actual_delay_r,
			i_hdmi_in_actual_delay_g,
			i_hdmi_in_actual_delay_b,
			o_hdmi_in_delay,
			//
			i_hdmi_in_r, i_hdmi_in_g, i_hdmi_in_b,
			wb_cyc, (wb_stb)&&(hdmiin_sel), wb_we, wb_addr[3:0],
				wb_data, wb_sel,
			hdmiin_stall, hdmiin_ack, hdmiin_data,
			rambus_cyc, rambus_stb, rambus_we,
				rambus_addr, rambus_data, rambus_sel,
				rambus_stall, rambus_ack, rambus_err,
			hdmiin_int,
			hin_pixels, hin_dbg_scope);

	assign	hdmi_in_r = hin_pixels[29:20];
	assign	hdmi_in_g = hin_pixels[19:10];
	assign	hdmi_in_b = hin_pixels[ 9: 0];
	// }}}
`else	// HDMIIN_ACCESS
	// {{{
	// Null bus master
	// {{{
	// }}}
	// Null interrupt definitions
	// {{{
	assign	hdmiin_int = 1'b0;	// hdmiin.INT.VSYNC.WIRE
	// }}}
	// }}}
`endif	// HDMIIN_ACCESS

`ifdef	GPSTRK_ACCESS
	// {{{
	// Verilator lint_off UNUSED
	wire	[1:0]	ck_dbg;
	// Verilator lint_on  UNUSED

	gpsclock #(.DEFAULT_STEP(GPSCLOCK_DEFAULT_STEP))
		ppsck(i_clk, 1'b0, gps_pps, ck_pps, gps_led,
			wb_gck_cyc, wb_gck_stb, wb_gck_we,
			wb_gck_addr[2-1:0],
			wb_gck_data, // 32 bits wide
			wb_gck_sel,  // 32/8 bits wide
		wb_gck_stall, wb_gck_ack, wb_gck_idata,
			gps_tracking, gps_now, gps_step, gps_err, gps_locked,
			ck_dbg);
	// }}}
`else	// GPSTRK_ACCESS
	// {{{
	wire	[31:0]	pre_step;
	assign	pre_step = { 16'h00, (({GPSCLOCK_DEFAULT_STEP[27:0],20'h00})
				>>GPSCLOCK_DEFAULT_STEP[31:28]) };
	always @(posedge i_clk)
		{ ck_pps, gps_step[31:0] } <= gps_step + pre_step;
	assign	gck_stall  = 1'b0;
	assign	gps_now    = 64'h0;
	assign	gps_err    = 64'h0;
	assign	gps_step   = 64'h0;
	assign	gps_led    = 1'b0;
	assign	gps_locked = 1'b0;

	// Null interrupt definitions
	// {{{
	assign	ck_pps = 1'b0;	// gck.INT.PPS.WIRE
	// }}}
	// }}}
`endif	// GPSTRK_ACCESS

	assign	wb_buildtime_idata = `BUILDTIME;
	assign	wb_buildtime_ack = wb_buildtime_stb;
	assign	wb_buildtime_stall = 1'b0;
`ifdef	NETCTRL_ACCESS
	// {{{
	// Verilator lint_off UNUSED
	wire[31:0]	mdio_debug;
	// Verilator lint_on  UNUSED
	enetctrl #(2)
		mdio(i_clk, i_reset, wb_mdio_cyc, wb_mdio_stb, wb_mdio_we,
			wb_mdio_addr[5-1:0],
			wb_mdio_data, // 32 bits wide
			wb_mdio_sel,  // 32/8 bits wide
		wb_mdio_stall, wb_mdio_ack, wb_mdio_idata,
			o_mdclk, o_mdio, i_mdio, o_mdwe, mdio_debug);
	// }}}
`else	// NETCTRL_ACCESS
	// {{{
	assign	o_mdclk = 1'b1;
	assign	o_mdio  = 1'b1;
	assign	o_mdwe  = 1'b0;
	// Null bus slave
	// {{{

	//
	// In the case that there is no wb_mdio peripheral
	// responding on the wb bus
	assign	wb_mdio_ack   = 1'b0;
	assign	wb_mdio_err   = (wb_mdio_stb);
	assign	wb_mdio_stall = 0;
	assign	wb_mdio_idata = 0;

	// }}}
	// }}}
`endif	// NETCTRL_ACCESS

`ifdef	CFG_ACCESS
	// {{{
`ifdef	VERILATOR
	reg	r_cfg_ack;

	initial	r_cfg_ack = 1'b0;
	always @(posedge i_clk)
		r_cfg_ack <= wb_cfg_stb;
	assign	wb_cfg_ack   = r_cfg_ack;
	assign	wb_cfg_stall = 1'b0;
	assign	wb_cfg_idata = 32'h00;
`else
	wbicapetwo #(ICAPE_LGDIV)
		cfgport(i_clk, wb_cfg_cyc, wb_cfg_stb, wb_cfg_we,
			wb_cfg_addr[5-1:0],
			wb_cfg_data, // 32 bits wide
			wb_cfg_sel,  // 32/8 bits wide
		wb_cfg_stall, wb_cfg_ack, wb_cfg_idata);
`endif
	// }}}
`else	// CFG_ACCESS
	// {{{
	// Null bus slave
	// {{{

	//
	// In the case that there is no wb_cfg peripheral
	// responding on the wb bus
	assign	wb_cfg_ack   = 1'b0;
	assign	wb_cfg_err   = (wb_cfg_stb);
	assign	wb_cfg_stall = 0;
	assign	wb_cfg_idata = 0;

	// }}}
	// }}}
`endif	// CFG_ACCESS

`ifdef	PWRCOUNT_ACCESS
	// {{{
	initial	r_pwrcount_data = 32'h0;
	always @(posedge i_clk)
	if (r_pwrcount_data[31])
		r_pwrcount_data[30:0] <= r_pwrcount_data[30:0] + 1'b1;
	else
		r_pwrcount_data[31:0] <= r_pwrcount_data[31:0] + 1'b1;

	assign	wb_pwrcount_stall = 1'b0;
	assign	wb_pwrcount_ack   = wb_pwrcount_stb;
	assign	wb_pwrcount_idata = r_pwrcount_data;
	// }}}
`else	// PWRCOUNT_ACCESS
	// {{{
	// }}}
`endif	// PWRCOUNT_ACCESS

`ifdef	RTCDATE_ACCESS
	// {{{
	//
	// The Calendar DATE
	//
	rtcdate	rtcdatei(i_clk, rtc_ppd,
		wb_rtcdate_cyc, wb_rtcdate_stb, wb_rtcdate_we,
			wb_rtcdate_data, // 32 bits wide
			wb_rtcdate_sel,  // 32/8 bits wide
		wb_rtcdate_stall, wb_rtcdate_ack, wb_rtcdate_idata);
	// }}}
`else	// RTCDATE_ACCESS
	// {{{
	// }}}
`endif	// RTCDATE_ACCESS


	reg	scope_hdmiin_trigger, scope_hdmiin_tmp, scope_hdmiin_pre_trigger,
		scope_hdmiin_count_triggered;
	wire	scope_hdmiin_clear_stb;
	reg	[31:0]	scope_hdmiin_counter, scope_hdmiin_trigger_foo;
	initial	scope_hdmiin_pre_trigger = 1'b1;
	always @(posedge i_hdmi_in_clk)
		if (scope_hdmiin_trigger_foo == 0)
		begin
			scope_hdmiin_trigger_foo <= 32'd2475000-1'b1;
			scope_hdmiin_pre_trigger <= 1'b1;
		end else begin
			scope_hdmiin_trigger_foo <= scope_hdmiin_trigger_foo-1'b1;
			scope_hdmiin_pre_trigger <= 1'b0;
		end

	transferstb scope_hdmiin_clearctri(i_clk, i_hdmi_in_clk,
		((wb_stb)&&(scope_hdmiin_sel)&&(wb_we)&&(!wb_addr[0])),
		scope_hdmiin_clear_stb);

	initial	scope_hdmiin_count_triggered = 1'b0;
	always @(posedge i_hdmi_in_clk)
		if (scope_hdmiin_clear_stb)
			scope_hdmiin_count_triggered <= 1'b0;
		else if (scope_hdmiin_pre_trigger)
			scope_hdmiin_count_triggered <= 1'b1;

	initial	scope_hdmiin_counter = 32'hffff_ffff;
	always @(posedge i_hdmi_in_clk)
		if (!scope_hdmiin_count_triggered)
			scope_hdmiin_counter <= hdmi_scope_frame_offset_data;
		else if (scope_hdmiin_counter != 0)
			scope_hdmiin_counter <= scope_hdmiin_counter - 1'b1;

	initial	scope_hdmiin_trigger = 1'b0;
	always @(posedge i_hdmi_in_clk)
		scope_hdmiin_trigger <= (scope_hdmiin_counter == 0);

	wbscope #(.LGMEM(5'd14), .SYNCHRONOUS(0)
		) copyhdmiin(i_hdmi_in_clk, 1'b1,
			scope_hdmiin_trigger, hin_dbg_scope,
		i_clk, wb_cyc, (wb_stb)&&(scope_hdmiin_sel), wb_we, wb_addr[0],
				{ wb_data[31:20], 20'h0 },
			scope_hdmiin_stall, scope_hdmiin_ack,
			scope_hdmiin_data,
		scop_hdmiin_int);
`ifdef	HDMI_OUT_EDID_ACCESS
	// {{{
	wbi2cmaster	#(.READ_ONLY(1'b1),.MEM_ADDR_BITS(8)) the_edout(i_clk,
		wb_edout_cyc, wb_edout_stb, wb_edout_we,
			wb_edout_addr[7-1:0],
			wb_edout_data, // 32 bits wide
			wb_edout_sel,  // 32/8 bits wide
		wb_edout_stall, wb_edout_ack, wb_edout_idata,
		i_hdmi_out_scl, i_hdmi_out_sda, o_hdmi_out_scl, o_hdmi_out_sda,
		edid_out_int,
		edido_dbg);
	// }}}
`else	// HDMI_OUT_EDID_ACCESS
	// {{{
	assign	o_hdmi_out_scl = 1'b1;
	assign	o_hdmi_out_sda = 1'b1;
	// Null interrupt definitions
	// {{{
	assign	edid_out_int = 1'b0;	// edout.INT.EDID.WIRE
	// }}}
	// }}}
`endif	// HDMI_OUT_EDID_ACCESS

`ifdef	RTC_ACCESS
	// {{{
`ifdef	GPSTRK_ACCESS
	rtcgps	#(RTC_CLKSTEP) thertc(i_clk, i_reset,
		wb_rtc_cyc, wb_rtc_stb, wb_rtc_we,
			wb_rtc_addr[2-1:0],
			wb_rtc_data, // 32 bits wide
			wb_rtc_sel,  // 32/8 bits wide
		wb_rtc_stall, wb_rtc_ack, wb_rtc_idata,
		rtc_int, rtc_ppd,
		gps_tracking, ck_pps, gps_step[47:16], rtc_pps);
`else
	rtclight #(32'h2af31d) thertc(i_clk, i_reset,
		wb_cyc, (wb_stb)&&(rtc_sel), wb_we, { 1'b0, wb_addr[1:0] },
			wb_data, wb_sel,
		rtc_stall, rtc_ack, rtc_data,
		rtc_int, rtc_ppd);
`endif
	// }}}
`else	// RTC_ACCESS
	// {{{
`ifdef	GPSTRK_ACCESS
	assign	rtc_pps = 1'b0;
`endif
	assign	rtc_ppd = 1'b0;
	// Null interrupt definitions
	// {{{
	assign	rtc_int = 1'b0;	// rtc.INT.RTC.WIRE
	// }}}
	// }}}
`endif	// RTC_ACCESS

`ifdef	SDRAM_ACCESS
	// {{{
	assign	o_sdram_cyc  = rambus_sdram_cyc;
	assign	o_sdram_stb  =(rambus_sdram_stb);
	assign	o_sdram_we   = rambus_sdram_we;
	assign	o_sdram_addr = rambus_sdram_addr[25-1:0];
	assign	o_sdram_data = rambus_sdram_data;
	assign	o_sdram_sel  = rambus_sdram_sel;
	assign	rambus_sdram_ack   = i_sdram_ack;
	assign	rambus_sdram_stall = i_sdram_stall;
	assign	rambus_sdram_idata = i_sdram_data;

	// }}}
`else	// SDRAM_ACCESS
	// {{{
	// Null bus slave
	// {{{

	//
	// In the case that there is no rambus_sdram peripheral
	// responding on the rambus bus
	assign	rambus_sdram_ack   = 1'b0;
	assign	rambus_sdram_err   = (rambus_sdram_stb);
	assign	rambus_sdram_stall = 0;
	assign	rambus_sdram_idata = 0;

	// }}}
	// }}}
`endif	// SDRAM_ACCESS

`ifdef	SPIO_ACCESS
	// {{{
	//
	// Special purpose I/O driver (buttons, LEDs, and switches)
	//
	assign	w_btn = { i_btnc, i_btnd, i_btnl, i_btnr, i_btnu };

	spio #(.NBTN(5), .NLEDS(8), .NSW(8)) spioi(i_clk,
		wb_spio_cyc, wb_spio_stb, wb_spio_we,
			wb_spio_data, // 32 bits wide
			wb_spio_sel,  // 32/8 bits wide
		wb_spio_stall, wb_spio_ack, wb_spio_idata,
		i_sw, w_btn, w_led, spio_int);

	assign	o_led = w_led;

	// }}}
`else	// SPIO_ACCESS
	// {{{
	assign	w_btn = 0;
	assign	o_led = 0;
	// Null interrupt definitions
	// {{{
	assign	spio_int = 1'b0;	// spio.INT.SPIO.WIRE
	// }}}
	// }}}
`endif	// SPIO_ACCESS

`ifdef	MOUSE_ACCESS
	// {{{
	wbmouse themouse(i_clk,
		wb_mous_cyc, wb_mous_stb, wb_mous_we,
			wb_mous_addr[2-1:0],
			wb_mous_data, // 32 bits wide
			wb_mous_sel,  // 32/8 bits wide
		wb_mous_stall, wb_mous_ack, wb_mous_idata,
		i_ps2, o_ps2,
		scrn_mouse, mous_interrupt);
	// }}}
`else	// MOUSE_ACCESS
	// {{{
	// If there is no mouse, declare mouse types of things to be .. absent
	assign	scrn_mouse     = 32'h00;
	assign	o_ps2          = 2'b11;
	// Null interrupt definitions
	// {{{
	assign	mous_interrupt = 1'b0;	// mous.INT.MOUSE.WIRE
	// }}}
	// }}}
`endif	// MOUSE_ACCESS

`ifdef	OLEDBW_ACCESS
	// {{{
	wboledbw #(.CBITS(4)) oledctrl(i_clk,
		wb_oled_cyc, wb_oled_stb, wb_oled_we,
			wb_oled_addr[2-1:0],
			wb_oled_data, // 32 bits wide
			wb_oled_sel,  // 32/8 bits wide
		wb_oled_stall, wb_oled_ack, wb_oled_idata,
		o_oled_sck, o_oled_mosi, o_oled_dcn,
		{ o_oled_reset_n, o_oled_panel_en, o_oled_logic_en },
		oled_int);
	// }}}
`else	// OLEDBW_ACCESS
	// {{{
	assign	o_oled_sck     = 1'b1;
	assign	o_oled_mosi    = 1'b1;
	assign	o_oled_dcn     = 1'b1;
	assign	o_oled_reset_n = 1'b0;
	assign	o_oled_panel_en= 1'b0;
	assign	o_oled_logic_en= 1'b0;

	// Null interrupt definitions
	// {{{
	assign	oled_int = 1'b0;	// oled.INT.OLED.WIRE
	// }}}
	// }}}
`endif	// OLEDBW_ACCESS

`ifdef	MICROPHONE_ACCESS
	// {{{
	wbmic #(.DEFAULT_RELOAD(@$.CLKSPERSAMPLE))
		microphone(i_clk, 1'b0,
			wb_pmic_cyc, wb_pmic_stb, wb_pmic_we,
			wb_pmic_addr[1-1:0],
			wb_pmic_data, // 32 bits wide
			wb_pmic_sel,  // 32/8 bits wide
		wb_pmic_stall, wb_pmic_ack, wb_pmic_idata,
			o_mic_csn, o_mic_sck, i_mic_din, pmic_int);
	// }}}
`else	// MICROPHONE_ACCESS
	// {{{
	assign	o_mic_csn    = 1'b1;
	assign	o_mic_sck    = 1'b1;
	// Null bus slave
	// {{{

	//
	// In the case that there is no wb_pmic peripheral
	// responding on the wb bus
	assign	wb_pmic_ack   = 1'b0;
	assign	wb_pmic_err   = (wb_pmic_stb);
	assign	wb_pmic_stall = 0;
	assign	wb_pmic_idata = 0;

	// }}}
	// Null interrupt definitions
	// {{{
	assign	pmic_int = 1'b0;	// pmic.INT.MIC.WIRE
	// }}}
	// }}}
`endif	// MICROPHONE_ACCESS

`ifdef	SCOPC_SCOPC
	// {{{
	wbscopc #(.LGMEM(12),
		.SYNCHRONOUS(1))
	scopci(i_clk, 1'b1, @$(TRIGGER), @$(DEBUG),
		i_clk, wb_scopc_cyc, wb_scopc_stb, wb_scopc_we,
			wb_scopc_addr[1-1:0],
			wb_scopc_data, // 32 bits wide
			wb_scopc_sel,  // 32/8 bits wide
		wb_scopc_stall, wb_scopc_ack, wb_scopc_idata,
		scopc_int);
	// }}}
`else	// SCOPC_SCOPC
	// {{{
	assign	scopc_int = 0;
	// Null bus slave
	// {{{

	//
	// In the case that there is no wb_scopc peripheral
	// responding on the wb bus
	assign	wb_scopc_ack   = 1'b0;
	assign	wb_scopc_err   = (wb_scopc_stb);
	assign	wb_scopc_stall = 0;
	assign	wb_scopc_idata = 0;

	// }}}
	// }}}
`endif	// SCOPC_SCOPC

`ifdef	SCOPE_SCOPE
	// {{{
	wbscope #(.LGMEM(12),
		.SYNCHRONOUS(1))
	scopei(i_clk, 1'b1, @$(TRIGGER), @$(DEBUG),
		i_clk, wb_scope_cyc, wb_scope_stb, wb_scope_we,
			wb_scope_addr[1-1:0],
			wb_scope_data, // 32 bits wide
			wb_scope_sel,  // 32/8 bits wide
		wb_scope_stall, wb_scope_ack, wb_scope_idata,
		scope_int);
	// }}}
`else	// SCOPE_SCOPE
	// {{{
	assign	scope_int = 0;
	// Null bus slave
	// {{{

	//
	// In the case that there is no wb_scope peripheral
	// responding on the wb bus
	assign	wb_scope_ack   = 1'b0;
	assign	wb_scope_err   = (wb_scope_stb);
	assign	wb_scope_stall = 0;
	assign	wb_scope_idata = 0;

	// }}}
	// }}}
`endif	// SCOPE_SCOPE

`ifdef	WBUBUS_MASTER
	// {{{
	// The Host USB interface, to be used by the WB-UART bus
	rxuartlite	#(BUSUART) rcv(s_clk, i_host_uart_rx,
				rx_host_stb, rx_host_data);
	txuartlite	#(BUSUART) txv(s_clk, tx_host_stb, tx_host_data,
				o_host_uart_tx, tx_host_busy);

`ifdef	INCLUDE_ZIPCPU
	// assign	wbu_zip_sel   = wbu_addr[1];
`else
	assign	wbu_zip_sel   = 1'b0;
	assign	zip_dbg_ack   = 1'b0;
	assign	zip_dbg_stall = 1'b0;
	assign	zip_dbg_data  = 0;
`endif
`ifndef	BUSPIC_ACCESS
	wire	w_bus_int;
	assign	w_bus_int = 1'b0;
`endif
	wire	[31:0]	wbu_tmp_addr;
	wbubus	genbus(i_clk, i_host_rx_stb, i_host_rx_data,
			wbu_wbu_cyc, wbu_wbu_stb, wbu_wbu_we, wbu_tmp_addr, wbu_wbu_data,
			wbu_wbu_stall, wbu_wbu_ack, wbu_wbu_idata, wbu_wbu_err,
			w_bus_int,
			o_host_tx_stb, o_host_tx_data, i_host_tx_busy,
			wbubus_dbg[0]);
	assign	wbu_sel = 4'hf;
	assign	wbu_addr = wbu_tmp_addr[(2-1):0];
	// }}}
`else	// WBUBUS_MASTER
	// {{{
	// Null bus master
	// {{{
	// }}}
	// }}}
`endif	// WBUBUS_MASTER

	busexpander #(.AWIN(27), .DWIN(32),
			.DWOUT(128))
		xpandi32x128(
			i_clk, i_reset,
			wb_xpand_cyc, wb_xpand_stb, wb_xpand_we,
			wb_xpand_addr[27-1:0],
			wb_xpand_data, // 32 bits wide
			wb_xpand_sel,  // 32/8 bits wide
		wb_xpand_stall, wb_xpand_ack, wb_xpand_idata, wb_xpand_err,
			//
			rambus_xpand_cyc, rambus_xpand_stb, rambus_xpand_we,
			rambus_xpand_addr[25-1:0],
			rambus_xpand_data, // 128 bits wide
			rambus_xpand_sel,  // 128/8 bits wide
		rambus_xpand_stall, rambus_xpand_ack, rambus_xpand_idata,rambus_xpand_err);
`ifdef	HDMI_IN_EDID_ACCESS
	// {{{
	wbi2cslave	#( .INITIAL_MEM("edid.hex"),
		.I2C_READ_ONLY(1'b1),
		.MEM_ADDR_BITS(8))
	    the_input_edid(i_clk, 1'b0,
		wb_edin_cyc, wb_edin_stb, wb_edin_we,
			wb_edin_addr[6-1:0],
			wb_edin_data, // 32 bits wide
			wb_edin_sel,  // 32/8 bits wide
		wb_edin_stall, wb_edin_ack, wb_edin_idata,
		i_hdmi_in_scl, i_hdmi_in_sda, o_hdmi_in_scl, o_hdmi_in_sda,
		edid_dbg);
	// }}}
`else	// HDMI_IN_EDID_ACCESS
	// {{{
	assign	o_hdmi_in_scl = 1'b1;
	assign	o_hdmi_in_sda = 1'b1;
	// }}}
`endif	// HDMI_IN_EDID_ACCESS

	// }}}
endmodule // main.v
