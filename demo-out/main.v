`timescale	1ps / 1ps
////////////////////////////////////////////////////////////////////////////////
//
// Filename:	../demo-out/main.v
//
// Project:	AutoFPGA, a utility for composing FPGA designs from peripherals
// {{{
// Computer Generated: This file is computer generated by AUTOFPGA. DO NOT EDIT.
// DO NOT EDIT THIS FILE!
//
// CmdLine:	./autofpga -d -o ../demo-out -I ../auto-data allclocks.txt bkram.txt buserr.txt clkcheck.txt crossbus.txt ddr3.txt edidslvscope.txt edid.txt exconsole.txt flashcfg.txt flash.txt global.txt gpio.txt gps.txt hdmi.txt i2ccpu.txt i2cdma.txt i2saudio.txt icape.txt meganet.txt mdio.txt pic.txt pwrcount.txt rtcdate.txt rtcgps.txt spio.txt sdio.txt vadj33.txt version.txt wboledbw.txt wbpmic.txt wbuarbiter.txt wbubus.txt zipcpu.txt zipmaster.txt
//
// Creator:	Dan Gisselquist, Ph.D.
//		Gisselquist Technology, LLC
//
////////////////////////////////////////////////////////////////////////////////
// }}}
// Copyright (C) 2017-2024, Gisselquist Technology, LLC
// {{{
// This program is free software (firmware): you can redistribute it and/or
// modify it under the terms of the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License, or (at
// your option) any later version.
//
// This program is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// for more details.
//
// You should have received a copy of the GNU General Public License along
// with this program.  (It's in the $(ROOT)/doc directory.  Run make with no
// target there if the PDF file isn't present.)  If not, see
// <http://www.gnu.org/licenses/> for a copy.
// }}}
// License:	GPL, v3, as defined and found on www.gnu.org,
// {{{
//		http://www.gnu.org/licenses/gpl.html
//
//
////////////////////////////////////////////////////////////////////////////////
//
// }}}
`default_nettype	none
////////////////////////////////////////////////////////////////////////////////
//
// Macro defines
// {{{
//
//
// Here is a list of defines which may be used, post auto-design
// (not post-build), to turn particular peripherals (and bus masters)
// on and off.  In particular, to turn off support for a particular
// design component, just comment out its respective `define below.
//
// These lines are taken from the respective @ACCESS tags for each of our
// components.  If a component doesn't have an @ACCESS tag, it will not
// be listed here.
//
// First, the independent access fields for any bus masters
`define	EXBUS_MASTER
`define	ALLCLOCKS_PRESENT
`define	VADJ_ACCESS
// And then for the independent peripherals
`define	FLASH_ACCESS
`define	I2CCPU_ACCESS
`define	EDID_ACCESS
`define	GPSUART_ACCESS
`define	VIDPIPE_ACCESS
`define	EDIDSLVSCOPE_SCOPC
`define	CFG_ACCESS
`define	BKRAM_ACCESS
`define	SDRAM_ACCESS
`define	DDR3_PHY_ACCESS
`define	I2CDMA_ACCESS
`define	PWRCOUNT_ACCESS
`define	MEGANET_ACCESS
`define	RTC_ACCESS
`define	SPIO_ACCESS
`define	GPIO_ACCESS
`define	SDIO_ACCESS
`define	BUSPIC_ACCESS
`define	GPSTRK_ACCESS
`define	NETCTRL_ACCESS
`define	VERSION_ACCESS
`define	OLEDBW_ACCESS
`define	MICROPHONE_ACCESS
`define	INCLUDE_ZIPCPU
//
//
// The list of those things that have @DEPENDS tags
//
//
//
// Dependencies
// Any core with both an @ACCESS and a @DEPENDS tag will show up here.
// The @DEPENDS tag will turn into a series of ifdef's, with the @ACCESS
// being defined only if all of the ifdef's are true//
// Deplist for @$(PREFIX)=rtcdate
`ifdef	RTC_ACCESS
`define	RTCDATE_ACCESS
`endif	// RTC_ACCESS
// Deplist for @$(PREFIX)=flashcfg
`ifdef	FLASH_ACCESS
`define	FLASHCFG_ACCESS
`endif	// FLASH_ACCESS
// Deplist for @$(PREFIX)=txclk
`ifdef	ALLCLOCKS_PRESENT
`define	TXCLK
`endif	// ALLCLOCKS_PRESENT
// Deplist for @$(PREFIX)=adcclk
`ifdef	ALLCLOCKS_PRESENT
`define	ADCCLK
`endif	// ALLCLOCKS_PRESENT
// Deplist for @$(PREFIX)=i2saudio
// Deplist for @$(PREFIX)=rxeth0ck
`ifdef	MEGANET_ACCESS
`define	RXETH0CK
`endif	// MEGANET_ACCESS
// Deplist for @$(PREFIX)=i2saudio
//
// The following macros have unmet dependencies.  They are listed
// here for reference, but their dependencies cannot be met.
// Unmet Dependency list for @$(PREFIX)=i2saudio
`ifdef	ARBITRARY_CLOCK_GENERATOR_ACCESS // This value is unknown
`define	I2SAUDIO
`endif

//
// End of dependency list
//
//
// }}}
////////////////////////////////////////////////////////////////////////////////
//
// Any include files
// {{{
// These are drawn from anything with a MAIN.INCLUDE definition.
`include "builddate.v"
// }}}
//
// Finally, we define our main module itself.  We start with the list of
// I/O ports, or wires, passed into (or out of) the main function.
//
// These fields are copied verbatim from the respective I/O port lists,
// from the fields given by @MAIN.PORTLIST
//
module	main(i_clk, i_reset,
	// {{{
		// The Universal QSPI Flash
		o_flash_cs_n, o_flash_sck, o_flash_dat, i_flash_dat, o_flash_mod,
			i_i2c_sda, i_i2c_scl,
			o_i2c_sda, o_i2c_scl,
		// UART/host to wishbone interface
		i_wbu_uart_rx, o_wbu_uart_tx,
			i_edid_sda, i_edid_scl,
			o_edid_sda, o_edid_scl,
		// The GPS-UART
		i_gpsu_rx, o_gpsu_tx,
		// HDMI control ports
`ifndef	VERILATOR
		i_hdmiclk,
`endif
		i_pixclk,
		i_hdmi_red, i_hdmi_grn, i_hdmi_blu,
		o_hdmi_red, o_hdmi_grn, o_hdmi_blu,
		o_hdmi_iodelay, i_hdmi_iodelay,
		o_pix_reset_n, i_pxpll_locked, o_hdmirx_reset_n,
		o_pxclk_cksel,
		// EDID RX definitions
		i_edidslv_scl, i_edidslv_sda,
		o_edidslv_scl, o_edidslv_sda,
		// DDR3 Controller Interface
		i_ddr3_iserdes_data, i_ddr3_iserdes_dqs,
		i_ddr3_iserdes_bitslip_reference,
		i_ddr3_idelayctrl_rdy,
		o_ddr3_cmd,
		o_ddr3_dqs_tri_control, o_ddr3_dq_tri_control,
		o_ddr3_toggle_dqs, o_ddr3_data, o_ddr3_dm,
		o_ddr3_odelay_data_cntvaluein, o_ddr3_odelay_dqs_cntvaluein,
		o_ddr3_idelay_data_cntvaluein, o_ddr3_idelay_dqs_cntvaluein,
		o_ddr3_odelay_data_ld, o_ddr3_odelay_dqs_ld,
		o_ddr3_idelay_data_ld, o_ddr3_idelay_dqs_ld,
		o_ddr3_bitslip,
		o_ddr3_leveling_calib,
		o_ddr3_reset,
		o_i2s_lrclk, o_i2s_bclk, o_i2s_mclk, o_i2s_dac, i_i2s_adc,
		o_pxclk_cyc, o_pxclk_stb, o_pxclk_we,
		o_pxclk_addr, o_pxclk_data, o_pxclk_sel,
		i_pxclk_stall, i_pxclk_ack, i_pxclk_idata,
                // Ethernet control (packets) lines
                o_net_reset_n,
                // eth_int_b    // Interrupt, leave floating
                // eth_pme_b    // Power management event, leave floating
                i_net_rx_clk, i_net_rx_dv, i_net_rx_err, i_net_rxd,
                o_net_tx_clk, o_net_tx_ctl, o_net_txd,
		// SPIO interface
		i_sw, i_btnc, i_btnd, i_btnl, i_btnr, i_btnu, o_led,
		// GPIO ports
`ifdef	VERILATOR
		o_trace, o_halt,
`endif
		i_gpio, o_gpio,
		// SDIO SD Card
		i_sdio_detect,
		//
		o_sdio_cfg_ddr,
		o_sdio_cfg_ds,
		o_sdio_cfg_dscmd,
		o_sdio_cfg_sample_shift,
		o_sdio_cmd_tristate,
		o_sdio_data_tristate,
		//
		o_sdio_sdclk,
		o_sdio_cmd_en,
		o_sdio_cmd_data,
		o_sdio_data_en,
		o_sdio_rx_en,
		o_sdio_tx_data,
		//
		i_sdio_cmd_strb,
		i_sdio_cmd_data,
		i_sdio_cmd_collision,
		i_sdio_crcack,
		i_sdio_crcnak,
		i_sdio_card_busy,
		i_sdio_rx_strb,
		i_sdio_rx_data,
		//
		i_sdio_ac_valid,
		i_sdio_ac_data,
		i_sdio_ad_valid,
		i_sdio_ad_data,
		o_sdio_hwreset_n, o_sdio_1p8v,
		i_sdio_debug,
		// Extra clocks
		i_clk_125mhz,
		// The GPS 1PPS signal port
		i_gps_pps,
		// The ethernet MDIO wires
		o_mdclk, o_mdio, o_mdwe, i_mdio,
		// OLED control interface (roughly SPI)
		o_oled_sck, o_oled_mosi, o_oled_dcn,
		// The PMic3 microphone wires
		o_mic_csn, o_mic_sck, i_mic_din,
		// Veri1ator only interface
		cpu_sim_cyc,
		cpu_sim_stb,
		cpu_sim_we,
		cpu_sim_addr,
		cpu_sim_data,
		cpu_sim_stall,
		cpu_sim_ack,
		cpu_sim_idata,
`ifdef	VERILATOR
		cpu_prof_stb,
		cpu_prof_addr,
		cpu_prof_ticks,
`endif
		i_cpu_reset
	// }}}
	);
////////////////////////////////////////////////////////////////////////////////
//
// Any parameter definitions
// {{{
// These are drawn from anything with a MAIN.PARAM definition.
// As they aren't connected to the toplevel at all, it would
// be best to use localparam over parameter, but here we don't
// check
	////////////////////////////////////////////////////////////////////////
	//
	// EXBUS parameters
	// {{{
	// Baudrate :   1000000
	// Clock    : 100000000
	localparam [23:0] BUSUART = 24'h64;	//   1000000 baud
	localparam	DBGBUSBITS = $clog2(BUSUART);
	// }}}
	localparam	ICAPE_LGDIV=3;
	localparam real SDRAMCONTROLLER_CLK_PERIOD = 10_000,  //ps, clock period of the controller interface
		DDR3_CLK_PERIOD = 2_500; //ps, clock period of the DDR3 RAM device (must be 1/4 of the CONTROLLER_CLK_PERIOD) 
	localparam SDRAMROW_BITS = 14,  // width of row address
		SDRAMCOL_BITS = 10,  // width of column address
		SDRAMBA_BITS  =  3,  // width of bank address
		SDRAMDQ_BITS  =  8,  // Size of one octet
		SDRAMBYTE_LANES = 2, //8 lanes of DQ
		SDRAMAUX_WIDTH = 4, //width of aux line (must be >= 4) 
		SDRAMSERDES_RATIO = $rtoi(SDRAMCONTROLLER_CLK_PERIOD/DDR3_CLK_PERIOD),
		//4 is the width of a single ddr3 command {cs_n, ras_n, cas_n, we_n} plus 3 (ck_en, odt, reset_n) plus bank bits plus row bits
		SDRAMCMD_LEN = 4 + 3 + SDRAMBA_BITS + SDRAMROW_BITS;


	parameter	[15:0]	UDP_DBGPORT  = 6784;

	localparam	[47:0]	DEF_HWMAC  = 48'h82_33_48_02_e1_c8;
	localparam	[31:0]	DEF_IPADDR = { 8'd192, 8'd168, 8'd15, 8'd29 };
	localparam [31:0] GPSCLOCK_DEFAULT_STEP = 32'haabcc771;
	////////////////////////////////////////////////////////////////////////
	//
	// Variables/definitions/parameters used by the ZipCPU bus master
	// {{{
	//
	// A 32-bit address indicating where the ZipCPU should start running
	// from
`ifdef	BKROM_ACCESS
	localparam	RESET_ADDRESS = @$(/bkrom.BASE);
`else
`ifdef	FLASH_ACCESS
	localparam	RESET_ADDRESS = 23068672;
`else
	localparam	RESET_ADDRESS = 268435456;
`endif	// FLASH_ACCESS
`endif	// BKROM_ACCESS
	//
	// The number of valid bits on the bus
	localparam	ZIP_ADDRESS_WIDTH = 27; // Zip-CPU address width
	//
	// Number of ZipCPU interrupts
	localparam	ZIP_INTS = 16;
	//
	// ZIP_START_HALTED
	//
	// A boolean, indicating whether or not the ZipCPU be halted on startup?
`ifdef	BKROM_ACCESS
	localparam	ZIP_START_HALTED=1'b0;
`else
	localparam	ZIP_START_HALTED=1'b1;
`endif
	// }}}
// }}}
////////////////////////////////////////////////////////////////////////////////
//
// Port declarations
// {{{
// The next step is to declare all of the various ports that were just
// listed above.
//
// The following declarations are taken from the values of the various
// @MAIN.IODECL keys.
//
	input	wire		i_clk;
	// verilator lint_off UNUSED
	input	wire		i_reset;
	// verilator lint_on UNUSED
	// The Universal QSPI flash
	output	wire		o_flash_cs_n, o_flash_sck;
	output	wire	[3:0]	o_flash_dat;
	input	wire	[3:0]	i_flash_dat;
	output	wire	[1:0]	o_flash_mod;
	// I2C Port declarations
	// {{{
	input	wire	i_i2c_sda, i_i2c_scl;
	output	wire	o_i2c_sda, o_i2c_scl;
	// }}}
	input	wire		i_wbu_uart_rx;
	output	wire		o_wbu_uart_tx;
	// I2C Port declarations
	// {{{
	input	wire	i_edid_sda, i_edid_scl;
	output	wire	o_edid_sda, o_edid_scl;
	// }}}
	input	wire		i_gpsu_rx;
	output	wire		o_gpsu_tx;
	// hdmi declarations
	// {{{
`ifndef	VERILATOR
	input	wire		i_hdmiclk;
`endif
	input	wire		i_pixclk;
	input	wire	[9:0]	i_hdmi_red, i_hdmi_grn, i_hdmi_blu;
	output	wire	[9:0]	o_hdmi_red, o_hdmi_grn, o_hdmi_blu;
	output	wire	[14:0]	o_hdmi_iodelay;
	input	wire	[14:0]	i_hdmi_iodelay;
	output	wire		o_pix_reset_n, o_hdmirx_reset_n;
	input	wire		i_pxpll_locked;
	output	wire	[1:0]	o_pxclk_cksel;
	// }}}
	// EDID RX definitions
	input	wire	i_edidslv_scl, i_edidslv_sda;
	output	wire	o_edidslv_scl, o_edidslv_sda;
	// DDR3 Controller I/O declarations
	// {{{
	input	wire	[SDRAMDQ_BITS*SDRAMBYTE_LANES*8-1:0] i_ddr3_iserdes_data;
	input wire    [SDRAMBYTE_LANES*8-1:0] i_ddr3_iserdes_dqs;
	input wire    [SDRAMBYTE_LANES*8-1:0] i_ddr3_iserdes_bitslip_reference;
	input wire    i_ddr3_idelayctrl_rdy;
	output wire    [SDRAMCMD_LEN*SDRAMSERDES_RATIO-1:0] o_ddr3_cmd;
	output wire    o_ddr3_dqs_tri_control, o_ddr3_dq_tri_control;
	output wire    o_ddr3_toggle_dqs;
	output wire    [SDRAMDQ_BITS*SDRAMBYTE_LANES*8-1:0] o_ddr3_data;
	output wire    [(SDRAMDQ_BITS*SDRAMBYTE_LANES*8)/8-1:0] o_ddr3_dm;
	output wire    [4:0] o_ddr3_odelay_data_cntvaluein, o_ddr3_odelay_dqs_cntvaluein;
	output wire    [4:0] o_ddr3_idelay_data_cntvaluein, o_ddr3_idelay_dqs_cntvaluein;
	output wire    [SDRAMBYTE_LANES-1:0] o_ddr3_odelay_data_ld, o_ddr3_odelay_dqs_ld;
	output wire    [SDRAMBYTE_LANES-1:0] o_ddr3_idelay_data_ld, o_ddr3_idelay_dqs_ld;
	output wire    [SDRAMBYTE_LANES-1:0] o_ddr3_bitslip;
	output wire    o_ddr3_leveling_calib;
	output wire    o_ddr3_reset;
	// }}}
	output	wire	o_i2s_lrclk, o_i2s_bclk, o_i2s_mclk, o_i2s_dac;
	input	wire	i_i2s_adc;
	output	wire	o_pxclk_cyc, o_pxclk_stb, o_pxclk_we;
	output	wire	[6:0]	o_pxclk_addr;
	output	wire	[31:0]	o_pxclk_data;
	output	wire	[3:0]	o_pxclk_sel;
	input	wire		i_pxclk_stall, i_pxclk_ack;
	input	wire	[31:0]	i_pxclk_idata;
        // Ethernet (RGMII) control
	// {{{
	// Verilator lint_off SYNCASYNCNET
        output  wire            o_net_reset_n;
	// Verilator lint_on  SYNCASYNCNET
        input   wire            i_net_rx_clk, i_net_rx_dv, i_net_rx_err;
        input   wire    [7:0]   i_net_rxd;
        output  wire    [1:0]   o_net_tx_clk;
        output  wire            o_net_tx_ctl;
        output  wire    [7:0]   o_net_txd;
	// }}}
	// SPIO interface
	input	wire	[8-1:0]	i_sw;
	input	wire		i_btnc, i_btnd, i_btnl, i_btnr, i_btnu;
	output	wire	[8-1:0]	o_led;
	localparam	NGPI = 8, NGPO=10;
	// GPIO ports
`ifdef	VERILATOR
	output	wire			o_trace;
	output	wire			o_halt;
`endif
	input		[(NGPI-1):0]	i_gpio;
	output	wire	[(NGPO-1):0]	o_gpio;
	// SDIO SD Card declarations
	// {{{
	input	wire		i_sdio_detect;
		//
	output	wire		o_sdio_cfg_ddr;
	output	wire		o_sdio_cfg_ds;
	output	wire		o_sdio_cfg_dscmd;
	output	wire	[4:0]	o_sdio_cfg_sample_shift;
	output	wire		o_sdio_cmd_tristate;
	output	wire		o_sdio_data_tristate;
		//
	output	wire	[7:0]	o_sdio_sdclk;
	output	wire		o_sdio_cmd_en;
	output	wire	[1:0]	o_sdio_cmd_data;
	output	wire		o_sdio_data_en;
	output	wire		o_sdio_rx_en;
	output	wire	[31:0]	o_sdio_tx_data;
		//
	input	wire	[1:0]	i_sdio_cmd_strb;
	input	wire	[1:0]	i_sdio_cmd_data;
	input	wire		i_sdio_cmd_collision;
	input	wire		i_sdio_crcack;
	input	wire		i_sdio_crcnak;
	input	wire		i_sdio_card_busy;
	input	wire	[1:0]	i_sdio_rx_strb;
	input	wire	[15:0]	i_sdio_rx_data;
		//
	input	wire		i_sdio_ac_valid;
	input	wire	[1:0]	i_sdio_ac_data;
	input	wire		i_sdio_ad_valid;
	input	wire	[31:0]	i_sdio_ad_data;
	output	wire		o_sdio_hwreset_n,
				o_sdio_1p8v;
	// Verilator lint_off UNUSED
	input	wire	[31:0]	i_sdio_debug;
	// Verilator lint_on  UNUSED
	// }}}
	// Extra clocks
	// Verilator lint_off UNUSED
	input	wire		i_clk_125mhz;
	// Verilator lint_on  UNUSED
	//The GPS Clock
	input	wire		i_gps_pps;
	// Ethernet control (MDIO)
	output	wire		o_mdclk, o_mdio, o_mdwe;
	input	wire		i_mdio;
	// OLEDBW interface
	output	wire		o_oled_sck, o_oled_mosi, o_oled_dcn;
	output	wire		o_mic_csn, o_mic_sck;
	input	wire		i_mic_din;
	input	wire		cpu_sim_cyc, cpu_sim_stb;
	input	wire		cpu_sim_we;
	input	wire	[6:0]	cpu_sim_addr;
	input	wire	[31:0]	cpu_sim_data;
	//
	output	wire		cpu_sim_stall, cpu_sim_ack;
	output	wire	[31:0]	cpu_sim_idata;
	//
`ifdef	VERILATOR
	output	wire		cpu_prof_stb;
	output	wire	[27+$clog2(128/8)-1:0]	cpu_prof_addr;
	output	wire [31:0]	cpu_prof_ticks;
`endif
	input	wire		i_cpu_reset;
// }}}
	// Make Verilator happy
	// {{{
	// Defining bus wires for lots of components often ends up with unused
	// wires lying around.  We'll turn off Ver1lator's lint warning
	// here that checks for unused wires.
	// }}}
	// verilator lint_off UNUSED
	////////////////////////////////////////////////////////////////////////
	//
	// Declaring interrupt lines
	// {{{
	// These declarations come from the various components values
	// given under the @INT.<interrupt name>.WIRE key.
	//
	wire	i2c_int;	// i2c.INT.I2C.WIRE
	wire	edid_int;	// edid.INT.EDID.WIRE
	wire	gpsurxf_int;	// gpsu.INT.GPSRXF.WIRE
	wire	gpsutxf_int;	// gpsu.INT.GPSTXF.WIRE
	wire	gpsutx_int;	// gpsu.INT.GPSTX.WIRE
	wire	gpsurx_int;	// gpsu.INT.GPSRX.WIRE
	wire	hdmi_int;	// hdmi.INT.VIDFRAME.WIRE
	wire	edidslvscope_int;	// edidslvscope.INT.EDIDSLVSCOPE.WIRE
	wire	rtc_int;	// rtc.INT.RTC.WIRE
	wire	spio_int;	// spio.INT.SPIO.WIRE
	wire	gpio_int;	// gpio.INT.GPIO.WIRE
	wire	sdio_int;	// sdio.INT.SDCARD.WIRE
	wire	w_bus_int;	// buspic.INT.BUS.WIRE
	wire	gck_pps;	// gck.INT.PPS.WIRE
	wire	oled_int;	// oled.INT.OLED.WIRE
	wire	pmic_int;	// pmic.INT.MIC.WIRE
	wire	zip_cpu_int;	// zip.INT.ZIP.WIRE
	// }}}
	////////////////////////////////////////////////////////////////////////
	//
	// Component declarations
	// {{{
	// These declarations come from the @MAIN.DEFNS keys found in the
	// various components comprising the design.
	//
	// Definitions for the flash debug port
	// Verilator lint_off UNUSED
	wire		flash_dbg_trigger;
	wire	[31:0]	flash_debug;
	// Verilator lint_on  UNUSED
	// I2C Controller
	// {{{
	// Verilator lint_off UNUSED
	localparam	I2CCPU_WIDTH=(2 == 0) ? 1 : 2;

	wire		i2c_valid, i2c_ready, i2c_last;
	wire	[7:0]	i2c_data;
	wire	[I2CCPU_WIDTH-1:0]	i2c_id;

	wire	[31:0]	i2c_debug;
	// Verilator lint_on  UNUSED
	// }}}
	reg	[30-1:0]	r_buserr_addr;
`ifndef	GPSTRK_ACCESS
	reg	[31:0]	r_subseconds_data;
`endif
	reg	r_adcclk_ack;
	////////////////////////////////////////////////////////////////////////
	//
	// EXBUS: USB-UART interface declarations
	// {{{
	//
	wire	[7:0]	wbu_rx_data, wbu_tx_data;
	wire		wbu_rx_stb;
	wire		wbu_tx_stb, wbu_tx_busy;

	// Verilator lint_off UNUSED
	wire	[0:0]	ex_reset;
	wire	[1:0]	ex_gpio;
	// Verilator lint_on  UNUSED
	// }}}
	// I2C Controller
	// {{{
	// Verilator lint_off UNUSED
	localparam	EDID_WIDTH=(2 == 0) ? 1 : 2;

	wire		edid_valid, edid_ready, edid_last;
	wire	[7:0]	edid_data;
	wire	[EDID_WIDTH-1:0]	edid_id;

	wire	[31:0]	edid_debug;
	// Verilator lint_on  UNUSED
	// }}}
	wire	w_gpsu_cts_n, w_gpsu_rts_n;
	assign	w_gpsu_cts_n=1'b1;
	// Verilator lint_off UNUSED
`ifdef	VERILATOR
	wire		i_hdmiclk;
`endif
	wire		hdmidbg_ce, hdmidbg_trigger;
	wire	[31:0]	hdmiclr_debug;
	// Verilator lint_on  UNUSED
	// Verilator lint_off UNUSED
	wire	[31:0]	edidslv_dbg;
	// Verilator lint_on  UNUSED
	reg	r_txclk_ack;
	reg	r_rxeth0ck_ack;
	// Verilator lint_off UNUSED
	reg		rtc_pps;
	reg	[26:0]	rtc_pps_counter;
	// Verilator lint_on  UNUSED
	// Verilator lint_off UNUSED
	wire	[SDRAMAUX_WIDTH-1:0]	ddr3_aux_out;
	wire	[31:0]	ddr3_debug;
	// Verilator lint_on  UNUSED
	wire	i2cdma_ready;
	reg	[31:0]	r_pwrcount_data;
	////////////////////////////////////////////////////////////////////////
	//
	// I2S Audio signal definitions
	// {{{
	wire		w_i2saudio_en;
	// Verilator lint_off UNUSED
	//
	// These wires may or may not be connected to anything ...
	wire		w_audio_out_valid, w_audio_out_ready, w_audio_out_last;
	wire	[23:0]	w_audio_out_data;
	//
	// w_audio_in... comes from the microphone (if present)
	wire		w_audio_in_valid, w_audio_in_ready,
			w_audio_in_last;
	wire	[23:0]	w_audio_in_data;

	wire	[31:0]	w_i2saudio_debug;
	// Verilator lint_on  UNUSED
	// }}}
	wire	tb_pps;
        // Ethernet (RGMII) control
	// {{{
	// Verilator lint_off UNUSED
	wire	[47:0]	net_hwmac, net_last_ping_hwmac;
	wire	[31:0]	net_ip_addr, net_last_ping_ipaddr;

	wire		netcpurx_valid, netcpurx_ready;
	wire	[31:0]	netcpurx_data;
	wire	[1:0]	netcpurx_bytes;
	wire		netcpurx_last, netcpurx_abort;

	wire		netcputx_valid, netcputx_ready,
			netcputx_last, netcputx_abort;
	wire	[31:0]	netcputx_data;
	wire	[1:0]	netcputx_bytes;

	wire		net_dbg_valid, net_dbg_ready,
			net_dbg_last;
	wire	[31:0]	net_dbg_data;
	wire	[1:0]	net_dbg_bytes;

	wire		net_high_speed;

	wire		net_debug_clk;
	wire	[31:0]	net_debug;
	wire		ign_rxpkt_net_ready;

	// Verilator lint_on  UNUSED
	// }}}
	// Definitions in support of the GPS driven RTC
	// This clock step is designed to match 100000000 Hz
	localparam	[31:0]	RTC_CLKSTEP = 32'h002af31d;
	wire	rtc_ppd;
	wire	rtc_pps;
	wire	[5-1:0]	w_btn;
	wire	[8-1:0]	w_led;
	wire	sd_reset;
	// SDIO SD Card definitions
	// Verilator lint_off UNUSED
	wire	[31:0]	w_sdio_sdwb_debug;
	wire		s_sdio_ready,
			m_sdio_valid, m_sdio_last;
	reg	[31:0]	sdio_debug;
	wire	[31:0]	m_sdio_data;
	// assign		sdio_debug = i_sdio_debug;
	// Verilator lint_on  UNUSED
	wire	i_net_tx_clk;
	wire		ck_pps;
	wire		gps_pps, gps_led, gps_locked, gps_tracking;
	wire	[63:0]	gps_now, gps_err, gps_step;
	wire	[1:0]	gps_dbg_tick;
	// Verilator lint_off UNUSED
	wire[31:0]	mdio_debug;
	// Verilator lint_on  UNUSED
// BUILDTIME doesnt need to include builddate.v a second time
// `include "builddate.v"
	// OLEDBW
	// {{{
	// Verilator lint_off UNUSED
	wire	[1:0]	w_oled_csn;
	wire		ign_oled_valid, ign_oled_last,
			ign_oled_id;
	wire	[7:0]	ign_oled_data;
	wire	[31:0]	oled_debug;
	// Verilator lint_on  UNUSED
	// }}}
	////////////////////////////////////////////////////////////////////////
	//
	// ZipSystem/ZipCPU connection definitions
	// {{{
`ifndef	VERILATOR
	wire		cpu_prof_stb;
	wire	[27+$clog2(128/8)-1:0]	cpu_prof_addr;
	wire [31:0]	cpu_prof_ticks;
`endif
	// All we define here is a set of scope wires
	// Verilator lint_off UNUSED
	wire		raw_cpu_dbg_stall, raw_cpu_dbg_ack;
	wire	[31:0]	zip_debug;
	wire		zip_trigger;
	// Verilator lint_on  UNUSED
	wire	[ZIP_INTS-1:0] zip_int_vector;
	// }}}

// }}}
	////////////////////////////////////////////////////////////////////////
	//
	// Declaring interrupt vector wires
	// {{{
	// These declarations come from the various components having
	// PIC and PIC.MAX keys.
	//
	wire	[14:0]	sys_int_vector;
	wire	[14:0]	alt_int_vector;
	wire	[14:0]	bus_int_vector;
	// }}}
	////////////////////////////////////////////////////////////////////////
	//
	// Declare bus signals
	// {{{
	////////////////////////////////////////////////////////////////////////

	// Bus wbwide
	// {{{
	// Wishbone definitions for bus wbwide, component i2c
	// Verilator lint_off UNUSED
	wire		wbwide_i2cm_cyc, wbwide_i2cm_stb, wbwide_i2cm_we;
	wire	[26:0]	wbwide_i2cm_addr;
	wire	[127:0]	wbwide_i2cm_data;
	wire	[15:0]	wbwide_i2cm_sel;
	wire		wbwide_i2cm_stall, wbwide_i2cm_ack, wbwide_i2cm_err;
	wire	[127:0]	wbwide_i2cm_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wbwide, component edid
	// Verilator lint_off UNUSED
	wire		wbwide_edidm_cyc, wbwide_edidm_stb, wbwide_edidm_we;
	wire	[26:0]	wbwide_edidm_addr;
	wire	[127:0]	wbwide_edidm_data;
	wire	[15:0]	wbwide_edidm_sel;
	wire		wbwide_edidm_stall, wbwide_edidm_ack, wbwide_edidm_err;
	wire	[127:0]	wbwide_edidm_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wbwide, component hdmi
	// Verilator lint_off UNUSED
	wire		wbwide_hdmi_cyc, wbwide_hdmi_stb, wbwide_hdmi_we;
	wire	[26:0]	wbwide_hdmi_addr;
	wire	[127:0]	wbwide_hdmi_data;
	wire	[15:0]	wbwide_hdmi_sel;
	wire		wbwide_hdmi_stall, wbwide_hdmi_ack, wbwide_hdmi_err;
	wire	[127:0]	wbwide_hdmi_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wbwide, component i2cdma
	// Verilator lint_off UNUSED
	wire		wbwide_i2cdma_cyc, wbwide_i2cdma_stb, wbwide_i2cdma_we;
	wire	[26:0]	wbwide_i2cdma_addr;
	wire	[127:0]	wbwide_i2cdma_data;
	wire	[15:0]	wbwide_i2cdma_sel;
	wire		wbwide_i2cdma_stall, wbwide_i2cdma_ack, wbwide_i2cdma_err;
	wire	[127:0]	wbwide_i2cdma_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wbwide, component sdio
	// Verilator lint_off UNUSED
	wire		wbwide_sdio_cyc, wbwide_sdio_stb, wbwide_sdio_we;
	wire	[26:0]	wbwide_sdio_addr;
	wire	[127:0]	wbwide_sdio_data;
	wire	[15:0]	wbwide_sdio_sel;
	wire		wbwide_sdio_stall, wbwide_sdio_ack, wbwide_sdio_err;
	wire	[127:0]	wbwide_sdio_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wbwide, component oled
	// Verilator lint_off UNUSED
	wire		wbwide_oledm_cyc, wbwide_oledm_stb, wbwide_oledm_we;
	wire	[26:0]	wbwide_oledm_addr;
	wire	[127:0]	wbwide_oledm_data;
	wire	[15:0]	wbwide_oledm_sel;
	wire		wbwide_oledm_stall, wbwide_oledm_ack, wbwide_oledm_err;
	wire	[127:0]	wbwide_oledm_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wbwide, component wbu_arbiter
	// Verilator lint_off UNUSED
	wire		wbwide_wbu_arbiter_cyc, wbwide_wbu_arbiter_stb, wbwide_wbu_arbiter_we;
	wire	[26:0]	wbwide_wbu_arbiter_addr;
	wire	[127:0]	wbwide_wbu_arbiter_data;
	wire	[15:0]	wbwide_wbu_arbiter_sel;
	wire		wbwide_wbu_arbiter_stall, wbwide_wbu_arbiter_ack, wbwide_wbu_arbiter_err;
	wire	[127:0]	wbwide_wbu_arbiter_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wbwide, component zip
	// Verilator lint_off UNUSED
	wire		wbwide_zip_cyc, wbwide_zip_stb, wbwide_zip_we;
	wire	[26:0]	wbwide_zip_addr;
	wire	[127:0]	wbwide_zip_data;
	wire	[15:0]	wbwide_zip_sel;
	wire		wbwide_zip_stall, wbwide_zip_ack, wbwide_zip_err;
	wire	[127:0]	wbwide_zip_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wbwide, component crossflash
	// Verilator lint_off UNUSED
	wire		wbwide_crossflash_cyc, wbwide_crossflash_stb, wbwide_crossflash_we;
	wire	[26:0]	wbwide_crossflash_addr;
	wire	[127:0]	wbwide_crossflash_data;
	wire	[15:0]	wbwide_crossflash_sel;
	wire		wbwide_crossflash_stall, wbwide_crossflash_ack, wbwide_crossflash_err;
	wire	[127:0]	wbwide_crossflash_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wbwide, component crossbus
	// Verilator lint_off UNUSED
	wire		wbwide_crossbus_cyc, wbwide_crossbus_stb, wbwide_crossbus_we;
	wire	[26:0]	wbwide_crossbus_addr;
	wire	[127:0]	wbwide_crossbus_data;
	wire	[15:0]	wbwide_crossbus_sel;
	wire		wbwide_crossbus_stall, wbwide_crossbus_ack, wbwide_crossbus_err;
	wire	[127:0]	wbwide_crossbus_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wbwide, component bkram
	// Verilator lint_off UNUSED
	wire		wbwide_bkram_cyc, wbwide_bkram_stb, wbwide_bkram_we;
	wire	[26:0]	wbwide_bkram_addr;
	wire	[127:0]	wbwide_bkram_data;
	wire	[15:0]	wbwide_bkram_sel;
	wire		wbwide_bkram_stall, wbwide_bkram_ack, wbwide_bkram_err;
	wire	[127:0]	wbwide_bkram_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wbwide, component ddr3
	// Verilator lint_off UNUSED
	wire		wbwide_ddr3_cyc, wbwide_ddr3_stb, wbwide_ddr3_we;
	wire	[26:0]	wbwide_ddr3_addr;
	wire	[127:0]	wbwide_ddr3_data;
	wire	[15:0]	wbwide_ddr3_sel;
	wire		wbwide_ddr3_stall, wbwide_ddr3_ack, wbwide_ddr3_err;
	wire	[127:0]	wbwide_ddr3_idata;
	// Verilator lint_on UNUSED
	// }}}
	// Bus wbflash
	// {{{
	// Wishbone definitions for bus wbflash, component crossflash
	// Verilator lint_off UNUSED
	wire		wbflash_crossflash_cyc, wbflash_crossflash_stb, wbflash_crossflash_we;
	wire	[22:0]	wbflash_crossflash_addr;
	wire	[31:0]	wbflash_crossflash_data;
	wire	[3:0]	wbflash_crossflash_sel;
	wire		wbflash_crossflash_stall, wbflash_crossflash_ack, wbflash_crossflash_err;
	wire	[31:0]	wbflash_crossflash_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wbflash, component sdio
	// Verilator lint_off UNUSED
	wire		wbflash_sdio_cyc, wbflash_sdio_stb, wbflash_sdio_we;
	wire	[22:0]	wbflash_sdio_addr;
	wire	[31:0]	wbflash_sdio_data;
	wire	[3:0]	wbflash_sdio_sel;
	wire		wbflash_sdio_stall, wbflash_sdio_ack, wbflash_sdio_err;
	wire	[31:0]	wbflash_sdio_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wbflash, component flash
	// Verilator lint_off UNUSED
	wire		wbflash_flash_cyc, wbflash_flash_stb, wbflash_flash_we;
	wire	[22:0]	wbflash_flash_addr;
	wire	[31:0]	wbflash_flash_data;
	wire	[3:0]	wbflash_flash_sel;
	wire		wbflash_flash_stall, wbflash_flash_ack, wbflash_flash_err;
	wire	[31:0]	wbflash_flash_idata;
	// Verilator lint_on UNUSED
	// }}}
	// Bus wb32
	// {{{
	// Wishbone definitions for bus wb32, component crossbus
	// Verilator lint_off UNUSED
	wire		wb32_crossbus_cyc, wb32_crossbus_stb, wb32_crossbus_we;
	wire	[11:0]	wb32_crossbus_addr;
	wire	[31:0]	wb32_crossbus_data;
	wire	[3:0]	wb32_crossbus_sel;
	wire		wb32_crossbus_stall, wb32_crossbus_ack, wb32_crossbus_err;
	wire	[31:0]	wb32_crossbus_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32(SIO), component adcclk
	// Verilator lint_off UNUSED
	wire		wb32_adcclk_cyc, wb32_adcclk_stb, wb32_adcclk_we;
	wire	[11:0]	wb32_adcclk_addr;
	wire	[31:0]	wb32_adcclk_data;
	wire	[3:0]	wb32_adcclk_sel;
	wire		wb32_adcclk_stall, wb32_adcclk_ack, wb32_adcclk_err;
	wire	[31:0]	wb32_adcclk_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32(SIO), component buildtime
	// Verilator lint_off UNUSED
	wire		wb32_buildtime_cyc, wb32_buildtime_stb, wb32_buildtime_we;
	wire	[11:0]	wb32_buildtime_addr;
	wire	[31:0]	wb32_buildtime_data;
	wire	[3:0]	wb32_buildtime_sel;
	wire		wb32_buildtime_stall, wb32_buildtime_ack, wb32_buildtime_err;
	wire	[31:0]	wb32_buildtime_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32(SIO), component buserr
	// Verilator lint_off UNUSED
	wire		wb32_buserr_cyc, wb32_buserr_stb, wb32_buserr_we;
	wire	[11:0]	wb32_buserr_addr;
	wire	[31:0]	wb32_buserr_data;
	wire	[3:0]	wb32_buserr_sel;
	wire		wb32_buserr_stall, wb32_buserr_ack, wb32_buserr_err;
	wire	[31:0]	wb32_buserr_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32(SIO), component buspic
	// Verilator lint_off UNUSED
	wire		wb32_buspic_cyc, wb32_buspic_stb, wb32_buspic_we;
	wire	[11:0]	wb32_buspic_addr;
	wire	[31:0]	wb32_buspic_data;
	wire	[3:0]	wb32_buspic_sel;
	wire		wb32_buspic_stall, wb32_buspic_ack, wb32_buspic_err;
	wire	[31:0]	wb32_buspic_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32(SIO), component gpio
	// Verilator lint_off UNUSED
	wire		wb32_gpio_cyc, wb32_gpio_stb, wb32_gpio_we;
	wire	[11:0]	wb32_gpio_addr;
	wire	[31:0]	wb32_gpio_data;
	wire	[3:0]	wb32_gpio_sel;
	wire		wb32_gpio_stall, wb32_gpio_ack, wb32_gpio_err;
	wire	[31:0]	wb32_gpio_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32(SIO), component pwrcount
	// Verilator lint_off UNUSED
	wire		wb32_pwrcount_cyc, wb32_pwrcount_stb, wb32_pwrcount_we;
	wire	[11:0]	wb32_pwrcount_addr;
	wire	[31:0]	wb32_pwrcount_data;
	wire	[3:0]	wb32_pwrcount_sel;
	wire		wb32_pwrcount_stall, wb32_pwrcount_ack, wb32_pwrcount_err;
	wire	[31:0]	wb32_pwrcount_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32(SIO), component rtcdate
	// Verilator lint_off UNUSED
	wire		wb32_rtcdate_cyc, wb32_rtcdate_stb, wb32_rtcdate_we;
	wire	[11:0]	wb32_rtcdate_addr;
	wire	[31:0]	wb32_rtcdate_data;
	wire	[3:0]	wb32_rtcdate_sel;
	wire		wb32_rtcdate_stall, wb32_rtcdate_ack, wb32_rtcdate_err;
	wire	[31:0]	wb32_rtcdate_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32(SIO), component rxeth0ck
	// Verilator lint_off UNUSED
	wire		wb32_rxeth0ck_cyc, wb32_rxeth0ck_stb, wb32_rxeth0ck_we;
	wire	[11:0]	wb32_rxeth0ck_addr;
	wire	[31:0]	wb32_rxeth0ck_data;
	wire	[3:0]	wb32_rxeth0ck_sel;
	wire		wb32_rxeth0ck_stall, wb32_rxeth0ck_ack, wb32_rxeth0ck_err;
	wire	[31:0]	wb32_rxeth0ck_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32(SIO), component spio
	// Verilator lint_off UNUSED
	wire		wb32_spio_cyc, wb32_spio_stb, wb32_spio_we;
	wire	[11:0]	wb32_spio_addr;
	wire	[31:0]	wb32_spio_data;
	wire	[3:0]	wb32_spio_sel;
	wire		wb32_spio_stall, wb32_spio_ack, wb32_spio_err;
	wire	[31:0]	wb32_spio_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32(SIO), component subseconds
	// Verilator lint_off UNUSED
	wire		wb32_subseconds_cyc, wb32_subseconds_stb, wb32_subseconds_we;
	wire	[11:0]	wb32_subseconds_addr;
	wire	[31:0]	wb32_subseconds_data;
	wire	[3:0]	wb32_subseconds_sel;
	wire		wb32_subseconds_stall, wb32_subseconds_ack, wb32_subseconds_err;
	wire	[31:0]	wb32_subseconds_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32(SIO), component txclk
	// Verilator lint_off UNUSED
	wire		wb32_txclk_cyc, wb32_txclk_stb, wb32_txclk_we;
	wire	[11:0]	wb32_txclk_addr;
	wire	[31:0]	wb32_txclk_data;
	wire	[3:0]	wb32_txclk_sel;
	wire		wb32_txclk_stall, wb32_txclk_ack, wb32_txclk_err;
	wire	[31:0]	wb32_txclk_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32(SIO), component version
	// Verilator lint_off UNUSED
	wire		wb32_version_cyc, wb32_version_stb, wb32_version_we;
	wire	[11:0]	wb32_version_addr;
	wire	[31:0]	wb32_version_data;
	wire	[3:0]	wb32_version_sel;
	wire		wb32_version_stall, wb32_version_ack, wb32_version_err;
	wire	[31:0]	wb32_version_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32(DIO), component edid
	// Verilator lint_off UNUSED
	wire		wb32_edids_cyc, wb32_edids_stb, wb32_edids_we;
	wire	[11:0]	wb32_edids_addr;
	wire	[31:0]	wb32_edids_data;
	wire	[3:0]	wb32_edids_sel;
	wire		wb32_edids_stall, wb32_edids_ack, wb32_edids_err;
	wire	[31:0]	wb32_edids_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32(DIO), component gck
	// Verilator lint_off UNUSED
	wire		wb32_gck_cyc, wb32_gck_stb, wb32_gck_we;
	wire	[11:0]	wb32_gck_addr;
	wire	[31:0]	wb32_gck_data;
	wire	[3:0]	wb32_gck_sel;
	wire		wb32_gck_stall, wb32_gck_ack, wb32_gck_err;
	wire	[31:0]	wb32_gck_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32(DIO), component i2c
	// Verilator lint_off UNUSED
	wire		wb32_i2cs_cyc, wb32_i2cs_stb, wb32_i2cs_we;
	wire	[11:0]	wb32_i2cs_addr;
	wire	[31:0]	wb32_i2cs_data;
	wire	[3:0]	wb32_i2cs_sel;
	wire		wb32_i2cs_stall, wb32_i2cs_ack, wb32_i2cs_err;
	wire	[31:0]	wb32_i2cs_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32(DIO), component i2cdma
	// Verilator lint_off UNUSED
	wire		wb32_i2cdma_cyc, wb32_i2cdma_stb, wb32_i2cdma_we;
	wire	[11:0]	wb32_i2cdma_addr;
	wire	[31:0]	wb32_i2cdma_data;
	wire	[3:0]	wb32_i2cdma_sel;
	wire		wb32_i2cdma_stall, wb32_i2cdma_ack, wb32_i2cdma_err;
	wire	[31:0]	wb32_i2cdma_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32(DIO), component oled
	// Verilator lint_off UNUSED
	wire		wb32_oled_cyc, wb32_oled_stb, wb32_oled_we;
	wire	[11:0]	wb32_oled_addr;
	wire	[31:0]	wb32_oled_data;
	wire	[3:0]	wb32_oled_sel;
	wire		wb32_oled_stall, wb32_oled_ack, wb32_oled_err;
	wire	[31:0]	wb32_oled_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32(DIO), component rtc
	// Verilator lint_off UNUSED
	wire		wb32_rtc_cyc, wb32_rtc_stb, wb32_rtc_we;
	wire	[11:0]	wb32_rtc_addr;
	wire	[31:0]	wb32_rtc_data;
	wire	[3:0]	wb32_rtc_sel;
	wire		wb32_rtc_stall, wb32_rtc_ack, wb32_rtc_err;
	wire	[31:0]	wb32_rtc_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32(DIO), component gtb
	// Verilator lint_off UNUSED
	wire		wb32_gtb_cyc, wb32_gtb_stb, wb32_gtb_we;
	wire	[11:0]	wb32_gtb_addr;
	wire	[31:0]	wb32_gtb_data;
	wire	[3:0]	wb32_gtb_sel;
	wire		wb32_gtb_stall, wb32_gtb_ack, wb32_gtb_err;
	wire	[31:0]	wb32_gtb_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32(DIO), component wb32_sio
	// Verilator lint_off UNUSED
	wire		wb32_sio_cyc, wb32_sio_stb, wb32_sio_we;
	wire	[11:0]	wb32_sio_addr;
	wire	[31:0]	wb32_sio_data;
	wire	[3:0]	wb32_sio_sel;
	wire		wb32_sio_stall, wb32_sio_ack, wb32_sio_err;
	wire	[31:0]	wb32_sio_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32(DIO), component edidslv
	// Verilator lint_off UNUSED
	wire		wb32_edidslv_cyc, wb32_edidslv_stb, wb32_edidslv_we;
	wire	[11:0]	wb32_edidslv_addr;
	wire	[31:0]	wb32_edidslv_data;
	wire	[3:0]	wb32_edidslv_sel;
	wire		wb32_edidslv_stall, wb32_edidslv_ack, wb32_edidslv_err;
	wire	[31:0]	wb32_edidslv_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32, component flashcfg
	// Verilator lint_off UNUSED
	wire		wb32_flashcfg_cyc, wb32_flashcfg_stb, wb32_flashcfg_we;
	wire	[11:0]	wb32_flashcfg_addr;
	wire	[31:0]	wb32_flashcfg_data;
	wire	[3:0]	wb32_flashcfg_sel;
	wire		wb32_flashcfg_stall, wb32_flashcfg_ack, wb32_flashcfg_err;
	wire	[31:0]	wb32_flashcfg_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32, component edidslvscope
	// Verilator lint_off UNUSED
	wire		wb32_edidslvscope_cyc, wb32_edidslvscope_stb, wb32_edidslvscope_we;
	wire	[11:0]	wb32_edidslvscope_addr;
	wire	[31:0]	wb32_edidslvscope_data;
	wire	[3:0]	wb32_edidslvscope_sel;
	wire		wb32_edidslvscope_stall, wb32_edidslvscope_ack, wb32_edidslvscope_err;
	wire	[31:0]	wb32_edidslvscope_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32, component pmic
	// Verilator lint_off UNUSED
	wire		wb32_pmic_cyc, wb32_pmic_stb, wb32_pmic_we;
	wire	[11:0]	wb32_pmic_addr;
	wire	[31:0]	wb32_pmic_data;
	wire	[3:0]	wb32_pmic_sel;
	wire		wb32_pmic_stall, wb32_pmic_ack, wb32_pmic_err;
	wire	[31:0]	wb32_pmic_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32, component gpsu
	// Verilator lint_off UNUSED
	wire		wb32_gpsu_cyc, wb32_gpsu_stb, wb32_gpsu_we;
	wire	[11:0]	wb32_gpsu_addr;
	wire	[31:0]	wb32_gpsu_data;
	wire	[3:0]	wb32_gpsu_sel;
	wire		wb32_gpsu_stall, wb32_gpsu_ack, wb32_gpsu_err;
	wire	[31:0]	wb32_gpsu_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32, component icape
	// Verilator lint_off UNUSED
	wire		wb32_icape_cyc, wb32_icape_stb, wb32_icape_we;
	wire	[11:0]	wb32_icape_addr;
	wire	[31:0]	wb32_icape_data;
	wire	[3:0]	wb32_icape_sel;
	wire		wb32_icape_stall, wb32_icape_ack, wb32_icape_err;
	wire	[31:0]	wb32_icape_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32, component net
	// Verilator lint_off UNUSED
	wire		wb32_net_cyc, wb32_net_stb, wb32_net_we;
	wire	[11:0]	wb32_net_addr;
	wire	[31:0]	wb32_net_data;
	wire	[3:0]	wb32_net_sel;
	wire		wb32_net_stall, wb32_net_ack, wb32_net_err;
	wire	[31:0]	wb32_net_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32, component ddr3_phy
	// Verilator lint_off UNUSED
	wire		wb32_ddr3_phy_cyc, wb32_ddr3_phy_stb, wb32_ddr3_phy_we;
	wire	[11:0]	wb32_ddr3_phy_addr;
	wire	[31:0]	wb32_ddr3_phy_data;
	wire	[3:0]	wb32_ddr3_phy_sel;
	wire		wb32_ddr3_phy_stall, wb32_ddr3_phy_ack, wb32_ddr3_phy_err;
	wire	[31:0]	wb32_ddr3_phy_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32, component pxclk
	// Verilator lint_off UNUSED
	wire		wb32_pxclk_cyc, wb32_pxclk_stb, wb32_pxclk_we;
	wire	[11:0]	wb32_pxclk_addr;
	wire	[31:0]	wb32_pxclk_data;
	wire	[3:0]	wb32_pxclk_sel;
	wire		wb32_pxclk_stall, wb32_pxclk_ack, wb32_pxclk_err;
	wire	[31:0]	wb32_pxclk_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32, component wb32_dio
	// Verilator lint_off UNUSED
	wire		wb32_dio_cyc, wb32_dio_stb, wb32_dio_we;
	wire	[11:0]	wb32_dio_addr;
	wire	[31:0]	wb32_dio_data;
	wire	[3:0]	wb32_dio_sel;
	wire		wb32_dio_stall, wb32_dio_ack, wb32_dio_err;
	wire	[31:0]	wb32_dio_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32, component hdmi
	// Verilator lint_off UNUSED
	wire		wb32_hdmi_cyc, wb32_hdmi_stb, wb32_hdmi_we;
	wire	[11:0]	wb32_hdmi_addr;
	wire	[31:0]	wb32_hdmi_data;
	wire	[3:0]	wb32_hdmi_sel;
	wire		wb32_hdmi_stall, wb32_hdmi_ack, wb32_hdmi_err;
	wire	[31:0]	wb32_hdmi_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32, component mdio
	// Verilator lint_off UNUSED
	wire		wb32_mdio_cyc, wb32_mdio_stb, wb32_mdio_we;
	wire	[11:0]	wb32_mdio_addr;
	wire	[31:0]	wb32_mdio_data;
	wire	[3:0]	wb32_mdio_sel;
	wire		wb32_mdio_stall, wb32_mdio_ack, wb32_mdio_err;
	wire	[31:0]	wb32_mdio_idata;
	// Verilator lint_on UNUSED
	// }}}
	// Bus wbu
	// {{{
	// Wishbone definitions for bus wbu, component wbu
	// Verilator lint_off UNUSED
	wire		wbu_cyc, wbu_stb, wbu_we;
	wire	[29:0]	wbu_addr;
	wire	[31:0]	wbu_data;
	wire	[3:0]	wbu_sel;
	wire		wbu_stall, wbu_ack, wbu_err;
	wire	[31:0]	wbu_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wbu, component wbu_arbiter
	// Verilator lint_off UNUSED
	wire		wbu_wbu_arbiter_cyc, wbu_wbu_arbiter_stb, wbu_wbu_arbiter_we;
	wire	[29:0]	wbu_wbu_arbiter_addr;
	wire	[31:0]	wbu_wbu_arbiter_data;
	wire	[3:0]	wbu_wbu_arbiter_sel;
	wire		wbu_wbu_arbiter_stall, wbu_wbu_arbiter_ack, wbu_wbu_arbiter_err;
	wire	[31:0]	wbu_wbu_arbiter_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wbu, component zip
	// Verilator lint_off UNUSED
	wire		wbu_zip_cyc, wbu_zip_stb, wbu_zip_we;
	wire	[29:0]	wbu_zip_addr;
	wire	[31:0]	wbu_zip_data;
	wire	[3:0]	wbu_zip_sel;
	wire		wbu_zip_stall, wbu_zip_ack, wbu_zip_err;
	wire	[31:0]	wbu_zip_idata;
	// Verilator lint_on UNUSED
	// }}}
	// }}}
	////////////////////////////////////////////////////////////////////////
	//
	// Peripheral address decoding, bus handling
	// {{{
	//
	// BUS-LOGIC for wbwide
	// {{{
	//
	// No class SINGLE peripherals on the "wbwide" bus
	//

	//
	// No class DOUBLE peripherals on the "wbwide" bus
	//

	// info: @ERROR.WIRE for crossflash matches the buses error name, wbwide_crossflash_err
	// info: @ERROR.WIRE for crossbus matches the buses error name, wbwide_crossbus_err
	assign	wbwide_bkram_err= 1'b0;
	assign	wbwide_ddr3_err= 1'b0;
	//
	// Connect the wbwide bus components together using the wbxbar()
	//
	//
	wbxbar #(
		.NM(8), .NS(4), .AW(27), .DW(128),
		.SLAVE_ADDR({
			// Address width    = 27
			// Address LSBs     = 4
			{ 27'h4000000 }, //       ddr3: 0x40000000
			{ 27'h1000000 }, //      bkram: 0x10000000
			{ 27'h0800000 }, //   crossbus: 0x08000000
			{ 27'h0000000 }  // crossflash: 0x00000000
		}),
		.SLAVE_MASK({
			// Address width    = 27
			// Address LSBs     = 4
			{ 27'h4000000 }, //       ddr3
			{ 27'h7800000 }, //      bkram
			{ 27'h7800000 }, //   crossbus
			{ 27'h7800000 }  // crossflash
		}),
		.OPT_DBLBUFFER(1'b1))
	wbwide_xbar(
		.i_clk(i_clk), .i_reset(i_reset),
		.i_mcyc({
			wbwide_zip_cyc,
			wbwide_wbu_arbiter_cyc,
			wbwide_oledm_cyc,
			wbwide_sdio_cyc,
			wbwide_i2cdma_cyc,
			wbwide_hdmi_cyc,
			wbwide_edidm_cyc,
			wbwide_i2cm_cyc
		}),
		.i_mstb({
			wbwide_zip_stb,
			wbwide_wbu_arbiter_stb,
			wbwide_oledm_stb,
			wbwide_sdio_stb,
			wbwide_i2cdma_stb,
			wbwide_hdmi_stb,
			wbwide_edidm_stb,
			wbwide_i2cm_stb
		}),
		.i_mwe({
			wbwide_zip_we,
			wbwide_wbu_arbiter_we,
			wbwide_oledm_we,
			wbwide_sdio_we,
			wbwide_i2cdma_we,
			wbwide_hdmi_we,
			wbwide_edidm_we,
			wbwide_i2cm_we
		}),
		.i_maddr({
			wbwide_zip_addr,
			wbwide_wbu_arbiter_addr,
			wbwide_oledm_addr,
			wbwide_sdio_addr,
			wbwide_i2cdma_addr,
			wbwide_hdmi_addr,
			wbwide_edidm_addr,
			wbwide_i2cm_addr
		}),
		.i_mdata({
			wbwide_zip_data,
			wbwide_wbu_arbiter_data,
			wbwide_oledm_data,
			wbwide_sdio_data,
			wbwide_i2cdma_data,
			wbwide_hdmi_data,
			wbwide_edidm_data,
			wbwide_i2cm_data
		}),
		.i_msel({
			wbwide_zip_sel,
			wbwide_wbu_arbiter_sel,
			wbwide_oledm_sel,
			wbwide_sdio_sel,
			wbwide_i2cdma_sel,
			wbwide_hdmi_sel,
			wbwide_edidm_sel,
			wbwide_i2cm_sel
		}),
		.o_mstall({
			wbwide_zip_stall,
			wbwide_wbu_arbiter_stall,
			wbwide_oledm_stall,
			wbwide_sdio_stall,
			wbwide_i2cdma_stall,
			wbwide_hdmi_stall,
			wbwide_edidm_stall,
			wbwide_i2cm_stall
		}),
		.o_mack({
			wbwide_zip_ack,
			wbwide_wbu_arbiter_ack,
			wbwide_oledm_ack,
			wbwide_sdio_ack,
			wbwide_i2cdma_ack,
			wbwide_hdmi_ack,
			wbwide_edidm_ack,
			wbwide_i2cm_ack
		}),
		.o_mdata({
			wbwide_zip_idata,
			wbwide_wbu_arbiter_idata,
			wbwide_oledm_idata,
			wbwide_sdio_idata,
			wbwide_i2cdma_idata,
			wbwide_hdmi_idata,
			wbwide_edidm_idata,
			wbwide_i2cm_idata
		}),
		.o_merr({
			wbwide_zip_err,
			wbwide_wbu_arbiter_err,
			wbwide_oledm_err,
			wbwide_sdio_err,
			wbwide_i2cdma_err,
			wbwide_hdmi_err,
			wbwide_edidm_err,
			wbwide_i2cm_err
		}),
		// Slave connections
		.o_scyc({
			wbwide_ddr3_cyc,
			wbwide_bkram_cyc,
			wbwide_crossbus_cyc,
			wbwide_crossflash_cyc
		}),
		.o_sstb({
			wbwide_ddr3_stb,
			wbwide_bkram_stb,
			wbwide_crossbus_stb,
			wbwide_crossflash_stb
		}),
		.o_swe({
			wbwide_ddr3_we,
			wbwide_bkram_we,
			wbwide_crossbus_we,
			wbwide_crossflash_we
		}),
		.o_saddr({
			wbwide_ddr3_addr,
			wbwide_bkram_addr,
			wbwide_crossbus_addr,
			wbwide_crossflash_addr
		}),
		.o_sdata({
			wbwide_ddr3_data,
			wbwide_bkram_data,
			wbwide_crossbus_data,
			wbwide_crossflash_data
		}),
		.o_ssel({
			wbwide_ddr3_sel,
			wbwide_bkram_sel,
			wbwide_crossbus_sel,
			wbwide_crossflash_sel
		}),
		.i_sstall({
			wbwide_ddr3_stall,
			wbwide_bkram_stall,
			wbwide_crossbus_stall,
			wbwide_crossflash_stall
		}),
		.i_sack({
			wbwide_ddr3_ack,
			wbwide_bkram_ack,
			wbwide_crossbus_ack,
			wbwide_crossflash_ack
		}),
		.i_sdata({
			wbwide_ddr3_idata,
			wbwide_bkram_idata,
			wbwide_crossbus_idata,
			wbwide_crossflash_idata
		}),
		.i_serr({
			wbwide_ddr3_err,
			wbwide_bkram_err,
			wbwide_crossbus_err,
			wbwide_crossflash_err
		})
		);

	// End of bus logic for wbwide
	// }}}
	//
	// BUS-LOGIC for wbflash
	// {{{
	//
	// No class SINGLE peripherals on the "wbflash" bus
	//

	//
	// No class DOUBLE peripherals on the "wbflash" bus
	//

	assign	wbflash_sdio_err= 1'b0;
	assign	wbflash_flash_err= 1'b0;
	//
	// Connect the wbflash bus components together using the wbxbar()
	//
	//
	wbxbar #(
		.NM(1), .NS(2), .AW(23), .DW(32),
		.SLAVE_ADDR({
			// Address width    = 23
			// Address LSBs     = 2
			{ 23'h400000 }, // flash: 0x1000000
			{ 23'h200000 }  //  sdio: 0x0800000
		}),
		.SLAVE_MASK({
			// Address width    = 23
			// Address LSBs     = 2
			{ 23'h400000 }, // flash
			{ 23'h600000 }  //  sdio
		}),
		.OPT_DBLBUFFER(1'b1))
	wbflash_xbar(
		.i_clk(i_clk), .i_reset(i_reset),
		.i_mcyc({
			wbflash_crossflash_cyc
		}),
		.i_mstb({
			wbflash_crossflash_stb
		}),
		.i_mwe({
			wbflash_crossflash_we
		}),
		.i_maddr({
			wbflash_crossflash_addr
		}),
		.i_mdata({
			wbflash_crossflash_data
		}),
		.i_msel({
			wbflash_crossflash_sel
		}),
		.o_mstall({
			wbflash_crossflash_stall
		}),
		.o_mack({
			wbflash_crossflash_ack
		}),
		.o_mdata({
			wbflash_crossflash_idata
		}),
		.o_merr({
			wbflash_crossflash_err
		}),
		// Slave connections
		.o_scyc({
			wbflash_flash_cyc,
			wbflash_sdio_cyc
		}),
		.o_sstb({
			wbflash_flash_stb,
			wbflash_sdio_stb
		}),
		.o_swe({
			wbflash_flash_we,
			wbflash_sdio_we
		}),
		.o_saddr({
			wbflash_flash_addr,
			wbflash_sdio_addr
		}),
		.o_sdata({
			wbflash_flash_data,
			wbflash_sdio_data
		}),
		.o_ssel({
			wbflash_flash_sel,
			wbflash_sdio_sel
		}),
		.i_sstall({
			wbflash_flash_stall,
			wbflash_sdio_stall
		}),
		.i_sack({
			wbflash_flash_ack,
			wbflash_sdio_ack
		}),
		.i_sdata({
			wbflash_flash_idata,
			wbflash_sdio_idata
		}),
		.i_serr({
			wbflash_flash_err,
			wbflash_sdio_err
		})
		);

	// End of bus logic for wbflash
	// }}}
	//
	// BUS-LOGIC for wb32
	// {{{
	//
	// wb32 Bus logic to handle SINGLE slaves
	//
	reg		r_wb32_sio_ack;
	reg	[31:0]	r_wb32_sio_data;

	assign	wb32_sio_stall = 1'b0;

	initial r_wb32_sio_ack = 1'b0;
	always	@(posedge i_clk)
		r_wb32_sio_ack <= (wb32_sio_stb);
	assign	wb32_sio_ack = r_wb32_sio_ack;

	always	@(posedge i_clk)
	casez( wb32_sio_addr[3:0] )
	4'h0: r_wb32_sio_data <= wb32_adcclk_idata;
	4'h1: r_wb32_sio_data <= wb32_buildtime_idata;
	4'h2: r_wb32_sio_data <= wb32_buserr_idata;
	4'h3: r_wb32_sio_data <= wb32_buspic_idata;
	4'h4: r_wb32_sio_data <= wb32_gpio_idata;
	4'h5: r_wb32_sio_data <= wb32_pwrcount_idata;
	4'h6: r_wb32_sio_data <= wb32_rtcdate_idata;
	4'h7: r_wb32_sio_data <= wb32_rxeth0ck_idata;
	4'h8: r_wb32_sio_data <= wb32_spio_idata;
	4'h9: r_wb32_sio_data <= wb32_subseconds_idata;
	4'ha: r_wb32_sio_data <= wb32_txclk_idata;
	4'hb: r_wb32_sio_data <= wb32_version_idata;
	default: r_wb32_sio_data <= wb32_version_idata;
	endcase
	assign	wb32_sio_idata = r_wb32_sio_data;


	//
	// Now to translate this logic to the various SIO slaves
	//
	// In this case, the SIO bus has the prefix wb32_sio
	// and all of the slaves have various wires beginning
	// with their own respective bus prefixes.
	// Our goal here is to make certain that all of
	// the slave bus inputs match the SIO bus wires
	assign	wb32_adcclk_cyc = wb32_sio_cyc;
	assign	wb32_adcclk_stb = wb32_sio_stb && (wb32_sio_addr[ 3: 0] ==  4'h0);  // 0x000
	assign	wb32_adcclk_we  = wb32_sio_we;
	assign	wb32_adcclk_data= wb32_sio_data;
	assign	wb32_adcclk_sel = wb32_sio_sel;
	assign	wb32_buildtime_cyc = wb32_sio_cyc;
	assign	wb32_buildtime_stb = wb32_sio_stb && (wb32_sio_addr[ 3: 0] ==  4'h1);  // 0x004
	assign	wb32_buildtime_we  = wb32_sio_we;
	assign	wb32_buildtime_data= wb32_sio_data;
	assign	wb32_buildtime_sel = wb32_sio_sel;
	assign	wb32_buserr_cyc = wb32_sio_cyc;
	assign	wb32_buserr_stb = wb32_sio_stb && (wb32_sio_addr[ 3: 0] ==  4'h2);  // 0x008
	assign	wb32_buserr_we  = wb32_sio_we;
	assign	wb32_buserr_data= wb32_sio_data;
	assign	wb32_buserr_sel = wb32_sio_sel;
	assign	wb32_buspic_cyc = wb32_sio_cyc;
	assign	wb32_buspic_stb = wb32_sio_stb && (wb32_sio_addr[ 3: 0] ==  4'h3);  // 0x00c
	assign	wb32_buspic_we  = wb32_sio_we;
	assign	wb32_buspic_data= wb32_sio_data;
	assign	wb32_buspic_sel = wb32_sio_sel;
	assign	wb32_gpio_cyc = wb32_sio_cyc;
	assign	wb32_gpio_stb = wb32_sio_stb && (wb32_sio_addr[ 3: 0] ==  4'h4);  // 0x010
	assign	wb32_gpio_we  = wb32_sio_we;
	assign	wb32_gpio_data= wb32_sio_data;
	assign	wb32_gpio_sel = wb32_sio_sel;
	assign	wb32_pwrcount_cyc = wb32_sio_cyc;
	assign	wb32_pwrcount_stb = wb32_sio_stb && (wb32_sio_addr[ 3: 0] ==  4'h5);  // 0x014
	assign	wb32_pwrcount_we  = wb32_sio_we;
	assign	wb32_pwrcount_data= wb32_sio_data;
	assign	wb32_pwrcount_sel = wb32_sio_sel;
	assign	wb32_rtcdate_cyc = wb32_sio_cyc;
	assign	wb32_rtcdate_stb = wb32_sio_stb && (wb32_sio_addr[ 3: 0] ==  4'h6);  // 0x018
	assign	wb32_rtcdate_we  = wb32_sio_we;
	assign	wb32_rtcdate_data= wb32_sio_data;
	assign	wb32_rtcdate_sel = wb32_sio_sel;
	assign	wb32_rxeth0ck_cyc = wb32_sio_cyc;
	assign	wb32_rxeth0ck_stb = wb32_sio_stb && (wb32_sio_addr[ 3: 0] ==  4'h7);  // 0x01c
	assign	wb32_rxeth0ck_we  = wb32_sio_we;
	assign	wb32_rxeth0ck_data= wb32_sio_data;
	assign	wb32_rxeth0ck_sel = wb32_sio_sel;
	assign	wb32_spio_cyc = wb32_sio_cyc;
	assign	wb32_spio_stb = wb32_sio_stb && (wb32_sio_addr[ 3: 0] ==  4'h8);  // 0x020
	assign	wb32_spio_we  = wb32_sio_we;
	assign	wb32_spio_data= wb32_sio_data;
	assign	wb32_spio_sel = wb32_sio_sel;
	assign	wb32_subseconds_cyc = wb32_sio_cyc;
	assign	wb32_subseconds_stb = wb32_sio_stb && (wb32_sio_addr[ 3: 0] ==  4'h9);  // 0x024
	assign	wb32_subseconds_we  = wb32_sio_we;
	assign	wb32_subseconds_data= wb32_sio_data;
	assign	wb32_subseconds_sel = wb32_sio_sel;
	assign	wb32_txclk_cyc = wb32_sio_cyc;
	assign	wb32_txclk_stb = wb32_sio_stb && (wb32_sio_addr[ 3: 0] ==  4'ha);  // 0x028
	assign	wb32_txclk_we  = wb32_sio_we;
	assign	wb32_txclk_data= wb32_sio_data;
	assign	wb32_txclk_sel = wb32_sio_sel;
	assign	wb32_version_cyc = wb32_sio_cyc;
	assign	wb32_version_stb = wb32_sio_stb && (wb32_sio_addr[ 3: 0] ==  4'hb);  // 0x02c
	assign	wb32_version_we  = wb32_sio_we;
	assign	wb32_version_data= wb32_sio_data;
	assign	wb32_version_sel = wb32_sio_sel;
	//
	// wb32 Bus logic to handle 9 DOUBLE slaves
	//
	//
	reg	[1:0]	r_wb32_dio_ack;
	// # dlist = 9, nextlg(#dlist) = 4
	reg	[3:0]	r_wb32_dio_bus_select;
	reg	[31:0]	r_wb32_dio_data;

	// DOUBLE peripherals are not allowed to stall.
	assign	wb32_dio_stall = 1'b0;

	// DOUBLE peripherals return their acknowledgments in two
	// clocks--always, allowing us to collect this logic together
	// in a slave independent manner.  Here, the acknowledgment
	// is treated as a two stage shift register, cleared on any
	// reset, or any time the cycle line drops.  (Dropping the
	// cycle line aborts the transaction.)
	initial	r_wb32_dio_ack = 0;
	always	@(posedge i_clk)
	if (i_reset || !wb32_dio_cyc)
		r_wb32_dio_ack <= 0;
	else
		r_wb32_dio_ack <= { r_wb32_dio_ack[0], (wb32_dio_stb) };
	assign	wb32_dio_ack = r_wb32_dio_ack[1];

	// Since it costs us two clocks to go through this
	// logic, we'll take one of those clocks here to set
	// a selection index, and then on the next clock we'll
	// use this index to select from among the vaious
	// possible bus return values
	always @(posedge i_clk)
	casez(wb32_dio_addr[6:2])
	5'b0_0000: r_wb32_dio_bus_select <= 4'd0;
	5'b0_0001: r_wb32_dio_bus_select <= 4'd1;
	5'b0_0010: r_wb32_dio_bus_select <= 4'd2;
	5'b0_0011: r_wb32_dio_bus_select <= 4'd3;
	5'b0_0100: r_wb32_dio_bus_select <= 4'd4;
	5'b0_0101: r_wb32_dio_bus_select <= 4'd5;
	5'b0_011?: r_wb32_dio_bus_select <= 4'd6;
	5'b0_10??: r_wb32_dio_bus_select <= 4'd7;
	5'b1_????: r_wb32_dio_bus_select <= 4'd8;
	default: r_wb32_dio_bus_select <= 0;
	endcase

	always	@(posedge i_clk)
	casez(r_wb32_dio_bus_select)
	4'd0: r_wb32_dio_data <= wb32_edids_idata;
	4'd1: r_wb32_dio_data <= wb32_gck_idata;
	4'd2: r_wb32_dio_data <= wb32_i2cs_idata;
	4'd3: r_wb32_dio_data <= wb32_i2cdma_idata;
	4'd4: r_wb32_dio_data <= wb32_oled_idata;
	4'd5: r_wb32_dio_data <= wb32_rtc_idata;
	4'd6: r_wb32_dio_data <= wb32_gtb_idata;
	4'd7: r_wb32_dio_data <= wb32_sio_idata;
	4'd8: r_wb32_dio_data <= wb32_edidslv_idata;
	default: r_wb32_dio_data <= wb32_edidslv_idata;
	endcase

	assign	wb32_dio_idata = r_wb32_dio_data;

	assign	wb32_edids_cyc = wb32_dio_cyc;
	assign	wb32_edids_stb = wb32_dio_stb && ((wb32_dio_addr[ 6: 2] &  5'h1f) ==  5'h00);  // 0x000 - 0x00f
	assign	wb32_edids_we  = wb32_dio_we;
	assign	wb32_edids_addr= wb32_dio_addr;
	assign	wb32_edids_data= wb32_dio_data;
	assign	wb32_edids_sel = wb32_dio_sel;
	assign	wb32_gck_cyc = wb32_dio_cyc;
	assign	wb32_gck_stb = wb32_dio_stb && ((wb32_dio_addr[ 6: 2] &  5'h1f) ==  5'h01);  // 0x010 - 0x01f
	assign	wb32_gck_we  = wb32_dio_we;
	assign	wb32_gck_addr= wb32_dio_addr;
	assign	wb32_gck_data= wb32_dio_data;
	assign	wb32_gck_sel = wb32_dio_sel;
	assign	wb32_i2cs_cyc = wb32_dio_cyc;
	assign	wb32_i2cs_stb = wb32_dio_stb && ((wb32_dio_addr[ 6: 2] &  5'h1f) ==  5'h02);  // 0x020 - 0x02f
	assign	wb32_i2cs_we  = wb32_dio_we;
	assign	wb32_i2cs_addr= wb32_dio_addr;
	assign	wb32_i2cs_data= wb32_dio_data;
	assign	wb32_i2cs_sel = wb32_dio_sel;
	assign	wb32_i2cdma_cyc = wb32_dio_cyc;
	assign	wb32_i2cdma_stb = wb32_dio_stb && ((wb32_dio_addr[ 6: 2] &  5'h1f) ==  5'h03);  // 0x030 - 0x03f
	assign	wb32_i2cdma_we  = wb32_dio_we;
	assign	wb32_i2cdma_addr= wb32_dio_addr;
	assign	wb32_i2cdma_data= wb32_dio_data;
	assign	wb32_i2cdma_sel = wb32_dio_sel;
	assign	wb32_oled_cyc = wb32_dio_cyc;
	assign	wb32_oled_stb = wb32_dio_stb && ((wb32_dio_addr[ 6: 2] &  5'h1f) ==  5'h04);  // 0x040 - 0x04f
	assign	wb32_oled_we  = wb32_dio_we;
	assign	wb32_oled_addr= wb32_dio_addr;
	assign	wb32_oled_data= wb32_dio_data;
	assign	wb32_oled_sel = wb32_dio_sel;
	assign	wb32_rtc_cyc = wb32_dio_cyc;
	assign	wb32_rtc_stb = wb32_dio_stb && ((wb32_dio_addr[ 6: 2] &  5'h1f) ==  5'h05);  // 0x050 - 0x05f
	assign	wb32_rtc_we  = wb32_dio_we;
	assign	wb32_rtc_addr= wb32_dio_addr;
	assign	wb32_rtc_data= wb32_dio_data;
	assign	wb32_rtc_sel = wb32_dio_sel;
	assign	wb32_gtb_cyc = wb32_dio_cyc;
	assign	wb32_gtb_stb = wb32_dio_stb && ((wb32_dio_addr[ 6: 2] &  5'h1e) ==  5'h06);  // 0x060 - 0x07f
	assign	wb32_gtb_we  = wb32_dio_we;
	assign	wb32_gtb_addr= wb32_dio_addr;
	assign	wb32_gtb_data= wb32_dio_data;
	assign	wb32_gtb_sel = wb32_dio_sel;
	assign	wb32_sio_cyc = wb32_dio_cyc;
	assign	wb32_sio_stb = wb32_dio_stb && ((wb32_dio_addr[ 6: 2] &  5'h1c) ==  5'h08);  // 0x080 - 0x0bf
	assign	wb32_sio_we  = wb32_dio_we;
	assign	wb32_sio_addr= wb32_dio_addr;
	assign	wb32_sio_data= wb32_dio_data;
	assign	wb32_sio_sel = wb32_dio_sel;
	assign	wb32_edidslv_cyc = wb32_dio_cyc;
	assign	wb32_edidslv_stb = wb32_dio_stb && ((wb32_dio_addr[ 6: 2] &  5'h10) ==  5'h10);  // 0x100 - 0x1ff
	assign	wb32_edidslv_we  = wb32_dio_we;
	assign	wb32_edidslv_addr= wb32_dio_addr;
	assign	wb32_edidslv_data= wb32_dio_data;
	assign	wb32_edidslv_sel = wb32_dio_sel;
	assign	wb32_flashcfg_err= 1'b0;
	assign	wb32_edidslvscope_err= 1'b0;
	assign	wb32_pmic_err= 1'b0;
	assign	wb32_gpsu_err= 1'b0;
	assign	wb32_icape_err= 1'b0;
	assign	wb32_net_err= 1'b0;
	assign	wb32_ddr3_phy_err= 1'b0;
	assign	wb32_pxclk_err= 1'b0;
	assign	wb32_dio_err= 1'b0;
	assign	wb32_hdmi_err= 1'b0;
	assign	wb32_mdio_err= 1'b0;
	//
	// Connect the wb32 bus components together using the wbxbar()
	//
	//
	wbxbar #(
		.NM(1), .NS(11), .AW(12), .DW(32),
		.SLAVE_ADDR({
			// Address width    = 12
			// Address LSBs     = 2
			{ 12'hc00 }, //         mdio: 0x3000
			{ 12'h800 }, //         hdmi: 0x2000
			{ 12'h500 }, //     wb32_dio: 0x1400
			{ 12'h480 }, //        pxclk: 0x1200
			{ 12'h400 }, //     ddr3_phy: 0x1000
			{ 12'h380 }, //          net: 0x0e00
			{ 12'h300 }, //        icape: 0x0c00
			{ 12'h280 }, //         gpsu: 0x0a00
			{ 12'h200 }, //         pmic: 0x0800
			{ 12'h180 }, // edidslvscope: 0x0600
			{ 12'h100 }  //     flashcfg: 0x0400
		}),
		.SLAVE_MASK({
			// Address width    = 12
			// Address LSBs     = 2
			{ 12'hc00 }, //         mdio
			{ 12'hc00 }, //         hdmi
			{ 12'hf80 }, //     wb32_dio
			{ 12'hf80 }, //        pxclk
			{ 12'hf80 }, //     ddr3_phy
			{ 12'hf80 }, //          net
			{ 12'hf80 }, //        icape
			{ 12'hf80 }, //         gpsu
			{ 12'hf80 }, //         pmic
			{ 12'hf80 }, // edidslvscope
			{ 12'hf80 }  //     flashcfg
		}),
		.OPT_DBLBUFFER(1'b1))
	wb32_xbar(
		.i_clk(i_clk), .i_reset(i_reset),
		.i_mcyc({
			wb32_crossbus_cyc
		}),
		.i_mstb({
			wb32_crossbus_stb
		}),
		.i_mwe({
			wb32_crossbus_we
		}),
		.i_maddr({
			wb32_crossbus_addr
		}),
		.i_mdata({
			wb32_crossbus_data
		}),
		.i_msel({
			wb32_crossbus_sel
		}),
		.o_mstall({
			wb32_crossbus_stall
		}),
		.o_mack({
			wb32_crossbus_ack
		}),
		.o_mdata({
			wb32_crossbus_idata
		}),
		.o_merr({
			wb32_crossbus_err
		}),
		// Slave connections
		.o_scyc({
			wb32_mdio_cyc,
			wb32_hdmi_cyc,
			wb32_dio_cyc,
			wb32_pxclk_cyc,
			wb32_ddr3_phy_cyc,
			wb32_net_cyc,
			wb32_icape_cyc,
			wb32_gpsu_cyc,
			wb32_pmic_cyc,
			wb32_edidslvscope_cyc,
			wb32_flashcfg_cyc
		}),
		.o_sstb({
			wb32_mdio_stb,
			wb32_hdmi_stb,
			wb32_dio_stb,
			wb32_pxclk_stb,
			wb32_ddr3_phy_stb,
			wb32_net_stb,
			wb32_icape_stb,
			wb32_gpsu_stb,
			wb32_pmic_stb,
			wb32_edidslvscope_stb,
			wb32_flashcfg_stb
		}),
		.o_swe({
			wb32_mdio_we,
			wb32_hdmi_we,
			wb32_dio_we,
			wb32_pxclk_we,
			wb32_ddr3_phy_we,
			wb32_net_we,
			wb32_icape_we,
			wb32_gpsu_we,
			wb32_pmic_we,
			wb32_edidslvscope_we,
			wb32_flashcfg_we
		}),
		.o_saddr({
			wb32_mdio_addr,
			wb32_hdmi_addr,
			wb32_dio_addr,
			wb32_pxclk_addr,
			wb32_ddr3_phy_addr,
			wb32_net_addr,
			wb32_icape_addr,
			wb32_gpsu_addr,
			wb32_pmic_addr,
			wb32_edidslvscope_addr,
			wb32_flashcfg_addr
		}),
		.o_sdata({
			wb32_mdio_data,
			wb32_hdmi_data,
			wb32_dio_data,
			wb32_pxclk_data,
			wb32_ddr3_phy_data,
			wb32_net_data,
			wb32_icape_data,
			wb32_gpsu_data,
			wb32_pmic_data,
			wb32_edidslvscope_data,
			wb32_flashcfg_data
		}),
		.o_ssel({
			wb32_mdio_sel,
			wb32_hdmi_sel,
			wb32_dio_sel,
			wb32_pxclk_sel,
			wb32_ddr3_phy_sel,
			wb32_net_sel,
			wb32_icape_sel,
			wb32_gpsu_sel,
			wb32_pmic_sel,
			wb32_edidslvscope_sel,
			wb32_flashcfg_sel
		}),
		.i_sstall({
			wb32_mdio_stall,
			wb32_hdmi_stall,
			wb32_dio_stall,
			wb32_pxclk_stall,
			wb32_ddr3_phy_stall,
			wb32_net_stall,
			wb32_icape_stall,
			wb32_gpsu_stall,
			wb32_pmic_stall,
			wb32_edidslvscope_stall,
			wb32_flashcfg_stall
		}),
		.i_sack({
			wb32_mdio_ack,
			wb32_hdmi_ack,
			wb32_dio_ack,
			wb32_pxclk_ack,
			wb32_ddr3_phy_ack,
			wb32_net_ack,
			wb32_icape_ack,
			wb32_gpsu_ack,
			wb32_pmic_ack,
			wb32_edidslvscope_ack,
			wb32_flashcfg_ack
		}),
		.i_sdata({
			wb32_mdio_idata,
			wb32_hdmi_idata,
			wb32_dio_idata,
			wb32_pxclk_idata,
			wb32_ddr3_phy_idata,
			wb32_net_idata,
			wb32_icape_idata,
			wb32_gpsu_idata,
			wb32_pmic_idata,
			wb32_edidslvscope_idata,
			wb32_flashcfg_idata
		}),
		.i_serr({
			wb32_mdio_err,
			wb32_hdmi_err,
			wb32_dio_err,
			wb32_pxclk_err,
			wb32_ddr3_phy_err,
			wb32_net_err,
			wb32_icape_err,
			wb32_gpsu_err,
			wb32_pmic_err,
			wb32_edidslvscope_err,
			wb32_flashcfg_err
		})
		);

	// End of bus logic for wb32
	// }}}
	//
	// BUS-LOGIC for wbu
	// {{{
	//
	// No class SINGLE peripherals on the "wbu" bus
	//

	//
	// No class DOUBLE peripherals on the "wbu" bus
	//

	// info: @ERROR.WIRE for wbu_arbiter matches the buses error name, wbu_wbu_arbiter_err
	assign	wbu_zip_err= 1'b0;
	//
	// Connect the wbu bus components together using the wbxbar()
	//
	//
	wbxbar #(
		.NM(1), .NS(2), .AW(30), .DW(32),
		.SLAVE_ADDR({
			// Address width    = 30
			// Address LSBs     = 2
			{ 30'h20000000 }, //         zip: 0x80000000
			{ 30'h00000000 }  // wbu_arbiter: 0x00000000
		}),
		.SLAVE_MASK({
			// Address width    = 30
			// Address LSBs     = 2
			{ 30'h38000000 }, //         zip
			{ 30'h20000000 }  // wbu_arbiter
		}),
		.OPT_DBLBUFFER(1'b1))
	wbu_xbar(
		.i_clk(i_clk), .i_reset(i_reset),
		.i_mcyc({
			wbu_cyc
		}),
		.i_mstb({
			wbu_stb
		}),
		.i_mwe({
			wbu_we
		}),
		.i_maddr({
			wbu_addr
		}),
		.i_mdata({
			wbu_data
		}),
		.i_msel({
			wbu_sel
		}),
		.o_mstall({
			wbu_stall
		}),
		.o_mack({
			wbu_ack
		}),
		.o_mdata({
			wbu_idata
		}),
		.o_merr({
			wbu_err
		}),
		// Slave connections
		.o_scyc({
			wbu_zip_cyc,
			wbu_wbu_arbiter_cyc
		}),
		.o_sstb({
			wbu_zip_stb,
			wbu_wbu_arbiter_stb
		}),
		.o_swe({
			wbu_zip_we,
			wbu_wbu_arbiter_we
		}),
		.o_saddr({
			wbu_zip_addr,
			wbu_wbu_arbiter_addr
		}),
		.o_sdata({
			wbu_zip_data,
			wbu_wbu_arbiter_data
		}),
		.o_ssel({
			wbu_zip_sel,
			wbu_wbu_arbiter_sel
		}),
		.i_sstall({
			wbu_zip_stall,
			wbu_wbu_arbiter_stall
		}),
		.i_sack({
			wbu_zip_ack,
			wbu_wbu_arbiter_ack
		}),
		.i_sdata({
			wbu_zip_idata,
			wbu_wbu_arbiter_idata
		}),
		.i_serr({
			wbu_zip_err,
			wbu_wbu_arbiter_err
		})
		);

	// End of bus logic for wbu
	// }}}
	// }}}
	////////////////////////////////////////////////////////////////////////
	//
	// Declare the interrupt busses
	// {{{
	// Interrupt busses are defined by anything with a @PIC tag.
	// The @PIC.BUS tag defines the name of the wire bus below,
	// while the @PIC.MAX tag determines the size of the bus width.
	//
	// For your peripheral to be assigned to this bus, it must have an
	// @INT.NAME.WIRE= tag to define the wire name of the interrupt line,
	// and an @INT.NAME.PIC= tag matching the @PIC.BUS tag of the bus
	// your interrupt will be assigned to.  If an @INT.NAME.ID tag also
	// exists, then your interrupt will be assigned to the position given
	// by the ID# in that tag.
	//
	assign	sys_int_vector = {
		pmic_int,
		oled_int,
		gck_pps,
		sdio_int,
		gpio_int,
		hdmi_int,
		edid_int,
		i2c_int,
		w_bus_int,
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		1'b0
	};
	assign	alt_int_vector = {
		1'b0,
		rtc_int,
		edidslvscope_int,
		gpsutxf_int,
		gpsurxf_int,
		gpsutx_int,
		gpsurx_int,
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		1'b0
	};
	assign	bus_int_vector = {
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		spio_int
	};
	// }}}
	////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////
	//
	// @MAIN.INSERT and @MAIN.ALT
	// {{{
	////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////
	//
	//
	// Now we turn to defining all of the parts and pieces of what
	// each of the various peripherals does, and what logic it needs.
	//
	// This information comes from the @MAIN.INSERT and @MAIN.ALT tags.
	// If an @ACCESS tag is available, an ifdef is created to handle
	// having the access and not.  If the @ACCESS tag is `defined above
	// then the @MAIN.INSERT code is executed.  If not, the @MAIN.ALT
	// code is exeucted, together with any other cleanup settings that
	// might need to take place--such as returning zeros to the bus,
	// or making sure all of the various interrupt wires are set to
	// zero if the component is not included.
	//
`ifdef	FLASH_ACCESS
	// {{{
	////////////////////////////////////////////////////////////////////////
	//
	// Flash controller
	// {{{
	qflexpress #(
		// {{{
		.LGFLASHSZ(24), .OPT_CLKDIV(1),
		.OPT_ENDIANSWAP(0),
		.NDUMMY(6), .RDDELAY(2),
		.OPT_STARTUP_FILE("spansion.hex"),
`ifdef	FLASHCFG_ACCESS
		.OPT_CFG(1'b1)
`else
		.OPT_CFG(1'b0)
`endif
		// }}}
	) u_flash (
		// {{{
		.i_clk(i_clk),
		.i_reset(i_reset),
		// Primary memory reading inputs
		.i_wb_cyc(wbflash_flash_cyc), .i_wb_stb(wbflash_flash_stb), .i_wb_we(wbflash_flash_we),
			.i_wb_addr(wbflash_flash_addr[22-1:0]),
			.i_wb_data(wbflash_flash_data), // 32 bits wide
			.i_wb_sel(wbflash_flash_sel),  // 32/8 bits wide
		.o_wb_stall(wbflash_flash_stall),.o_wb_ack(wbflash_flash_ack), .o_wb_data(wbflash_flash_idata),
		// Configuration bus ports
		.i_cfg_cyc(wb32_flashcfg_cyc), .i_cfg_stb(wb32_flashcfg_stb), .i_cfg_we(wb32_flashcfg_we),
			.i_cfg_data(wb32_flashcfg_data), // 32 bits wide
			.i_cfg_sel(wb32_flashcfg_sel),  // 32/8 bits wide
		.o_cfg_stall(wb32_flashcfg_stall),.o_cfg_ack(wb32_flashcfg_ack), .o_cfg_data(wb32_flashcfg_idata),
		.o_qspi_sck(o_flash_sck),
		.o_qspi_cs_n(o_flash_cs_n),
		.o_qspi_mod(o_flash_mod),
		.o_qspi_dat(o_flash_dat),
		.i_qspi_dat(i_flash_dat),
		.o_dbg_trigger(flash_dbg_trigger),
		.o_debug(flash_debug)
		// }}}
	);
	// }}}
	// }}}
`else	// FLASH_ACCESS
	// {{{
	assign	o_flash_sck  = 1'b1;
	assign	o_flash_cs_n = 1'b1;
	assign	o_flash_mod  = 2'b01;
	assign	o_flash_dat  = 4'b1111;
	// Verilator lint_off UNUSED
	wire	flash_unused = &{ 1'b0, i_flash_dat };
	// Verilator lint_on UNUSED
	// Null bus slave
	// {{{

	//
	// In the case that there is no wbflash_flash peripheral
	// responding on the wbflash bus
	assign	wbflash_flash_ack   = 1'b0;
	assign	wbflash_flash_err   = (wbflash_flash_stb);
	assign	wbflash_flash_stall = 0;
	assign	wbflash_flash_idata = 0;

	// }}}
	// }}}
`endif	// FLASH_ACCESS

`ifdef	I2CCPU_ACCESS
	// {{{
	////////////////////////////////////////////////////////////////////////
	//
	// The I2C Controller
	// {{{

	wbi2ccpu #(
		.ADDRESS_WIDTH(27),
		.DATA_WIDTH(128),
		.AXIS_ID_WIDTH(2)
	) u_i2c (
		// {{{
		.i_clk(i_clk), .i_reset(i_reset),
		.i_wb_cyc(wb32_i2cs_cyc), .i_wb_stb(wb32_i2cs_stb), .i_wb_we(wb32_i2cs_we),
			.i_wb_addr(wb32_i2cs_addr[2-1:0]),
			.i_wb_data(wb32_i2cs_data), // 32 bits wide
			.i_wb_sel(wb32_i2cs_sel),  // 32/8 bits wide
		.o_wb_stall(wb32_i2cs_stall),.o_wb_ack(wb32_i2cs_ack), .o_wb_data(wb32_i2cs_idata),
		.o_pf_cyc(wbwide_i2cm_cyc), .o_pf_stb(wbwide_i2cm_stb), .o_pf_we(wbwide_i2cm_we),
			.o_pf_addr(wbwide_i2cm_addr[27-1:0]),
			.o_pf_data(wbwide_i2cm_data), // 128 bits wide
			.o_pf_sel(wbwide_i2cm_sel),  // 128/8 bits wide
		.i_pf_stall(wbwide_i2cm_stall), .i_pf_ack(wbwide_i2cm_ack), .i_pf_data(wbwide_i2cm_idata), .i_pf_err(wbwide_i2cm_err),
		.i_i2c_sda(i_i2c_sda), .i_i2c_scl(i_i2c_scl),
		.o_i2c_sda(o_i2c_sda), .o_i2c_scl(o_i2c_scl),
		.M_AXIS_TVALID(i2c_valid), .M_AXIS_TREADY(i2c_ready),
			.M_AXIS_TDATA(i2c_data), .M_AXIS_TLAST(i2c_last),
			.M_AXIS_TID(i2c_id),
		.i_sync_signal(rtc_pps),
		//
		.o_interrupt(i2c_int),
		.o_debug(i2c_debug)
		// }}}
	);

	assign	i2c_ready = (!i2c_valid) || (1'b0
			|| (i2c_id == 0)		// NULL address
			|| (i2c_id == 1)
`ifdef	I2CDMA_ACCESS
			|| (i2c_id == 2 && i2cdma_ready)
`else
			|| (i2c_id == 2)
`endif
			|| (i2c_id > 2));

	// }}}
	// }}}
`else	// I2CCPU_ACCESS
	// {{{
	assign	o_i2c_scl = 1'b1;
	assign	o_i2c_sda = 1'b1;
	// Null bus master
	// {{{
	// }}}
	// Null interrupt definitions
	// {{{
	assign	i2c_int = 1'b0;	// i2c.INT.I2C.WIRE
	// }}}
	// }}}
`endif	// I2CCPU_ACCESS

	always @(posedge i_clk)
	if (wbwide_zip_err)
	begin
		r_buserr_addr <= 0;
		r_buserr_addr[27-1:0] <= wbwide_zip_addr[27-1:0];
	end else if (wbu_err)
	begin
		r_buserr_addr <= 0;
		r_buserr_addr[30-1:0] <= wbu_addr[30-1:0];
	end
	assign	wb32_buserr_stall= 1'b0;
	assign	wb32_buserr_ack  = wb32_buserr_stb;
	assign	wb32_buserr_idata = { {(30-30){1'b0}},
			r_buserr_addr, 2'b00 };
`ifdef	GPSTRK_ACCESS
	assign	wb32_subseconds_idata = gps_now[31:0];
`else
	always @(posedge i_clk)
	if (wb32_subseconds_stb && wb32_subseconds_we)
		r_subseconds_data <= wb32_subseconds_data;
	else
		r_subseconds_data <= r_subseconds_data
			+ { 16'h0, RTC_CLKSTEP[31:16] };

	assign	wb32_subseconds_idata = r_subseconds_data;
`endif
`ifdef	ADCCLK
	// {{{
	clkcounter #(
		.CLOCKFREQ_HZ(0)	// We'll count PPS externally
	) clkadcclkctr(
		.i_sys_clk(i_clk),
		.i_tst_clk(i_clk_200mhz),
		.i_sys_pps(rtc_pps),
		.o_sys_counts(wb32_adcclk_idata)
	);

	initial	r_adcclk_ack = 0;
	always @(posedge i_clk)
		r_adcclk_ack <= !i_reset && wb32_adcclk_stb;
	assign	wb32_adcclk_ack   = r_adcclk_ack;
	assign	wb32_adcclk_stall = 1'b0;
	// }}}
`else	// ADCCLK
	// {{{
	// }}}
`endif	// ADCCLK

`ifdef	EXBUS_MASTER
	// {{{
	////////////////////////////////////////////////////////////////////////
	//
	// EXBUS: USB-UART driven bus master and console
	// {{{
	// The Host USB interface, to be used by the WB-UART bus
	rxuartlite	#(
		// {{{
		.TIMER_BITS(DBGBUSBITS),
		.CLOCKS_PER_BAUD(BUSUART[DBGBUSBITS-1:0])
		// }}}
	) rcv(
		// {{{
		.i_clk(      i_clk),
		.i_uart_rx(i_wbu_uart_rx),
		.o_wr(       wbu_rx_stb),
		.o_data(     wbu_rx_data)
		// }}}
	);

	txuartlite	#(
		// {{{
		.TIMING_BITS(DBGBUSBITS[4:0]),
		.CLOCKS_PER_BAUD(BUSUART[DBGBUSBITS-1:0])
		// }}}
	) txv(
		// {{{
		.i_clk(    i_clk),
		.i_wr(     wbu_tx_stb),
		.i_data(   wbu_tx_data),
		.o_uart_tx(o_wbu_uart_tx),
		.o_busy(   wbu_tx_busy)
		// }}}
	);

`ifndef	BUSPIC_ACCESS
	wire	w_bus_int;
	assign	w_bus_int = 1'b0;
`endif
	// Verilator lint_off UNUSED
	wire	[29:0]	wbu_tmp_addr;
	// Verilator lint_on  UNUSED
	exbuswb #(
		// {{{
		// .LGWATCHDOG(DBGBUSWATCHDOG)
		.ADDRESS_WIDTH(30)
		// }}}
	) u_exbus(
		// {{{
		.i_clk(i_clk), .i_reset(i_reset),
		.o_reset(ex_reset),
		.i_rx_stb(wbu_rx_stb), .i_rx_byte(wbu_rx_data),
		.o_tx_stb(wbu_tx_stb), .o_tx_byte(wbu_tx_data),
			.i_tx_busy(wbu_tx_busy),
		//
		.i_gpio(2'b00), .o_gpio(ex_gpio),
		//
		.i_console_stb(w_console_tx_stb),
			.i_console_byte(w_console_tx_data),
			.o_console_busy(w_console_busy),
		.o_console_stb(w_console_rx_stb),
			.o_console_byte(w_console_rx_data),
		//
		.o_wb_cyc(wbu_cyc), .o_wb_stb(wbu_stb),
			.o_wb_we(wbu_we),
			.o_wb_addr(wbu_addr),
			.o_wb_data(wbu_data),
			.o_wb_sel(wbu_sel),
		.i_wb_stall(wbu_stall),
			.i_wb_ack(wbu_ack),
		.i_wb_data(wbu_idata),
		.i_wb_err(wbu_err),
		.i_interrupt(w_bus_int)
		// }}}
	);
	// }}}
	// }}}
`else	// EXBUS_MASTER
	// {{{
	// Null bus master
	// {{{
	// }}}
	// }}}
`endif	// EXBUS_MASTER

`ifdef	FLASHCFG_ACCESS
	// {{{
	// The Flash control interface is defined by the flash instantiation
	// hence we don't need to do anything to define it here.
	// }}}
`else	// FLASHCFG_ACCESS
	// {{{
	// Null bus slave
	// {{{

	//
	// In the case that there is no wb32_flashcfg peripheral
	// responding on the wb32 bus
	assign	wb32_flashcfg_ack   = 1'b0;
	assign	wb32_flashcfg_err   = (wb32_flashcfg_stb);
	assign	wb32_flashcfg_stall = 0;
	assign	wb32_flashcfg_idata = 0;

	// }}}
	// }}}
`endif	// FLASHCFG_ACCESS

`ifdef	EDID_ACCESS
	// {{{
	////////////////////////////////////////////////////////////////////////
	//
	// The EDID I2C Controller
	// {{{

	wbi2ccpu #(
		.ADDRESS_WIDTH(27),
		.DATA_WIDTH(128),
		.AXIS_ID_WIDTH(2)
	) u_edid (
		// {{{
		.i_clk(i_clk), .i_reset(i_reset),
		.i_wb_cyc(wb32_edids_cyc), .i_wb_stb(wb32_edids_stb), .i_wb_we(wb32_edids_we),
			.i_wb_addr(wb32_edids_addr[2-1:0]),
			.i_wb_data(wb32_edids_data), // 32 bits wide
			.i_wb_sel(wb32_edids_sel),  // 32/8 bits wide
		.o_wb_stall(wb32_edids_stall),.o_wb_ack(wb32_edids_ack), .o_wb_data(wb32_edids_idata),
		.o_pf_cyc(wbwide_edidm_cyc), .o_pf_stb(wbwide_edidm_stb), .o_pf_we(wbwide_edidm_we),
			.o_pf_addr(wbwide_edidm_addr[27-1:0]),
			.o_pf_data(wbwide_edidm_data), // 128 bits wide
			.o_pf_sel(wbwide_edidm_sel),  // 128/8 bits wide
		.i_pf_stall(wbwide_edidm_stall), .i_pf_ack(wbwide_edidm_ack), .i_pf_data(wbwide_edidm_idata), .i_pf_err(wbwide_edidm_err),
		.i_i2c_sda(i_edid_sda), .i_i2c_scl(i_edid_scl),
		.o_i2c_sda(o_edid_sda), .o_i2c_scl(o_edid_scl),
		.M_AXIS_TVALID(edid_valid), .M_AXIS_TREADY(edid_ready),
			.M_AXIS_TDATA(edid_data), .M_AXIS_TLAST(edid_last),
			.M_AXIS_TID(edid_id),
		.i_sync_signal(rtc_pps),
		//
		.o_interrupt(edid_int),
		.o_debug(edid_debug)
		// }}}
	);

	// }}}
	// }}}
`else	// EDID_ACCESS
	// {{{
	assign	o_edid_scl = 1'b1;
	assign	o_edid_sda = 1'b1;
	// Null bus master
	// {{{
	// }}}
	// Null interrupt definitions
	// {{{
	assign	edid_int = 1'b0;	// edid.INT.EDID.WIRE
	// }}}
	// }}}
`endif	// EDID_ACCESS

`ifdef	GPSUART_ACCESS
	// {{{
	wbuart #(
		.INITIAL_SETUP(31'h000028b0)
	) u_gpsu_uart(
		i_clk, 1'b0,
		wb32_gpsu_cyc, wb32_gpsu_stb, wb32_gpsu_we,
			wb32_gpsu_addr[2-1:0],
			wb32_gpsu_data, // 32 bits wide
			wb32_gpsu_sel,  // 32/8 bits wide
		wb32_gpsu_stall, wb32_gpsu_ack, wb32_gpsu_idata,
		i_gpsu_rx, o_gpsu_tx, w_gpsu_cts_n, w_gpsu_rts_n,
		gpsurx_int, gpsutx_int,
		gpsurxf_int, gpsutxf_int
	);
	// }}}
`else	// GPSUART_ACCESS
	// {{{
	assign	o_gpsu_tx    = 1'b1;
	assign	w_gpsu_rts_n = 1'b0;
	// Null bus slave
	// {{{

	//
	// In the case that there is no wb32_gpsu peripheral
	// responding on the wb32 bus
	assign	wb32_gpsu_ack   = 1'b0;
	assign	wb32_gpsu_err   = (wb32_gpsu_stb);
	assign	wb32_gpsu_stall = 0;
	assign	wb32_gpsu_idata = 0;

	// }}}
	// Null interrupt definitions
	// {{{
	assign	gpsurxf_int = 1'b0;	// gpsu.INT.GPSRXF.WIRE
	assign	gpsutxf_int = 1'b0;	// gpsu.INT.GPSTXF.WIRE
	assign	gpsutx_int = 1'b0;	// gpsu.INT.GPSTX.WIRE
	assign	gpsurx_int = 1'b0;	// gpsu.INT.GPSRX.WIRE
	// }}}
	// }}}
`endif	// GPSUART_ACCESS

`ifdef	VIDPIPE_ACCESS
	// {{{
	////////////////////////////////////////////////////////////////////////
	//
	// HDMI Video processing pipeline
	// {{{
`ifdef	VERILATOR
	assign	i_hdmiclk = i_pixclk;
`endif

	vidpipe #(
		.AW(27),
		.DW(128)
	) u_hdmi (
		.i_clk(i_clk), .i_reset(i_reset),
		.i_wb_cyc(wb32_hdmi_cyc), .i_wb_stb(wb32_hdmi_stb), .i_wb_we(wb32_hdmi_we),
			.i_wb_addr(wb32_hdmi_addr[10-1:0]),
			.i_wb_data(wb32_hdmi_data), // 32 bits wide
			.i_wb_sel(wb32_hdmi_sel),  // 32/8 bits wide
		.o_wb_stall(wb32_hdmi_stall),.o_wb_ack(wb32_hdmi_ack), .o_wb_data(wb32_hdmi_idata),
		.i_hdmiclk(i_hdmiclk),
		.i_altclk(i_pixclk),
		.i_pixclk(i_pixclk),
		.i_hdmi_red(i_hdmi_red), .i_hdmi_grn(i_hdmi_grn),
				.i_hdmi_blu(i_hdmi_blu),
		.o_dma_cyc(wbwide_hdmi_cyc), .o_dma_stb(wbwide_hdmi_stb), .o_dma_we(wbwide_hdmi_we),
			.o_dma_addr(wbwide_hdmi_addr[27-1:0]),
			.o_dma_data(wbwide_hdmi_data), // 128 bits wide
			.o_dma_sel(wbwide_hdmi_sel),  // 128/8 bits wide
		.i_dma_stall(wbwide_hdmi_stall), .i_dma_ack(wbwide_hdmi_ack), .i_dma_data(wbwide_hdmi_idata), .i_dma_err(wbwide_hdmi_err),
		.o_hdmi_red(o_hdmi_red), .o_hdmi_grn(o_hdmi_grn),
				.o_hdmi_blu(o_hdmi_blu),
		.o_pix_reset_n(o_pix_reset_n),
		.i_pxpll_locked(i_pxpll_locked),
		.o_hdmirx_reset_n(o_hdmirx_reset_n),
		.o_pxclk_sel(o_pxclk_cksel),
		.o_iodelay(o_hdmi_iodelay),
		.i_iodelay(i_hdmi_iodelay),
		.o_interrupt(hdmi_int),
		//
		.o_dbg_ce(hdmidbg_ce),
		.o_dbg_trigger(hdmidbg_trigger),
		.o_pixdebug(hdmiclr_debug)
	);

	// }}}
	// }}}
`else	// VIDPIPE_ACCESS
	// {{{
	// Null bus master
	// {{{
	// }}}
	// Null bus slave
	// {{{

	//
	// In the case that there is no wb32_hdmi peripheral
	// responding on the wb32 bus
	assign	wb32_hdmi_ack   = 1'b0;
	assign	wb32_hdmi_err   = (wb32_hdmi_stb);
	assign	wb32_hdmi_stall = 0;
	assign	wb32_hdmi_idata = 0;

	// }}}
	// Null interrupt definitions
	// {{{
	assign	hdmi_int = 1'b0;	// hdmi.INT.VIDFRAME.WIRE
	// }}}
	// }}}
`endif	// VIDPIPE_ACCESS

	////////////////////////////////////////////////////////////////////////
	//
	// EDIDRX
	// {{{
	wbi2cslave #(
		.AXIS_SUPPORT(1'b1),
		.SLAVE_ADDRESS(7'h50)
	) u_edidslv (
		.i_clk(i_clk), .i_reset(i_reset),
		.i_wb_cyc(wb32_edidslv_cyc), .i_wb_stb(wb32_edidslv_stb), .i_wb_we(wb32_edidslv_we),
			.i_wb_addr(wb32_edidslv_addr[6-1:0]),
			.i_wb_data(wb32_edidslv_data), // 32 bits wide
			.i_wb_sel(wb32_edidslv_sel),  // 32/8 bits wide
		.o_wb_stall(wb32_edidslv_stall),.o_wb_ack(wb32_edidslv_ack), .o_wb_data(wb32_edidslv_idata),
		.s_valid(edid_valid), .s_ready(edid_ready),
			.s_data(edid_data), .s_last(edid_last),
		.i_i2c_scl(i_edidslv_scl), .i_i2c_sda(i_edidslv_sda),
		.o_i2c_scl(o_edidslv_scl), .o_i2c_sda(o_edidslv_sda),
		.o_dbg(edidslv_dbg)
	);
	// }}}

`ifdef	EDIDSLVSCOPE_SCOPC
	// {{{
	wbscopc #(
		// {{{
		.LGMEM(13),
		.SYNCHRONOUS(1),
		.DEFAULT_HOLDOFF(0)
		// }}}
	) u_edidslvscope (
		// {{{
		.i_data_clk(i_clk), .i_ce(1'b1),
		.i_trigger(edidslv_dbg[31]), .i_data(edidslv_dbg[30:0]),
		.i_wb_clk(i_clk),
		.i_wb_cyc(wb32_edidslvscope_cyc), .i_wb_stb(wb32_edidslvscope_stb), .i_wb_we(wb32_edidslvscope_we),
			.i_wb_addr(wb32_edidslvscope_addr[1-1:0]),
			.i_wb_data(wb32_edidslvscope_data), // 32 bits wide
			.i_wb_sel(wb32_edidslvscope_sel),  // 32/8 bits wide
		.o_wb_stall(wb32_edidslvscope_stall),.o_wb_ack(wb32_edidslvscope_ack), .o_wb_data(wb32_edidslvscope_idata),
		.o_interrupt(edidslvscope_int)
		// }}}
	);
	// }}}
`else	// EDIDSLVSCOPE_SCOPC
	// {{{
	// Null bus slave
	// {{{

	//
	// In the case that there is no wb32_edidslvscope peripheral
	// responding on the wb32 bus
	assign	wb32_edidslvscope_ack   = 1'b0;
	assign	wb32_edidslvscope_err   = (wb32_edidslvscope_stb);
	assign	wb32_edidslvscope_stall = 0;
	assign	wb32_edidslvscope_idata = 0;

	// }}}
	// Null interrupt definitions
	// {{{
	assign	edidslvscope_int = 1'b0;	// edidslvscope.INT.EDIDSLVSCOPE.WIRE
	// }}}
	// }}}
`endif	// EDIDSLVSCOPE_SCOPC

	wbdown #(
		// {{{
		// Slave bus address width: 27
		// Slave address width    : 21
		// Master address width   : 23
		.ADDRESS_WIDTH(21+$clog2(128/8)),
		.WIDE_DW(128),
		.SMALL_DW(32),
		.OPT_LITTLE_ENDIAN(1'b0),
		.OPT_LOWLOGIC(1'b0)
		// }}}
	) u_crossflash (
		// {{{
		.i_clk(i_clk),
		.i_reset(i_reset),
		// Slave/incoming
		// {{{
		.i_wcyc(  wbwide_crossflash_cyc),
		.i_wstb(  wbwide_crossflash_stb),
		.i_wwe(   wbwide_crossflash_we),
		.i_waddr( wbwide_crossflash_addr[21-1:0]),
		.i_wdata( wbwide_crossflash_data),
		.i_wsel(  wbwide_crossflash_sel),
		.o_wstall(wbwide_crossflash_stall),
		.o_wack(  wbwide_crossflash_ack),
		.o_wdata( wbwide_crossflash_idata),
		.o_werr(  wbwide_crossflash_err),
		// }}}
		// Master/down-range/outgoing
		// {{{
		.o_scyc(  wbflash_crossflash_cyc),
		.o_sstb(  wbflash_crossflash_stb),
		.o_swe(   wbflash_crossflash_we),
		.o_saddr( wbflash_crossflash_addr[23-1:0]),
		.o_sdata( wbflash_crossflash_data),
		.o_ssel(  wbflash_crossflash_sel),
		.i_sstall(wbflash_crossflash_stall),
		.i_sack(  wbflash_crossflash_ack),
		.i_sdata( wbflash_crossflash_idata),
		.i_serr(  wbflash_crossflash_err)
		// }}}
		// }}}
	);
`ifdef	CFG_ACCESS
	// {{{
	////////////////////////////////////////////////////////////////////////
	//
	// ICAPE2 driver/controller
	// {{{
	////////////////////////////////////////////////////////////////////////
	//
	//
`ifdef	VERILATOR
	reg	r_icape_ack;

	initial	r_icape_ack = 1'b0;
	always @(posedge i_clk)
		r_icape_ack <= wb32_icape_stb;
	assign	wb32_icape_ack   = r_icape_ack;
	assign	wb32_icape_stall = 1'b0;
	assign	wb32_icape_idata = 32'h00;
`else
	wbicapetwo #(
		.LGDIV(ICAPE_LGDIV)
	) u_icape (
		// {{{
		.i_clk(i_clk), .i_reset(i_reset),
		.i_wb_cyc(wb32_icape_cyc), .i_wb_stb(wb32_icape_stb), .i_wb_we(wb32_icape_we),
			.i_wb_addr(wb32_icape_addr[5-1:0]),
			.i_wb_data(wb32_icape_data), // 32 bits wide
			.i_wb_sel(wb32_icape_sel),  // 32/8 bits wide
		.o_wb_stall(wb32_icape_stall),.o_wb_ack(wb32_icape_ack), .o_wb_data(wb32_icape_idata)
		// }}}
	);
`endif
	// }}}
	// }}}
`else	// CFG_ACCESS
	// {{{
	// Null bus slave
	// {{{

	//
	// In the case that there is no wb32_icape peripheral
	// responding on the wb32 bus
	assign	wb32_icape_ack   = 1'b0;
	assign	wb32_icape_err   = (wb32_icape_stb);
	assign	wb32_icape_stall = 0;
	assign	wb32_icape_idata = 0;

	// }}}
	// }}}
`endif	// CFG_ACCESS

`ifdef	TXCLK
	// {{{
	clkcounter #(
		.CLOCKFREQ_HZ(0)	// We'll count PPS externally
	) clktxclkctr(
		.i_sys_clk(i_clk),
		.i_tst_clk(i_net_tx_clk),
		.i_sys_pps(rtc_pps),
		.o_sys_counts(wb32_txclk_idata)
	);

	initial	r_txclk_ack = 0;
	always @(posedge i_clk)
		r_txclk_ack <= !i_reset && wb32_txclk_stb;
	assign	wb32_txclk_ack   = r_txclk_ack;
	assign	wb32_txclk_stall = 1'b0;
	// }}}
`else	// TXCLK
	// {{{
	// }}}
`endif	// TXCLK

`ifdef	RXETH0CK
	// {{{
	clkcounter #(
		.CLOCKFREQ_HZ(0)	// We'll count PPS externally
	) clkrxeth0ckctr(
		.i_sys_clk(i_clk),
		.i_tst_clk(i_eth0_rx_clk),
		.i_sys_pps(rtc_pps),
		.o_sys_counts(wb32_rxeth0ck_idata)
	);

	initial	r_rxeth0ck_ack = 0;
	always @(posedge i_clk)
		r_rxeth0ck_ack <= !i_reset && wb32_rxeth0ck_stb;
	assign	wb32_rxeth0ck_ack   = r_rxeth0ck_ack;
	assign	wb32_rxeth0ck_stall = 1'b0;
	// }}}
`else	// RXETH0CK
	// {{{
	// }}}
`endif	// RXETH0CK

	initial	rtc_pps = 1'b0;
	initial	rtc_pps_counter = 0;
	always @(posedge i_clk)
	if (rtc_pps_counter > 0)
	begin
		rtc_pps_counter <= rtc_pps_counter - 1;
		rtc_pps <= 1'b0;
	end else begin
		rtc_pps_counter <= 27'd100_000_000 - 1;
		rtc_pps <= 1'b1;
	end
`ifdef	BKRAM_ACCESS
	// {{{
	memdev #(
		.LGMEMSZ(20),
		.DW(128),
		.EXTRACLOCK(1)
	) u_bkram (
		.i_clk(i_clk),
		.i_reset(i_reset),
		.i_wb_cyc(wbwide_bkram_cyc), .i_wb_stb(wbwide_bkram_stb), .i_wb_we(wbwide_bkram_we),
			.i_wb_addr(wbwide_bkram_addr[16-1:0]),
			.i_wb_data(wbwide_bkram_data), // 128 bits wide
			.i_wb_sel(wbwide_bkram_sel),  // 128/8 bits wide
		.o_wb_stall(wbwide_bkram_stall),.o_wb_ack(wbwide_bkram_ack), .o_wb_data(wbwide_bkram_idata)
	);
	// }}}
`else	// BKRAM_ACCESS
	// {{{
	// Null bus slave
	// {{{

	//
	// In the case that there is no wbwide_bkram peripheral
	// responding on the wbwide bus
	assign	wbwide_bkram_ack   = 1'b0;
	assign	wbwide_bkram_err   = (wbwide_bkram_stb);
	assign	wbwide_bkram_stall = 0;
	assign	wbwide_bkram_idata = 0;

	// }}}
	// }}}
`endif	// BKRAM_ACCESS

	wbdown #(
		// {{{
		// Slave bus address width: 27
		// Slave address width    : 10
		// Master address width   : 12
		.ADDRESS_WIDTH(10+$clog2(128/8)),
		.WIDE_DW(128),
		.SMALL_DW(32),
		.OPT_LITTLE_ENDIAN(1'b0),
		.OPT_LOWLOGIC(1'b0)
		// }}}
	) u_crossbus (
		// {{{
		.i_clk(i_clk),
		.i_reset(i_reset),
		// Slave/incoming
		// {{{
		.i_wcyc(  wbwide_crossbus_cyc),
		.i_wstb(  wbwide_crossbus_stb),
		.i_wwe(   wbwide_crossbus_we),
		.i_waddr( wbwide_crossbus_addr[10-1:0]),
		.i_wdata( wbwide_crossbus_data),
		.i_wsel(  wbwide_crossbus_sel),
		.o_wstall(wbwide_crossbus_stall),
		.o_wack(  wbwide_crossbus_ack),
		.o_wdata( wbwide_crossbus_idata),
		.o_werr(  wbwide_crossbus_err),
		// }}}
		// Master/down-range/outgoing
		// {{{
		.o_scyc(  wb32_crossbus_cyc),
		.o_sstb(  wb32_crossbus_stb),
		.o_swe(   wb32_crossbus_we),
		.o_saddr( wb32_crossbus_addr[12-1:0]),
		.o_sdata( wb32_crossbus_data),
		.o_ssel(  wb32_crossbus_sel),
		.i_sstall(wb32_crossbus_stall),
		.i_sack(  wb32_crossbus_ack),
		.i_sdata( wb32_crossbus_idata),
		.i_serr(  wb32_crossbus_err)
		// }}}
		// }}}
	);
`ifdef	SDRAM_ACCESS
	// {{{
	////////////////////////////////////////////////////////////////////////
	//
	// DDR3 Controller instantiation
	// {{{
           
	ddr3_controller #(
		// {{{
		.CONTROLLER_CLK_PERIOD(SDRAMCONTROLLER_CLK_PERIOD), //ps, clock period of the controller interface
		.DDR3_CLK_PERIOD(DDR3_CLK_PERIOD), //ps, clock period of the DDR3 RAM device (must be 1/4 of the CONTROLLER_CLK_PERIOD) 
		.ROW_BITS(SDRAMROW_BITS),	//width of row address
		.COL_BITS(SDRAMCOL_BITS),	//width of column address
		.BA_BITS(SDRAMBA_BITS),	//width of bank address
		.DQ_BITS(SDRAMDQ_BITS),	//width of DQ
		.LANES(SDRAMBYTE_LANES),		// byte lanes
		.AUX_WIDTH(SDRAMAUX_WIDTH),	//width of aux line (must be >= 4) 
		.WB2_ADDR_BITS(7), 		//width of 2nd wishbone address bus 
            	.WB2_DATA_BITS(32),  		//width of 2nd wishbone data bus
		.MICRON_SIM(0),		//simulation for micron ddr3 model (shorten POWER_ON_RESET_HIGH and INITIAL_CKE_LOW)
		.ODELAY_SUPPORTED(1),		//set to 1 when ODELAYE2 is supported
		.SECOND_WISHBONE(1) 		//set to 1 if 2nd wishbone is needed 
		// }}}
	) u_ddr3 (
		// {{{
		.i_controller_clk(i_clk), //i_controller_clk has period of CONTROLLER_CLK_PERIOD
		.i_rst_n(!i_reset), //200MHz input clock
		// Wishbone 1 (Controller)
		.i_wb_cyc(wbwide_ddr3_cyc), .i_wb_stb(wbwide_ddr3_stb), .i_wb_we(wbwide_ddr3_we),
			.i_wb_addr(wbwide_ddr3_addr[26-1:0]),
			.i_wb_data(wbwide_ddr3_data), // 128 bits wide
			.i_wb_sel(wbwide_ddr3_sel),  // 128/8 bits wide
		.o_wb_stall(wbwide_ddr3_stall),.o_wb_ack(wbwide_ddr3_ack), .o_wb_data(wbwide_ddr3_idata),
		.i_aux(0),
		.o_aux(ddr3_aux_out),	// Leaving this empty would've caused a Verilator warning
		// Wishbone 2 (PHY)
		.i_wb2_cyc(wb32_ddr3_phy_cyc), .i_wb2_stb(wb32_ddr3_phy_stb), .i_wb2_we(wb32_ddr3_phy_we),
			.i_wb2_addr(wb32_ddr3_phy_addr[7-1:0]),
			.i_wb2_data(wb32_ddr3_phy_data), // 32 bits wide
			.i_wb2_sel(wb32_ddr3_phy_sel),  // 32/8 bits wide
		.o_wb2_stall(wb32_ddr3_phy_stall),.o_wb2_ack(wb32_ddr3_phy_ack), .o_wb2_data(wb32_ddr3_phy_idata),
		//
		// PHY interface
		.i_phy_iserdes_data(i_ddr3_iserdes_data),
		.i_phy_iserdes_dqs(i_ddr3_iserdes_dqs),
		.i_phy_iserdes_bitslip_reference(i_ddr3_iserdes_bitslip_reference),
		.i_phy_idelayctrl_rdy(i_ddr3_idelayctrl_rdy),
		.o_phy_cmd(o_ddr3_cmd),
		.o_phy_dqs_tri_control(o_ddr3_dqs_tri_control),
		.o_phy_dq_tri_control(o_ddr3_dq_tri_control),
		.o_phy_toggle_dqs(o_ddr3_toggle_dqs),
		.o_phy_data(o_ddr3_data),
		.o_phy_dm(o_ddr3_dm),
		.o_phy_odelay_data_cntvaluein(o_ddr3_odelay_data_cntvaluein),
		.o_phy_odelay_dqs_cntvaluein(o_ddr3_odelay_dqs_cntvaluein),
		.o_phy_idelay_data_cntvaluein(o_ddr3_idelay_data_cntvaluein),
		.o_phy_idelay_dqs_cntvaluein(o_ddr3_idelay_dqs_cntvaluein),
		.o_phy_odelay_data_ld(o_ddr3_odelay_data_ld),
		.o_phy_odelay_dqs_ld(o_ddr3_odelay_dqs_ld),
		.o_phy_idelay_data_ld(o_ddr3_idelay_data_ld),
		.o_phy_idelay_dqs_ld(o_ddr3_idelay_dqs_ld),
		.o_phy_bitslip(o_ddr3_bitslip),
		.o_phy_write_leveling_calib(o_ddr3_leveling_calib),
		.o_phy_reset(o_ddr3_reset),
		// Debug port
		.o_debug1(ddr3_debug),
		// Verilator lint_off PINCONNECTEMPTY
		.o_debug2(),
		.o_debug3()
		// Verilator lint_on  PINCONNECTEMPTY
		// }}}
	);
	// }}}
	// }}}
`else	// SDRAM_ACCESS
	// {{{
	// Null bus slave
	// {{{

	//
	// In the case that there is no wbwide_ddr3 peripheral
	// responding on the wbwide bus
	assign	wbwide_ddr3_ack   = 1'b0;
	assign	wbwide_ddr3_err   = (wbwide_ddr3_stb);
	assign	wbwide_ddr3_stall = 0;
	assign	wbwide_ddr3_idata = 0;

	// }}}
	// }}}
`endif	// SDRAM_ACCESS

`ifdef	I2CDMA_ACCESS
	// {{{
	wbi2cdma #(
		.AW(27), .DW(128), .SW(8),
		.OPT_LITTLE_ENDIAN(1'b0)
	) u_i2cdma (
		// {{{
		.i_clk(i_clk),
		.i_reset(i_reset),
		//
		.i_wb_cyc(wb32_i2cdma_cyc), .i_wb_stb(wb32_i2cdma_stb), .i_wb_we(wb32_i2cdma_we),
			.i_wb_addr(wb32_i2cdma_addr[2-1:0]),
			.i_wb_data(wb32_i2cdma_data), // 32 bits wide
			.i_wb_sel(wb32_i2cdma_sel),  // 32/8 bits wide
		.o_wb_stall(wb32_i2cdma_stall),.o_wb_ack(wb32_i2cdma_ack), .o_wb_data(wb32_i2cdma_idata),
		.S_VALID(i2c_valid && i2c_id == 2),
			.S_READY(i2cdma_ready),
			.S_DATA(i2c_data), .S_LAST(i2c_last),
		.o_dma_cyc(wbwide_i2cdma_cyc), .o_dma_stb(wbwide_i2cdma_stb), .o_dma_we(wbwide_i2cdma_we),
			.o_dma_addr(wbwide_i2cdma_addr[27-1:0]),
			.o_dma_data(wbwide_i2cdma_data), // 128 bits wide
			.o_dma_sel(wbwide_i2cdma_sel),  // 128/8 bits wide
		.i_dma_stall(wbwide_i2cdma_stall), .i_dma_ack(wbwide_i2cdma_ack), .i_dma_data(wbwide_i2cdma_idata), .i_dma_err(wbwide_i2cdma_err)
		// }}}
	);

	// }}}
`else	// I2CDMA_ACCESS
	// {{{
	assign	i2cdma_ready = 1'b0;
	// Null bus master
	// {{{
	// }}}
	// }}}
`endif	// I2CDMA_ACCESS

`ifdef	PWRCOUNT_ACCESS
	// {{{
	initial	r_pwrcount_data = 32'h0;
	always @(posedge i_clk)
	if (r_pwrcount_data[31])
		r_pwrcount_data[30:0] <= r_pwrcount_data[30:0] + 1'b1;
	else
		r_pwrcount_data[31:0] <= r_pwrcount_data[31:0] + 1'b1;

	assign	wb32_pwrcount_stall = 1'b0;
	assign	wb32_pwrcount_ack   = wb32_pwrcount_stb;
	assign	wb32_pwrcount_idata = r_pwrcount_data;
	// }}}
`else	// PWRCOUNT_ACCESS
	// {{{
	// }}}
`endif	// PWRCOUNT_ACCESS

`ifdef	I2SAUDIO
	// {{{
	////////////////////////////////////////////////////////////////////////
	//
	// I2S Audio signal handler
	// {{{

	assign	o_i2s_mclk = i_genclk_clk;
	assign	w_i2saudio_en = 1'b1;

	axisi2s #(
		.BDIV(4'h1)
	) u_i2saudio (
		// {{{
		.S_AXI_ACLK(i_clk), .S_AXI_ARESETN(!i_reset),
		//
		// Inputs to drive the speakers
		.S_AXIS_TVALID(w_audio_out_valid),
		.S_AXIS_TREADY(w_audio_out_ready),
		.S_AXIS_TDATA(w_audio_out_data),
		.S_AXIS_TLAST(w_audio_out_last),
		//
		// Outputs from the microphone
		.M_AXIS_TVALID(w_audio_in_valid),
		.M_AXIS_TREADY(w_audio_in_ready),
		.M_AXIS_TDATA(w_audio_in_data),
		.M_AXIS_TLAST(w_audio_in_last),
		//
		.i_mclk(o_i2s_mclk),
		.i_clken(w_i2saudio_en),
		.o_lrclk(o_i2s_lrclk),
		.o_bclk(o_i2s_bclk),
		.i_adc(i_i2s_adc),
		.o_dac(o_i2s_dac),
		.o_debug(w_i2saudio_debug)
		// }}}
	);

`ifndef	AUDIOSINK_ACCESS
	assign	w_audio_out_valid = 0;
	assign	w_audio_out_data  = 0;
	assign	w_audio_out_last  = 0;
`endif
`ifndef	AUDIOSOURCE_ACCESS
	assign	w_audio_in_ready = 1;
`endif
	// }}}
	// }}}
`else	// I2SAUDIO
	// {{{
	////////////////////////////////////////////////////////////////////////
	//
	// (No) I2S Audio signal handler (option)
	// {{{
`ifndef	AUDIOSINK_ACCESS
	assign	w_audio_out_valid = 0;
	assign	w_audio_out_data  = 0;
	assign	w_audio_out_last  = 0;
`endif
	assign	w_audio_out_ready = 0;

	assign	w_audio_in_valid = 0;
	assign	w_audio_in_data  = 0;
	assign	w_audio_in_last  = 0;
`ifndef	AUDIOSOURCE_ACCESS
	assign	w_audio_in_ready = 0;
`endif
	// }}}
	// }}}
`endif	// I2SAUDIO

	// Generate a PPS signal independent of the GPS--useful for testing
	gpsclock_tb #(
		.CLOCK_FREQUENCY_HZ(100000000)
	) ppstb(
		.i_clk(i_clk), .i_lcl_pps(ck_pps), .o_pps(tb_pps),
		.i_wb_cyc(wb32_gtb_cyc), .i_wb_stb(wb32_gtb_stb), .i_wb_we(wb32_gtb_we),
			.i_wb_addr(wb32_gtb_addr[3-1:0]),
			.i_wb_data(wb32_gtb_data), // 32 bits wide
			.i_wb_sel(wb32_gtb_sel),  // 32/8 bits wide
		.o_wb_stall(wb32_gtb_stall),.o_wb_ack(wb32_gtb_ack), .o_wb_data(wb32_gtb_idata),
		.i_err(gps_err), .i_count(gps_now), .i_step(gps_step)
	);

	assign	gps_pps = tb_pps;
	assign	o_pxclk_cyc  = wb32_pxclk_cyc;
	assign	o_pxclk_stb  = wb32_pxclk_stb;
	assign	o_pxclk_we   = wb32_pxclk_we;
	assign	o_pxclk_addr = wb32_pxclk_addr[6:0];
	assign	o_pxclk_data = wb32_pxclk_data;
	assign	o_pxclk_sel  = wb32_pxclk_sel;
	assign	wb32_pxclk_stall = i_pxclk_stall;
	assign	wb32_pxclk_ack   = i_pxclk_ack;
	assign	wb32_pxclk_idata = i_pxclk_idata;
`ifdef	MEGANET_ACCESS
	// {{{
	////////////////////////////////////////////////////////////////////////
	//
	// MegaNET MEGANET
	// {{{
	////////////////////////////////////////////////////////////////////////
	//
	//

	meganet #(
		// {{{
		.DEF_HWMAC(DEF_HWMAC),
		.DEF_IPADDR(DEF_IPADDR),
		.UDP_DBGPORT(UDP_DBGPORT)
		// }}}
	) u_net (
		// {{{
		.S_AXI_ACLK(i_clk), .S_AXI_ARESETN(!i_reset),
		//
		.o_hwmac(net_hwmac), .o_ipaddr(net_ip_addr),
		.o_ping_hwmac(net_last_ping_hwmac),
			.o_ping_ipaddr(net_last_ping_ipaddr),
		// Wishbone port
		// {{{
		.i_wb_cyc(wb32_net_cyc), .i_wb_stb(wb32_net_stb), .i_wb_we(wb32_net_we),
			.i_wb_addr(wb32_net_addr[5-1:0]),
			.i_wb_data(wb32_net_data), // 32 bits wide
			.i_wb_sel(wb32_net_sel),  // 32/8 bits wide
		.o_wb_stall(wb32_net_stall),.o_wb_ack(wb32_net_ack), .o_wb_data(wb32_net_idata),
		// }}}
		// ifdef MEGANETCPUTX_ACCESS
		// {{{
		.S_CPU_VALID(netcputx_valid),
			.S_CPU_READY(netcputx_ready),
			.S_CPU_DATA(netcputx_data),
			.S_CPU_BYTES(netcputx_bytes),
			.S_CPU_LAST(netcputx_last),
			.S_CPU_ABORT(netcputx_abort),
		// }}}
`ifdef	NETBUS_ACCESS
		// {{{
		.S_DBG_VALID(netbus_valid),
			.S_DBG_READY(netbus_ready),
			.S_DBG_DATA(netbus_pkdata),
			// .S_DBG_BYTES(netbus_bytes),
			.S_DBG_LAST(netbus_last),
`else
		.S_DBG_VALID(1'b0),
			.S_DBG_READY(net_dbg_ready),
			.S_DBG_DATA(32'h0),
			.S_DBG_LAST(1'b1),
`endif
		// }}}
		// Data interface
		// {{{
		.S_DATA_VALID(1'b0),
			.S_DATA_READY(ign_rxpkt_net_ready),
			.S_DATA_DATA(32'h0),
			.S_DATA_BYTES(2'h0),
			.S_DATA_LAST(1'b1),
		// }}}
		// ifdef MEGANETCPURX_ACCESS
		// {{{
		.M_CPU_VALID(netcpurx_valid),
			.M_CPU_READY(netcpurx_ready),
			.M_CPU_DATA(netcpurx_data),
			.M_CPU_BYTES(netcpurx_bytes),
			.M_CPU_LAST(netcpurx_last),
			.M_CPU_ABORT(netcpurx_abort),
		// }}}
		// Debug IP/UDP RX packets
		// {{{
		.M_DBG_VALID(net_dbg_valid),
			.M_DBG_READY(net_dbg_ready),
			.M_DBG_DATA( net_dbg_data),
			.M_DBG_BYTES(net_dbg_bytes),
			.M_DBG_LAST( net_dbg_last),
		// }}}
		// Interface to top-level IOs
		// {{{
		.o_net_reset_n(o_net_reset_n),
		.i_net_rx_clk(i_net_rx_clk), .i_net_rx_dv(i_net_rx_dv),
		.i_net_rx_err(i_net_rx_err), .i_net_rxd(i_net_rxd),
		//
		.i_net_tx_clk(i_net_tx_clk), .o_net_tx_ck(o_net_tx_clk),
		.o_net_tx_ctl(o_net_tx_ctl), .o_net_txd(o_net_txd),
		// }}}
		.o_debug_clk(net_debug_clk),
		.o_debug(net_debug)
		// }}}
	);

`ifndef	NETBUS_ACCESS
	// {{{
	assign	net_dbg_ready = 1'b1;
	// Verilator lint_off UNUSED
	wire	unused_net_dbgrx;
	assign	unused_net_dbgrx = &{ 1'b0,
			net_dbg_valid, net_dbg_data,
				net_dbg_bytes, net_dbg_last };
	// Verilator lint_on  UNUSED
	// }}}
`endif

`ifndef	MEGANETCPURX_ACCESS
	// {{{
	assign	netcpurx_ready = 1'b1;
	// Verilator lint_off UNUSED
	wire	unused_net_cpu_rx;
	assign	unused_net_cpu_rx = &{ 1'b0,
			netcpurx_valid, netcpurx_data,
				netcpurx_bytes,
			netcpurx_abort, netcpurx_last };
	// Verilator lint_on  UNUSED
	// }}}
`endif

`ifndef	MEGANETCPUTX_ACCESS
	// {{{
	assign	netcputx_valid = 1'b0;
	assign	netcputx_data  = 32'h0;
	assign	netcputx_bytes =  2'h0;
	assign	netcputx_last  =  1'b1;
	assign	netcputx_abort =  1'b0;
	// }}}
`endif


	// }}}
	// }}}
`else	// MEGANET_ACCESS
	// {{{
	// Null bus slave
	// {{{

	//
	// In the case that there is no wb32_net peripheral
	// responding on the wb32 bus
	assign	wb32_net_ack   = 1'b0;
	assign	wb32_net_err   = (wb32_net_stb);
	assign	wb32_net_stall = 0;
	assign	wb32_net_idata = 0;

	// }}}
	// }}}
`endif	// MEGANET_ACCESS

`ifdef	RTCDATE_ACCESS
	// {{{
	//
	// The Calendar DATE
	//
	rtcdate #(
		.INITIAL_DATE(`DATESTAMP)
	) u_rtcdate(
		.i_clk(i_clk), .i_ppd(rtc_ppd),
		.i_wb_cyc(wb32_rtcdate_cyc), .i_wb_stb(wb32_rtcdate_stb), .i_wb_we(wb32_rtcdate_we),
			.i_wb_data(wb32_rtcdate_data), // 32 bits wide
			.i_wb_sel(wb32_rtcdate_sel),  // 32/8 bits wide
		.o_wb_stall(wb32_rtcdate_stall),.o_wb_ack(wb32_rtcdate_ack), .o_wb_data(wb32_rtcdate_idata)
	);
	// }}}
`else	// RTCDATE_ACCESS
	// {{{
	// }}}
`endif	// RTCDATE_ACCESS

`ifdef	RTC_ACCESS
	// {{{
`ifdef	GPSTRK_ACCESS
	rtcgps	#(
		.DEFAULT_SPEED(RTC_CLKSTEP)
	) u_rtc(
		.i_clk(i_clk), .i_reset(i_reset),
		.i_wb_cyc(wb32_rtc_cyc), .i_wb_stb(wb32_rtc_stb), .i_wb_we(wb32_rtc_we),
			.i_wb_addr(wb32_rtc_addr[2-1:0]),
			.i_wb_data(wb32_rtc_data), // 32 bits wide
			.i_wb_sel(wb32_rtc_sel),  // 32/8 bits wide
		.o_wb_stall(wb32_rtc_stall),.o_wb_ack(wb32_rtc_ack), .o_wb_data(wb32_rtc_idata),
		.o_interrupt(rtc_int), .o_ppd(rtc_ppd),
		.i_gps_valid(gps_tracking), .i_gps_pps(ck_pps),
			.i_gps_ckspeed(gps_step[47:16]), .o_rtc_pps(rtc_pps)
	);
`else
	rtclight #(
		.DEFAULT_SPEED(32'h2af31d)
	) u_rtc(
		.i_clk(i_clk), .i_reset(i_reset),
		// Can't use the ANSIPORTLIST tag, because the address widths
		// don't match
		.i_wb_cyc(wb32_rtc_cyc),
		.i_wb_stb(wb32_rtc_stb),
		.i_wb_we(wb32_rtc_we),
		.i_wb_addr({ 1'b0, wb32_rtc_addr[1:0] }),
		.i_wb_data(wb32_rtc_data),
		.i_wb_sel(wb32_rtc_sel),
		.o_wb_stall(wb32_rtc_stall),
		.o_wb_ack(wb32_rtc_ack),
		.o_wb_data(wb32_rtc_idata),
		.o_interrupt(rtc_int),
		.o_pps(rtc_pps),
		.o_ppd(rtc_ppd)
	);

	// Verilator lint_off UNUSED
	wire	unused_rtc;
	assign	unused_rtc = &{ 1'b0, i_gps_pps };
	// Verilator lint_on  UNUSED
`endif
	// }}}
`else	// RTC_ACCESS
	// {{{
`ifdef	GPSTRK_ACCESS
	assign	rtc_pps = ck_pps;
`endif
	assign	rtc_ppd = 1'b0;
	// Null interrupt definitions
	// {{{
	assign	rtc_int = 1'b0;	// rtc.INT.RTC.WIRE
	// }}}
	// }}}
`endif	// RTC_ACCESS

`ifdef	SPIO_ACCESS
	// {{{
	//
	// Special purpose I/O driver (buttons, LEDs, and switches)
	//
	assign	w_btn = { i_btnc, i_btnd, i_btnl, i_btnr, i_btnu };

	spio #(
		.NBTN(5), .NLEDS(8), .NSW(8)
	) u_spio (
		.i_clk(i_clk), .i_reset(i_reset),
		.i_wb_cyc(wb32_spio_cyc), .i_wb_stb(wb32_spio_stb), .i_wb_we(wb32_spio_we),
			.i_wb_data(wb32_spio_data), // 32 bits wide
			.i_wb_sel(wb32_spio_sel),  // 32/8 bits wide
		.o_wb_stall(wb32_spio_stall),.o_wb_ack(wb32_spio_ack), .o_wb_data(wb32_spio_idata),
		.i_sw(i_sw), .i_btn(w_btn), .o_led(w_led),
		.o_int(spio_int)
	);

	assign	o_led = w_led;

	// }}}
`else	// SPIO_ACCESS
	// {{{
	assign	w_btn = 0;
	assign	o_led = 0;
	// Null interrupt definitions
	// {{{
	assign	spio_int = 1'b0;	// spio.INT.SPIO.WIRE
	// }}}
	// }}}
`endif	// SPIO_ACCESS

`ifdef	GPIO_ACCESS
	// {{{
	////////////////////////////////////////////////////////////////////////
	//
	// GPIO
	// {{{
	// This interface should allow us to control up to 16 GPIO inputs,
	// and another 16 GPIO outputs.  The interrupt trips when any of
	// the inputs changes.  (Sorry, which input isn't (yet) selectable.)
	//
	localparam [NGPO-1:0]	INITIAL_GPIO = 10'h13;

	wbgpio	#(
		.NIN(NGPI), .NOUT(NGPO), .DEFAULT(INITIAL_GPIO)
	) u_gpio (
		// {{{
		.i_clk(i_clk),
		.i_wb_cyc(wb32_gpio_cyc), .i_wb_stb(wb32_gpio_stb), .i_wb_we(wb32_gpio_we),
			.i_wb_data(wb32_gpio_data), // 32 bits wide
			.i_wb_sel(wb32_gpio_sel),  // 32/8 bits wide
		.o_wb_stall(wb32_gpio_stall),.o_wb_ack(wb32_gpio_ack), .o_wb_data(wb32_gpio_idata),
		.i_gpio(i_gpio), .o_gpio(o_gpio),
		.o_int(gpio_int)
		// }}}
	);

`ifdef	SDIO_ACCESS
	// This bit is used by the SDSPI controller, not the SDIO controller.
	assign	sd_reset = !o_sdio_hwreset_n;
`else
	assign	sd_reset = o_gpio[3];
`endif

`ifdef	VERILATOR
	wire	verilator_halt;
	assign	o_trace = o_gpio[8];

	assign	verilator_halt = o_gpio[9];
	assign	o_halt = verilator_halt;
	always @(posedge verilator_halt)
		$finish;
`endif
	// }}}
	// }}}
`else	// GPIO_ACCESS
	// {{{
	// Null interrupt definitions
	// {{{
	assign	gpio_int = 1'b0;	// gpio.INT.GPIO.WIRE
	// }}}
	// }}}
`endif	// GPIO_ACCESS

`ifdef	SDIO_ACCESS
	// {{{
	////////////////////////////////////////////////////////////////////////
	//
	// SDIO SD Card handling
	// {{{
	////////////////////////////////////////////////////////////////////////
	//
	//

	always @(*)
	begin
		sdio_debug = i_sdio_debug;
		sdio_debug = w_sdio_sdwb_debug;
	end

	sdio #(
		// {{{
		.LGFIFO(10), .NUMIO(4),
		.MW(32),
		.ADDRESS_WIDTH(27+$clog2(128/8)),
		.DMA_DW(128),
		.OPT_SERDES(1'b1),
		.OPT_EMMC(1'b0),
		.OPT_DMA(1'b1),
		.OPT_DDR(1'b1),
		.OPT_HWRESET(1'b0),
		.OPT_CARD_DETECT(1'b1),
		.OPT_CRCTOKEN(1),
		.OPT_1P8V(1'b0),
`ifdef	VERILATOR
		.LGTIMEOUT(18),
`else
		.LGTIMEOUT(26),
`endif
		.OPT_ISTREAM(1'b0),
		.OPT_OSTREAM(1'b0)
		// }}}
	) u_sdio(
		// {{{
		.i_clk(i_clk),
		.i_reset(i_reset),
		.i_wb_cyc(wbflash_sdio_cyc), .i_wb_stb(wbflash_sdio_stb), .i_wb_we(wbflash_sdio_we),
			.i_wb_addr(wbflash_sdio_addr[3-1:0]),
			.i_wb_data(wbflash_sdio_data), // 32 bits wide
			.i_wb_sel(wbflash_sdio_sel),  // 32/8 bits wide
		.o_wb_stall(wbflash_sdio_stall),.o_wb_ack(wbflash_sdio_ack), .o_wb_data(wbflash_sdio_idata),
		.o_dma_cyc(wbwide_sdio_cyc), .o_dma_stb(wbwide_sdio_stb), .o_dma_we(wbwide_sdio_we),
			.o_dma_addr(wbwide_sdio_addr[27-1:0]),
			.o_dma_data(wbwide_sdio_data), // 128 bits wide
			.o_dma_sel(wbwide_sdio_sel),  // 128/8 bits wide
		.i_dma_stall(wbwide_sdio_stall), .i_dma_ack(wbwide_sdio_ack), .i_dma_data(wbwide_sdio_idata), .i_dma_err(wbwide_sdio_err),
		// (Unused) DMA Stream assignments
		// {{{
		.s_valid(1'b0),
		.s_ready(s_sdio_ready),
		.s_data(32'h0),
		//
		.m_valid(m_sdio_valid),
		.m_ready(1'b1),
		.m_data(m_sdio_data),
		.m_last(m_sdio_last),
		// }}}
		.i_card_detect(i_sdio_detect),
		.o_hwreset_n(o_sdio_hwreset_n),
		.o_1p8v(o_sdio_1p8v),
		.o_int(sdio_int),
		//
		.o_cfg_ddr(o_sdio_cfg_ddr),
		.o_cfg_ds(o_sdio_cfg_ds),
		.o_cfg_dscmd(o_sdio_cfg_dscmd),
		.o_cfg_sample_shift(o_sdio_cfg_sample_shift),
		.o_cmd_tristate(o_sdio_cmd_tristate),
		.o_data_tristate(o_sdio_data_tristate),
		//
		.o_sdclk(   o_sdio_sdclk),
		.o_cmd_en(  o_sdio_cmd_en),
		.o_cmd_data(o_sdio_cmd_data),
		.o_data_en( o_sdio_data_en),
		.o_rx_en(   o_sdio_rx_en),
		.o_tx_data( o_sdio_tx_data),
		//
		.i_cmd_strb( i_sdio_cmd_strb),
		.i_cmd_data( i_sdio_cmd_data),
		.i_cmd_collision( i_sdio_cmd_collision),
		.i_crcack( i_sdio_crcack),
		.i_crcnak( i_sdio_crcnak),
		.i_card_busy(i_sdio_card_busy),
		.i_rx_strb(  i_sdio_rx_strb),
		.i_rx_data(  i_sdio_rx_data),
		//
		.S_AC_VALID(i_sdio_ac_valid),
		.S_AC_DATA( i_sdio_ac_data),
		.S_AD_VALID(i_sdio_ad_valid),
		.S_AD_DATA( i_sdio_ad_data),
		//
		.o_debug(w_sdio_sdwb_debug)
		// }}}
	);

	// }}}
	// }}}
`else	// SDIO_ACCESS
	// {{{
	// Null bus master
	// {{{
	// }}}
	// Null bus slave
	// {{{

	//
	// In the case that there is no wbflash_sdio peripheral
	// responding on the wbflash bus
	assign	wbflash_sdio_ack   = 1'b0;
	assign	wbflash_sdio_err   = (wbflash_sdio_stb);
	assign	wbflash_sdio_stall = 0;
	assign	wbflash_sdio_idata = 0;

	// }}}
	// Null interrupt definitions
	// {{{
	assign	sdio_int = 1'b0;	// sdio.INT.SDCARD.WIRE
	// }}}
	// }}}
`endif	// SDIO_ACCESS

	assign	i_net_tx_clk = i_clk_125mhz;
`ifdef	BUSPIC_ACCESS
	// {{{
	//
	// The BUS Interrupt controller
	//
	icontrol #(15)
	u_buspic (
		.i_clk(i_clk), .i_reset(1'b0),
		.i_wb_cyc(wb32_buspic_cyc), .i_wb_stb(wb32_buspic_stb), .i_wb_we(wb32_buspic_we),
			.i_wb_data(wb32_buspic_data), // 32 bits wide
			.i_wb_sel(wb32_buspic_sel),  // 32/8 bits wide
		.o_wb_stall(wb32_buspic_stall),.o_wb_ack(wb32_buspic_ack), .o_wb_data(wb32_buspic_idata),
		.i_brd_ints(bus_int_vector),
		.o_interrupt(w_bus_int)
	);
	// }}}
`else	// BUSPIC_ACCESS
	// {{{
	// Null interrupt definitions
	// {{{
	assign	w_bus_int = 1'b0;	// buspic.INT.BUS.WIRE
	// }}}
	// }}}
`endif	// BUSPIC_ACCESS

`ifdef	GPSTRK_ACCESS
	// {{{
	// Verilator lint_off UNUSED
	wire	[1:0]	ck_dbg;
	// Verilator lint_on  UNUSED

	gpsclock #(
		.DEFAULT_STEP(GPSCLOCK_DEFAULT_STEP)
	) ppsck (
		.i_clk(i_clk), .i_rst(1'b0), .i_pps(gps_pps), .o_pps(ck_pps),
			.o_led(gps_led),
		.i_wb_cyc(wb32_gck_cyc), .i_wb_stb(wb32_gck_stb), .i_wb_we(wb32_gck_we),
			.i_wb_addr(wb32_gck_addr[2-1:0]),
			.i_wb_data(wb32_gck_data), // 32 bits wide
			.i_wb_sel(wb32_gck_sel),  // 32/8 bits wide
		.o_wb_stall(wb32_gck_stall),.o_wb_ack(wb32_gck_ack), .o_wb_data(wb32_gck_idata),
		.o_tracking(gps_tracking), .o_count(gps_now), .o_step(gps_step),
		.o_err(gps_err), .o_locked(gps_locked), .o_dbg(ck_dbg)
	);

	assign	gck_pps = ck_pps;

	// }}}
`else	// GPSTRK_ACCESS
	// {{{
	reg		r_ck_pps;
	reg	[63:0]	r_gps_now;
	reg	[31:0]	r_gps_prior;
	wire	[47:0]	pre_step;
	assign	pre_step = { 16'h00, (({GPSCLOCK_DEFAULT_STEP[27:0],20'h00})
				>>GPSCLOCK_DEFAULT_STEP[31:28]) };

	initial	{ r_ck_pps, r_gps_prior } = 33'h0;
	always @(posedge i_clk)
		{ r_ck_pps, r_gps_prior[31:0] } <= r_gps_prior + pre_step[31:0];

	initial	r_gps_now = 64'h0;
	always @(posedge i_clk)
	begin
		r_gps_now[63:32] <= r_gps_now[63:32]+(r_ck_pps ? 32'h1:32'h0);
		r_gps_now[31:0]  <= r_gps_prior;
	end
	assign	ck_pps     = r_ck_pps;
	assign	gps_now    = r_gps_now;
	assign	gps_err    = 64'h0;
	assign	gps_step   = pre_step;
	assign	gps_led    = 1'b0;
	assign	gps_locked = 1'b0;

	// Null interrupt definitions
	// {{{
	assign	gck_pps = 1'b0;	// gck.INT.PPS.WIRE
	// }}}
	// }}}
`endif	// GPSTRK_ACCESS

`ifdef	NETCTRL_ACCESS
	// {{{
	enetctrl #(
		.CLKBITS(6)
	) u_mdio (
		.i_clk(i_clk), .i_reset(i_reset),
		.i_wb_cyc(wb32_mdio_cyc), .i_wb_stb(wb32_mdio_stb), .i_wb_we(wb32_mdio_we),
			.i_wb_addr(wb32_mdio_addr[10-1:0]),
			.i_wb_data(wb32_mdio_data), // 32 bits wide
			.i_wb_sel(wb32_mdio_sel),  // 32/8 bits wide
		.o_wb_stall(wb32_mdio_stall),.o_wb_ack(wb32_mdio_ack), .o_wb_data(wb32_mdio_idata),
		.o_mdclk(o_mdclk), .o_mdio(o_mdio), .i_mdio(i_mdio),
		.o_mdwe(o_mdwe), .o_debug(mdio_debug)
	);
	// }}}
`else	// NETCTRL_ACCESS
	// {{{
	assign	o_mdclk = 1'b1;
	assign	o_mdio  = 1'b1;
	assign	o_mdwe  = 1'b0;
	// Null bus slave
	// {{{

	//
	// In the case that there is no wb32_mdio peripheral
	// responding on the wb32 bus
	assign	wb32_mdio_ack   = 1'b0;
	assign	wb32_mdio_err   = (wb32_mdio_stb);
	assign	wb32_mdio_stall = 0;
	assign	wb32_mdio_idata = 0;

	// }}}
	// }}}
`endif	// NETCTRL_ACCESS

	assign	wb32_buildtime_idata = `BUILDTIME;
	assign	wb32_buildtime_ack = wb32_buildtime_stb;
	assign	wb32_buildtime_stall = 1'b0;
`ifdef	VERSION_ACCESS
	// {{{
	assign	wb32_version_idata = `DATESTAMP;
	assign	wb32_version_ack = wb32_version_stb;
	assign	wb32_version_stall = 1'b0;
	// }}}
`else	// VERSION_ACCESS
	// {{{
	// }}}
`endif	// VERSION_ACCESS

`ifdef	OLEDBW_ACCESS
	// {{{
	spicpu #(
		// {{{
		.ADDRESS_WIDTH(27),
		.DATA_WIDTH(128),
		.NCE(2),
		.OPT_MANUAL(1'b1), .OPT_LITTLE_ENDIAN(1'b0),
		.OPT_START_HALTED(1'b1), .OPT_SHARED_MISO(1'b1)
		// }}}
	) u_oled (
		// {{{
		.i_clk(i_clk), .i_reset(i_reset),
		.i_wb_cyc(wb32_oled_cyc), .i_wb_stb(wb32_oled_stb), .i_wb_we(wb32_oled_we),
			.i_wb_addr(wb32_oled_addr[2-1:0]),
			.i_wb_data(wb32_oled_data), // 32 bits wide
			.i_wb_sel(wb32_oled_sel),  // 32/8 bits wide
		.o_wb_stall(wb32_oled_stall),.o_wb_ack(wb32_oled_ack), .o_wb_data(wb32_oled_idata),
		.o_pf_cyc(wbwide_oledm_cyc), .o_pf_stb(wbwide_oledm_stb), .o_pf_we(wbwide_oledm_we),
			.o_pf_addr(wbwide_oledm_addr[27-1:0]),
			.o_pf_data(wbwide_oledm_data), // 128 bits wide
			.o_pf_sel(wbwide_oledm_sel),  // 128/8 bits wide
		.i_pf_stall(wbwide_oledm_stall), .i_pf_ack(wbwide_oledm_ack), .i_pf_data(wbwide_oledm_idata), .i_pf_err(wbwide_oledm_err),
		.o_spi_csn(w_oled_csn), .o_spi_sck(o_oled_sck),
		.o_spi_mosi(o_oled_mosi), .i_spi_miso(1'b0),
		.M_AXIS_TVALID(ign_oled_valid),
		.M_AXIS_TREADY(1'b1),
		.M_AXIS_TDATA( ign_oled_data),
		.M_AXIS_TLAST( ign_oled_last),
		.M_AXIS_TID(   ign_oled_id),
		//
		.o_interrupt(oled_int),
		.i_sync_signal(rtc_pps),
		.o_debug(oled_debug)
		// }}}
	);

	assign	o_oled_dcn = w_oled_csn[0];
	// }}}
`else	// OLEDBW_ACCESS
	// {{{
	assign	o_oled_sck     = 1'b1;
	assign	o_oled_mosi    = 1'b1;
	assign	o_oled_dcn     = 1'b1;

	// Null bus master
	// {{{
	// }}}
	// Null interrupt definitions
	// {{{
	assign	oled_int = 1'b0;	// oled.INT.OLED.WIRE
	// }}}
	// }}}
`endif	// OLEDBW_ACCESS

`ifdef	MICROPHONE_ACCESS
	// {{{
	wbmic #(.DEFAULT_RELOAD(@$.CLKSPERSAMPLE))
		microphone(i_clk, 1'b0,
			wb32_pmic_cyc, wb32_pmic_stb, wb32_pmic_we,
			wb32_pmic_addr[1-1:0],
			wb32_pmic_data, // 32 bits wide
			wb32_pmic_sel,  // 32/8 bits wide
		wb32_pmic_stall, wb32_pmic_ack, wb32_pmic_idata,
			o_mic_csn, o_mic_sck, i_mic_din, pmic_int);
	// }}}
`else	// MICROPHONE_ACCESS
	// {{{
	assign	o_mic_csn    = 1'b1;
	assign	o_mic_sck    = 1'b1;
	// Null bus slave
	// {{{

	//
	// In the case that there is no wb32_pmic peripheral
	// responding on the wb32 bus
	assign	wb32_pmic_ack   = 1'b0;
	assign	wb32_pmic_err   = (wb32_pmic_stb);
	assign	wb32_pmic_stall = 0;
	assign	wb32_pmic_idata = 0;

	// }}}
	// Null interrupt definitions
	// {{{
	assign	pmic_int = 1'b0;	// pmic.INT.MIC.WIRE
	// }}}
	// }}}
`endif	// MICROPHONE_ACCESS

	////////////////////////////////////////////////////////////////////////
	//
	// WBUBUS "wbu_arbiter" master->slave connection
	// {{{

	wbupsz #(
		// {{{
		// Slave bus address width : 30
		// Slave address width     : 29
		// Master bus address width: 27
		.ADDRESS_WIDTH(27+$clog2(128/8)),
		.SMALL_DW(32),
		.WIDE_DW(128),
		.OPT_LITTLE_ENDIAN(1'b0)
		// }}}
	) u_wbu_wbwide_downsz (
		// {{{
		.i_clk(i_clk),
		.i_reset(i_reset),
		.i_scyc(wbu_wbu_arbiter_cyc), .i_sstb(wbu_wbu_arbiter_stb), .i_swe(wbu_wbu_arbiter_we),
			.i_saddr(wbu_wbu_arbiter_addr[29-1:0]),
			.i_sdata(wbu_wbu_arbiter_data), // 32 bits wide
			.i_ssel(wbu_wbu_arbiter_sel),  // 32/8 bits wide
		.o_sstall(wbu_wbu_arbiter_stall),.o_sack(wbu_wbu_arbiter_ack), .o_sdata(wbu_wbu_arbiter_idata), .o_serr(wbu_wbu_arbiter_err),
		.o_wcyc(wbwide_wbu_arbiter_cyc), .o_wstb(wbwide_wbu_arbiter_stb), .o_wwe(wbwide_wbu_arbiter_we),
			.o_waddr(wbwide_wbu_arbiter_addr[27-1:0]),
			.o_wdata(wbwide_wbu_arbiter_data), // 128 bits wide
			.o_wsel(wbwide_wbu_arbiter_sel),  // 128/8 bits wide
		.i_wstall(wbwide_wbu_arbiter_stall), .i_wack(wbwide_wbu_arbiter_ack), .i_wdata(wbwide_wbu_arbiter_idata), .i_werr(wbwide_wbu_arbiter_err)
		// }}}
	);

	// }}}
`ifdef	INCLUDE_ZIPCPU
	// {{{
	////////////////////////////////////////////////////////////////////////
	//
	// The ZipCPU/ZipSystem BUS master
	// {{{
	//
	assign	zip_int_vector = { alt_int_vector[14:8], sys_int_vector[14:6] };
	zipsystem #(
		// {{{
		.RESET_ADDRESS(RESET_ADDRESS),
		.ADDRESS_WIDTH(ZIP_ADDRESS_WIDTH + $clog2(128/8)),
		.BUS_WIDTH(128),
		.OPT_LGICACHE(12),
		.OPT_LGDCACHE(12),
		.START_HALTED(ZIP_START_HALTED),
		.RESET_DURATION(20),
		.OPT_PIPELINED(1),
`ifdef	VERILATOR
		.OPT_PROFILER(1'b1),
`else
		.OPT_PROFILER(1'b0),
`endif
`ifdef	ZIPSCOPE_SCOPE
		.OPT_TRACE_PORT(1'b1),
`else
		.OPT_TRACE_PORT(1'b0),
`endif
		.OPT_DISTRIBUTED_REGS(1),
		.EXTERNAL_INTERRUPTS(ZIP_INTS)
		// }}}
	) swic(
		// {{{
		.i_clk(i_clk), .i_reset(i_reset || i_cpu_reset),
			// Zipsys wishbone interface
			.o_wb_cyc(wbwide_zip_cyc), .o_wb_stb(wbwide_zip_stb), .o_wb_we(wbwide_zip_we),
			.o_wb_addr(wbwide_zip_addr[27-1:0]),
			.o_wb_data(wbwide_zip_data), // 128 bits wide
			.o_wb_sel(wbwide_zip_sel),  // 128/8 bits wide
		.i_wb_stall(wbwide_zip_stall), .i_wb_ack(wbwide_zip_ack), .i_wb_data(wbwide_zip_idata), .i_wb_err(wbwide_zip_err),
			.i_ext_int(zip_int_vector), .o_ext_int(zip_cpu_int),
			// Debug wishbone interface
			.i_dbg_cyc(wbu_zip_cyc || cpu_sim_cyc),
			.i_dbg_stb(cpu_sim_cyc ? cpu_sim_stb : wbu_zip_stb),
			.i_dbg_we( cpu_sim_cyc ? cpu_sim_we  : wbu_zip_we),
			.i_dbg_addr(cpu_sim_cyc? cpu_sim_addr : wbu_zip_addr[6:0]),
			.i_dbg_data (cpu_sim_cyc? cpu_sim_data : wbu_zip_data),
			.i_dbg_sel  (cpu_sim_cyc? 4'hf : wbu_zip_sel),
			.o_dbg_stall(raw_cpu_dbg_stall),
			.o_dbg_ack  (raw_cpu_dbg_ack),
			.o_dbg_data (wbu_zip_idata),
			//
			.o_cpu_debug(zip_debug),
			.o_prof_stb(cpu_prof_stb),
			.o_prof_addr(cpu_prof_addr),
			.o_prof_ticks(cpu_prof_ticks)
		// }}}
	);
	assign	zip_trigger = zip_debug[31];

	assign	wbu_zip_stall =  cpu_sim_cyc || raw_cpu_dbg_stall;
	assign	wbu_zip_ack   = !cpu_sim_cyc && raw_cpu_dbg_ack;
	assign	cpu_sim_stall = !cpu_sim_cyc || raw_cpu_dbg_stall;
	assign	cpu_sim_ack   =  cpu_sim_cyc && raw_cpu_dbg_ack;
	assign	cpu_sim_idata = wbu_zip_idata;

	// Keep Verilator happy
	// {{{
	// Verilator lint_off UNUSED
	wire	zip_unused;
	assign	zip_unused = &{ 1'b0,
			alt_int_vector[7:0], sys_int_vector[5:0]};
	// Verilator lint_on  UNUSED
	// }}}
	// }}}
	// }}}
`else	// INCLUDE_ZIPCPU
	// {{{
	// Null bus master
	// {{{
	// }}}
	// Null bus slave
	// {{{

	//
	// In the case that there is no wbu_zip peripheral
	// responding on the wbu bus
	assign	wbu_zip_ack   = 1'b0;
	assign	wbu_zip_err   = (wbu_zip_stb);
	assign	wbu_zip_stall = 0;
	assign	wbu_zip_idata = 0;

	// }}}
	// Null interrupt definitions
	// {{{
	assign	zip_cpu_int = 1'b0;	// zip.INT.ZIP.WIRE
	// }}}
	// }}}
`endif	// INCLUDE_ZIPCPU

	// }}}
endmodule // main.v
