////////////////////////////////////////////////////////////////////////////////
//
// Filename:	../demo-out/main_tb.cpp
//
// Project:	AutoFPGA, a utility for composing FPGA designs from peripherals
// {{{
// Computer Generated: This file is computer generated by AUTOFPGA. DO NOT EDIT.
// DO NOT EDIT THIS FILE!
//
// CmdLine:	./autofpga -d -o ../demo-out -I ../auto-data allclocks.txt bkram.txt buserr.txt clkcheck.txt crossbus.txt ddr3.txt edidslvscope.txt edid.txt exconsole.txt flashcfg.txt flash.txt global.txt gpio.txt gps.txt hdmi.txt i2ccpu.txt i2cdma.txt i2saudio.txt icape.txt meganet.txt mdio.txt pic.txt pwrcount.txt rtcdate.txt rtcgps.txt spio.txt sdio.txt vadj33.txt version.txt wboledbw.txt wbpmic.txt wbuarbiter.txt wbubus.txt zipcpu.txt zipmaster.txt
//
// Creator:	Dan Gisselquist, Ph.D.
//		Gisselquist Technology, LLC
//
////////////////////////////////////////////////////////////////////////////////
// }}}
// Copyright (C) 2017-2024, Gisselquist Technology, LLC
// {{{
// This program is free software (firmware): you can redistribute it and/or
// modify it under the terms of the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License, or (at
// your option) any later version.
//
// This program is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// for more details.
//
// You should have received a copy of the GNU General Public License along
// with this program.  (It's in the $(ROOT)/doc directory.  Run make with no
// target there if the PDF file isn't present.)  If not, see
// <http://www.gnu.org/licenses/> for a copy.
// }}}
// License:	GPL, v3, as defined and found on www.gnu.org,
// {{{
//		http://www.gnu.org/licenses/gpl.html
//
//
////////////////////////////////////////////////////////////////////////////////
//
// }}}
//
// SIM.INCLUDE
//
// Any SIM.INCLUDE tags you define will be pasted here.
// This is useful for guaranteeing any include functions
// your simulation needs are called.
//
#include "verilated.h"
#include "Vmain.h"
#define	BASECLASS	Vmain

#include "design.h"
#include "regdefs.h"
#include "testb.h"
#include "flashsim.h"
#include "dbluartsim.h"
#include "uartsim.h"
#include "hdmisource.h"
#include "hdmisim.h"
#include "byteswap.h"
#include "netsim.h"
#include "sdiosim.h"
#include "enetctrlsim.h"
#include "zipelf.h"

//
// SIM.DEFINES
//
// This tag is useful fr pasting in any #define values that
// might then control the simulation following.
//
#ifndef VVAR
#ifdef  ROOT_VERILATOR
#include "Vmain___024root.h"

#define VVAR(A) rootp->main__DOT_ ## A
#elif	defined(NEW_VERILATOR)
#define VVAR(A) main__DOT_ ## A
#else
#define VVAR(A) v__DOT_ ## A
#endif
#endif

#define	block_ram	rootp->main__DOT__u_bkram__DOT__mem.m_storage

////////////////////////////////////////////////////////////////////////////////
//
// ZipCPU simulation defines
// {{{
#ifndef	VVAR
#ifdef	ROOT_VERILATOR

#include "Vmain___024root.h"
#define	VVAR(A)	rootp->main__DOT_ ## A

#elif	defined(NEW_VERILATOR)
#define	VVAR(A)	main__DOT_ ## A
#else
#define	VVAR(A)	v__DOT_ ## A
#endif
#endif

#define	OPT_PIPELINED
#define	CPUVAR(A)	VVAR(_swic__DOT__thecpu__DOT__core__DOT_ ## A)

#define	cpu_break 	VVAR(_swic__DOT__cpu_break)
// }}}
class	MAINTB : public TESTB<Vmain> {
public:
		// SIM.DEFNS
		//
		// If you have any simulation components, create a
		// SIM.DEFNS tag to have those components defined here
		// as part of the main_tb.cpp function.
#ifdef	FLASH_ACCESS
	FLASHSIM	*m_flash;
#endif // FLASH_ACCESS
	DBLUARTSIM	*m_wbu;
#ifdef	GPSUART_ACCESS
	UARTSIM	*m_gpsu;
#endif // GPSUART_ACCESS
#ifdef VIDPIPE_ACCESS
	HDMISOURCE	*m_hdmirx;
	HDMIWIN		*m_hdmitx;
#endif	// VIDPIPE_ACCESS
		NETSIM	*m_net;
	SDIOSIM		*m_sdio;
#ifdef	NETCTRL_ACCESS
	ENETCTRLSIM	*m_mdio;
#endif // NETCTRL_ACCESS
	int	m_cpu_bombed;
	MAINTB(void) {
		// SIM.INIT
		//
		// If your simulation components need to be initialized,
		// create a SIM.INIT tag.  That tag's value will be pasted
		// here.
		//
		// From flash
#ifdef	FLASH_ACCESS
		m_flash = new FLASHSIM(FLASHLGLEN, false, 2, 6);
#endif // FLASH_ACCESS
		// From wbu
		m_wbu = new DBLUARTSIM();
		m_wbu->setup(100);
		// From gpsu
#ifdef	GPSUART_ACCESS
		m_gpsu = new UARTSIM(FPGAPORT+2);
		m_gpsu->setup(0x000028b0);
#endif // GPSUART_ACCESS
		// From hdmi
#ifdef	VIDPIPE_ACCESS
		m_hdmirx = NULL;
		m_hdmitx = NULL;
		if (gbl_use_gui) {
			m_hdmirx = new HDMISOURCE(800, 600);
			m_hdmitx = new HDMIWIN(800, 600);
		}
#endif	// VIDPIPE_ACCESS
		// From net
		// Network init
		// {{{
		m_net = new NETSIM(); // DBGPORT: 6784, DATAPORT: 6785;
		m_net->external_mac[0] = 0xde;
		m_net->external_mac[1] = 0xad;
		m_net->external_mac[2] = 0xbe;
		m_net->external_mac[3] = 0xef;
		m_net->external_mac[4] = 0xda;
		m_net->external_mac[5] = 0xd0 | (200 & 0x0f);
		m_net->external_ip[0] = 127;
		m_net->external_ip[1] = 0;
		m_net->external_ip[2] = 0;
		m_net->external_ip[3] = 1;
		m_net->local_mac[0] = 0x82 & 0x0ff;
		m_net->local_mac[1] = 0x33 & 0x0ff;
		m_net->local_mac[2] = 0x48 & 0x0ff;
		m_net->local_mac[3] = 0x02 & 0x0ff;
		m_net->local_mac[4] = 0xe1 & 0x0ff;
		m_net->local_mac[5] = 0xc8 & 0x0ff;
		m_net->local_ip[0] = 0xc0 & 0x0ff; // 192
		m_net->local_ip[1] = 0xa8 & 0x0ff; // 168
		m_net->local_ip[2] = 0x0f & 0x0ff; //  15
		m_net->local_ip[3] = 0x1d & 0x0ff; //  29
		m_net->local_ipu = 0xc0a80f1d;
		// }}}
		// From sdio
#ifdef	SDIO_ACCESS
		m_sdio = new SDIOSIM("sdcard.img");
		m_core->i_sdio_detect = 1;
		m_core->i_sdio_crcack = 0;
		m_core->i_sdio_crcnak = 0;
#endif
		// From mdio
#ifdef	NETCTRL_ACCESS
		m_mdio = new ENETCTRLSIM;
#endif // NETCTRL_ACCESS
		// From zip
		m_cpu_bombed = 0;
	}

	void	reset(void) {
		// SIM.SETRESET
		// If your simulation component needs logic before the
		// tick with reset set, that logic can be placed into
		// the SIM.SETRESET tag and thus pasted here.
		//
		m_core->i_cpu_reset = 1;
		TESTB<Vmain>::reset();
		// SIM.CLRRESET
		// If your simulation component needs logic following the
		// reset tick, that logic can be placed into the
		// SIM.CLRRESET tag and thus pasted here.
		//
		m_core->i_cpu_reset = 0;
	}

	void	trace(const char *vcd_trace_file_name) {
		fprintf(stderr, "Opening TRACE(%s)\n",
				vcd_trace_file_name);
		opentrace(vcd_trace_file_name);
		m_time_ps = 0;
	}

	void	close(void) {
		m_done = true;
	}

	void	tick(void) {
		TESTB<Vmain>::tick(); // Clock.size = 4
	}


	// Evaluating clock clk

	// sim_clk_tick() will be called from TESTB<Vmain>::tick()
	//   following any falling edge of clock clk
	virtual	void	sim_clk_tick(void) {
		// Default clock tick
		//
		// SIM.TICK tags go here for SIM.CLOCK=clk
		//
		// SIM.TICK from flash
#ifdef	FLASH_ACCESS
		m_core->i_flash_dat = m_flash->simtick(
			m_core->o_flash_cs_n,
			m_core->o_flash_sck,
			m_core->o_flash_dat,
			m_core->o_flash_mod);
#endif // FLASH_ACCESS
		// SIM.TICK from i2c
		m_core->i_i2c_scl = m_core->o_i2c_scl;
		m_core->i_i2c_sda = m_core->o_i2c_sda;
		// SIM.TICK from wbu
		m_core->i_wbu_uart_rx = (*m_wbu)(m_core->o_wbu_uart_tx);
		// SIM.TICK from edid
		m_core->i_edid_scl = m_core->o_edid_scl;
		m_core->i_edid_sda = m_core->o_edid_sda;
		// SIM.TICK from pxclk
		m_core->i_pxclk_stall = 0;
		m_core->i_pxclk_ack   = m_core->o_pxclk_stb;
		m_core->i_pxclk_idata = m_core->o_pxclk_data;
		// SIM.TICK from sdio
#ifdef	SDIO_ACCESS
		{ unsigned	tmp, tmp_async;
		m_sdio->apply(
			(unsigned)m_core->o_sdio_sdclk,
			(unsigned)m_core->o_sdio_cfg_ddr,
			(unsigned)m_core->o_sdio_cmd_en,
			(unsigned)m_core->o_sdio_cmd_data,
			(unsigned)m_core->o_sdio_data_en,
			(unsigned)m_core->o_sdio_rx_en,
			(unsigned)m_core->o_sdio_tx_data,
			tmp, tmp_async,
			m_core->i_sdio_ad_data);
		m_core->i_sdio_cmd_strb = (tmp >> 30) & 3;
		m_core->i_sdio_cmd_data = (tmp >> 28) & 3;
		m_core->i_sdio_rx_strb  = (tmp >> 24) & 3;
		m_core->i_sdio_rx_data  =  tmp & 0x0ffff;
		m_core->i_sdio_ac_valid = (tmp_async & 2) ? 1:0;
		m_core->i_sdio_ad_valid =  tmp_async & 1;
		m_core->i_sdio_detect = 1;
		m_core->i_sdio_card_busy = m_sdio->card_busy() ? 1:0;
		m_core->i_sdio_crcack = m_sdio->crctoken();
		m_core->i_sdio_crcnak = (m_core->i_sdio_crcack & 2)?1:0;
		m_core->i_sdio_crcack &= 1;

		if (!m_core->o_sdio_cfg_dscmd) {
			m_core->i_sdio_ac_valid = 0;
			m_core->i_sdio_ac_data = 0;
		} if (!m_core->o_sdio_cfg_ds) {
			m_core->i_sdio_ad_valid = 0;
			m_core->i_sdio_ad_data = 0;
		} }
#endif
		// SIM.TICK from mdio
#ifdef	NETCTRL_ACCESS
		m_core->i_mdio = (*m_mdio)((m_core->i_reset)?1:0,
				m_core->o_mdclk,
				((m_core->o_mdwe)&&(!m_core->o_mdio))?0:1);
#else
		m_core->i_mdio = ((m_core->o_mdwe)&&(!m_core->o_mdio))?0:1;
#endif // NETCTRL_ACCESS
		// SIM.TICK from zip
#ifdef	INCLUDE_ZIPCPU
		// ZipCPU Sim instruction support
		// {{{
		if (m_cpu_bombed) {
			if (m_cpu_bombed++ > 12)
				m_done = true;
		} else if (m_core->cpu_break) {
			printf("\n\nBOMB : CPU BREAK RECEIVED\n");
			m_cpu_bombed++;
		}
		// }}}
#endif	// INCLUDE_ZIPCPU

	}

	// Evaluating clock pixclk

	// sim_pixclk_tick() will be called from TESTB<Vmain>::tick()
	//   following any falling edge of clock pixclk
	virtual	void	sim_pixclk_tick(void) {
		//
		// SIM.TICK tags go here for SIM.CLOCK=pixclk
		//
		// SIM.TICK from hdmi
#ifdef	VIDPIPE_ACCESS
		// Simulate both an external HDMI source and monitor
		if (gbl_use_gui) {
			int	r, g, b;

			// HDMI input received by the design
			(*m_hdmirx)(b, g, r);
			m_core->i_hdmi_blu = b;
			m_core->i_hdmi_grn = g;
			m_core->i_hdmi_red = r;

			m_core->i_pxpll_locked = 1;

			// HDMI output, transmitted from the design
			(*m_hdmitx)(m_core->o_hdmi_blu, m_core->o_hdmi_grn,
					m_core->o_hdmi_red);
		}
#endif	// VIDPIPE_ACCESS
	}

	// Evaluating clock net_rx_clk

	// sim_net_rx_clk_tick() will be called from TESTB<Vmain>::tick()
	//   following any falling edge of clock net_rx_clk
	virtual	void	sim_net_rx_clk_tick(void) {
		//
		// SIM.TICK tags go here for SIM.CLOCK=net_rx_clk
		//
		// SIM.TICK from net
		// Simulate the network
		// {{{
		{
			unsigned rxtmp = (*m_net)(m_core->o_net_reset_n,
					m_core->o_net_tx_ctl,
					m_core->o_net_txd);

			m_core->i_net_rx_err = 0;
			if (rxtmp & 0x0100) {
				m_core->i_net_rx_dv  = 1;
				m_core->i_net_rxd = rxtmp & 0x0ff;
			} else {
				m_core->i_net_rx_dv  = 0;
				m_core->i_net_rxd = 0x044;
			}
		}
		// }}}
	}

	// Evaluating clock clk_125mhz

	// sim_clk_125mhz_tick() will be called from TESTB<Vmain>::tick()
	//   following any falling edge of clock clk_125mhz
	virtual	void	sim_clk_125mhz_tick(void) {
		//
		// SIM.TICK tags go here for SIM.CLOCK=clk_125mhz
		//
		// No SIM.TICK tags defined
		m_changed = false;
	}
	//
	// Step until clock clk ticks
	//
	virtual	void	tick_clk(void) {
		// Advance until the default clock ticks
		do {
			tick();
		} while(!m_clk.rising_edge());
	}

	//
	// Step until clock pixclk ticks
	//
	virtual	void	tick_pixclk(void) {
		do {
			tick();
		} while(!m_pixclk.rising_edge());
	}

	//
	// Step until clock net_rx_clk ticks
	//
	virtual	void	tick_net_rx_clk(void) {
		do {
			tick();
		} while(!m_net_rx_clk.rising_edge());
	}

	//
	// Step until clock clk_125mhz ticks
	//
	virtual	void	tick_clk_125mhz(void) {
		do {
			tick();
		} while(!m_clk_125mhz.rising_edge());
	}

	//
	// The load function
	//
	// This function is required by designs that need the flash or memory
	// set prior to run time.  The test harness should be able to call
	// this function to load values into any (memory-type) location
	// on the bus.
	//
	bool	load(uint32_t addr, const char *buf, uint32_t len) {
		uint32_t	start, offset, wlen, base, adrln;

		//
		// Loading the flash component
		//
		base  = 0x01000000; // in octets
		adrln = 0x01000000;

		if ((addr >= base)&&(addr < base + adrln)) {
			// If the start access is in flash
			start = (addr > base) ? (addr-base) : 0;
			offset = (start + base) - addr;
			wlen = (len-offset > adrln - start)
				? (adrln - start) : len - offset;
#ifdef	FLASH_ACCESS
			// FROM flash.SIM.LOAD
			m_flash->load(start, &buf[offset], wlen);
			// AUTOFPGA::Now clean up anything else
			// Was there more to write than we wrote?
			if (addr + len > base + adrln)
				return load(base + adrln, &buf[offset+wlen], len-wlen);
			return true;
#else	// FLASH_ACCESS
			return false;
#endif	// FLASH_ACCESS
		//
		// End of components with a SIM.LOAD tag, and a
		// non-zero number of addresses (NADDR)
		//
		}

		//
		// Loading the bkram component
		//
		base  = 0x10000000; // in octets
		adrln = 0x00100000;

		if ((addr >= base)&&(addr < base + adrln)) {
			// If the start access is in bkram
			start = (addr > base) ? (addr-base) : 0;
			offset = (start + base) - addr;
			wlen = (len-offset > adrln - start)
				? (adrln - start) : len - offset;
#ifdef	BKRAM_ACCESS
			// FROM bkram.SIM.LOAD
			start = start & (-4);
			wlen = (wlen+3)&(-4);

			// Need to byte swap data to get it into the memory
			if (128 == 32) {
				char	*bswapd = new char[len+8];
				memcpy(bswapd, &buf[offset], wlen);
				byteswapbuf(len>>2, (uint32_t *)bswapd);
				memcpy(&m_core->block_ram[start], bswapd, wlen);
				delete[] bswapd;
			} else {
				for(unsigned jk=0; jk<wlen; jk=jk+1) {
					unsigned word_addr, subword_addr;
					unsigned	*wp;
					char		*cp;

					word_addr = start+jk;
					word_addr /= 128/8;
					wp = m_core->block_ram[word_addr];
					cp = (char *)wp;

					subword_addr = start+jk;
					subword_addr = ~subword_addr;
					subword_addr &= 128/8-1;
					// subword_addr = 128/8-subword_addr;
					cp[subword_addr] = buf[offset+jk];
				}
			}
			// AUTOFPGA::Now clean up anything else
			// Was there more to write than we wrote?
			if (addr + len > base + adrln)
				return load(base + adrln, &buf[offset+wlen], len-wlen);
			return true;
#else	// BKRAM_ACCESS
			return false;
#endif	// BKRAM_ACCESS
		//
		// End of components with a SIM.LOAD tag, and a
		// non-zero number of addresses (NADDR)
		//
		}

		return false;
	}

	//
	// KYSIM.METHODS
	//
	// If your simulation code will need to call any of its own function
	// define this tag by those functions (or other sim code), and
	// it will be pasated here.
	//
	void	connect_idler(void) {
		Glib::signal_idle().connect(
			sigc::mem_fun((*this),&MAINTB::on_tick));
	}

	bool	on_tick(void) {
		for(int i=0; i<15; i++)
			tick();
		return true;
	}
#ifdef	INCLUDE_ZIPCPU
	// ZipCPU Access functions
	// {{{
	void	loadelf(const char *elfname) {
		// {{{
		ELFSECTION	**secpp, *secp;
		uint32_t	entry;

		elfread(elfname, entry, secpp);

		for(int s=0; secpp[s]->m_len; s++) {
			bool	successful_load;
			secp = secpp[s];

			successful_load = load(secp->m_start,
				secp->m_data, secp->m_len);

			if (!successful_load) {
				printf("Could not load section "
					"from %08x to %08x--no such address\n",
					secp->m_start,
					secp->m_start+secp->m_len);
			}
		} free(secpp);
	}
	// }}}

	void	cpu_dbg_write(const uint32_t addr, const uint32_t data) {
		// {{{
		// printf("CPU-DBG-WRITE(@0x%08x, 0x%08x);\n", addr, data);
		m_core->cpu_sim_cyc   = 1;
		m_core->cpu_sim_stb   = 1;
		m_core->cpu_sim_we    = 1;
		m_core->cpu_sim_addr  = addr >> 2;
		m_core->cpu_sim_data  = data;

		do {
			tick_clk();
		} while(m_core->cpu_sim_stall);

		m_core->cpu_sim_stb = 0;

		while(!m_core->cpu_sim_ack)
			tick_clk();

		m_core->cpu_sim_cyc  = 0;
		m_core->cpu_sim_we   = 0;
		m_core->cpu_sim_addr = 0;
		m_core->cpu_sim_data = 0;

		tick_clk();
	}
	// }}}

	uint32_t cpu_dbg_read(const uint32_t addr) {
		// {{{
		unsigned	result;

		// printf("CPU-DBG-WRITE(@0x%08x, 0x%08x);\n", addr, data);
		m_core->cpu_sim_cyc   = 1;
		m_core->cpu_sim_stb   = 1;
		m_core->cpu_sim_we    = 0;
		m_core->cpu_sim_addr  = addr >> 2;
		m_core->cpu_sim_data  = 0;

		do {
			tick_clk();
		} while(m_core->cpu_sim_stall);

		m_core->cpu_sim_stb = 0;

		while(!m_core->cpu_sim_ack)
			tick_clk();

		result = m_core->cpu_sim_idata;

		m_core->cpu_sim_cyc  = 0;
		m_core->cpu_sim_we   = 0;
		m_core->cpu_sim_addr = 0;
		m_core->cpu_sim_data = 0;

		tick_clk();

		return result;
	}
	// }}}

	// }}}
#endif // INCLUDE_ZIPCPU

};
